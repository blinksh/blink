# Ukrainian translation for coreutils.
# Copyright (C) 2006 Free Software Foundation, Inc.
# This file is put in the public domain.
#
# Maxim Dziumanenko <dziumanenko@gmail.com>, 2007-2009.
# sevenfourk <sevenfourk@gmail.com>, 2009.
# Yuri Chornoivan <yurchor@ukr.net>, 2011, 2012, 2013, 2014, 2015, 2016, 2017.
msgid ""
msgstr ""
"Project-Id-Version: coreutils 8.27-pre1\n"
"Report-Msgid-Bugs-To: bug-coreutils@gnu.org\n"
"POT-Creation-Date: 2017-03-08 21:02-0800\n"
"PO-Revision-Date: 2017-03-02 18:50+0200\n"
"Last-Translator: Yuri Chornoivan <yurchor@ukr.net>\n"
"Language-Team: Ukrainian <translation-team-uk@lists.sourceforge.net>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 1.5\n"

#: lib/argmatch.c:134
#, c-format
msgid "invalid argument %s for %s"
msgstr "неправильний аргумент %s для %s"

#: lib/argmatch.c:135
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "неоднозначний аргумент %s для %s"

#: lib/argmatch.c:154
msgid "Valid arguments are:"
msgstr "Допустимі аргументи:"

#: lib/closein.c:100
msgid "error closing file"
msgstr "помилка при закритті файла"

#: lib/closeout.c:112 src/base64.c:139 src/base64.c:151 src/base64.c:157
#: src/base64.c:198 src/base64.c:254 src/cat.c:187 src/cat.c:203 src/cat.c:287
#: src/cksum.c:251 src/expand.c:152 src/expand.c:177 src/factor.c:2387
#: src/mktemp.c:339 src/od.c:969 src/paste.c:163 src/shuf.c:600 src/split.c:924
#: src/split.c:1178 src/split.c:1183 src/tail.c:1245 src/tail.c:1391
#: src/tail.c:2391 src/tr.c:1588 src/tr.c:1808 src/tr.c:1900 src/unexpand.c:234
#: src/unexpand.c:250
#, c-format
msgid "write error"
msgstr "помилка запису"

#: lib/copy-acl.c:54 src/copy.c:1390 src/copy.c:2851
#, c-format
msgid "preserving permissions for %s"
msgstr "збереження прав доступу для %s"

#: lib/error.c:191
msgid "Unknown system error"
msgstr "Невідома системна помилка"

#: lib/file-type.c:40
msgid "regular empty file"
msgstr "звичайний порожній файл"

#: lib/file-type.c:40
msgid "regular file"
msgstr "звичайний файл"

#: lib/file-type.c:43
msgid "directory"
msgstr "каталог"

#: lib/file-type.c:46
msgid "symbolic link"
msgstr "символічне посилання"

#: lib/file-type.c:52
msgid "message queue"
msgstr "черга повідомлень"

#: lib/file-type.c:55
msgid "semaphore"
msgstr "семафор"

#: lib/file-type.c:58
msgid "shared memory object"
msgstr "об'єкт спільній пам'яті"

#: lib/file-type.c:61
msgid "typed memory object"
msgstr "об'єкт типізованої пам'яті"

#: lib/file-type.c:66
msgid "block special file"
msgstr "файл блокового пристрою"

#: lib/file-type.c:69
msgid "character special file"
msgstr "файл символьного пристрою"

#: lib/file-type.c:72
msgid "contiguous data"
msgstr "неперервні дані"

#: lib/file-type.c:75
msgid "fifo"
msgstr "fifo"

#: lib/file-type.c:78
msgid "door"
msgstr "двері"

#: lib/file-type.c:81
msgid "multiplexed block special file"
msgstr "спеціальний файл ущільненого блокового пристрою"

#: lib/file-type.c:84
msgid "multiplexed character special file"
msgstr "спеціальний файл ущільненого символьного пристрою"

#: lib/file-type.c:87
msgid "multiplexed file"
msgstr "ущільнений файл"

#: lib/file-type.c:90
msgid "named file"
msgstr "іменований файл"

#: lib/file-type.c:93
msgid "network special file"
msgstr "спеціальний мережевий файл"

#: lib/file-type.c:96
msgid "migrated file with data"
msgstr "перенесений файл з даними"

#: lib/file-type.c:99
msgid "migrated file without data"
msgstr "перенесений файл без даних"

#: lib/file-type.c:102
msgid "port"
msgstr "порт"

#: lib/file-type.c:105
msgid "socket"
msgstr "сокет"

#: lib/file-type.c:108
msgid "whiteout"
msgstr "забілювання"

#: lib/file-type.c:110
msgid "weird file"
msgstr "дивний файл"

#: lib/gai_strerror.c:57
msgid "Address family for hostname not supported"
msgstr "Сімейство адрес не підтримується для цього вузла"

#: lib/gai_strerror.c:58
msgid "Temporary failure in name resolution"
msgstr "Тимчасова помилка розв'язання назв"

#: lib/gai_strerror.c:59
msgid "Bad value for ai_flags"
msgstr "Неправильне значення ai_flags"

#: lib/gai_strerror.c:60
msgid "Non-recoverable failure in name resolution"
msgstr "Критична помилка при розв'язанні назв"

#: lib/gai_strerror.c:61
msgid "ai_family not supported"
msgstr "ai_family не підтримується"

#: lib/gai_strerror.c:62
msgid "Memory allocation failure"
msgstr "Помилка виділення пам'яті"

#: lib/gai_strerror.c:63
msgid "No address associated with hostname"
msgstr "З даною назвою вузла не пов'язано жодної адреси"

#: lib/gai_strerror.c:64
msgid "Name or service not known"
msgstr "Невідома назва чи сервіс"

#: lib/gai_strerror.c:65
msgid "Servname not supported for ai_socktype"
msgstr "Servname не підтримується для ai_socktype"

#: lib/gai_strerror.c:66
msgid "ai_socktype not supported"
msgstr "ai_socktype не підтримується"

#: lib/gai_strerror.c:67
msgid "System error"
msgstr "Системна помилка"

#: lib/gai_strerror.c:68
msgid "Argument buffer too small"
msgstr "Буфер аргументів надто малий"

#: lib/gai_strerror.c:70
msgid "Processing request in progress"
msgstr "Триває обробка запиту"

#: lib/gai_strerror.c:71
msgid "Request canceled"
msgstr "Запит скасовано"

#: lib/gai_strerror.c:72
msgid "Request not canceled"
msgstr "Запит не скасовано"

#: lib/gai_strerror.c:73
msgid "All requests done"
msgstr "Всі запити завершені"

#: lib/gai_strerror.c:74
msgid "Interrupted by a signal"
msgstr "Перервано за сигналом"

#: lib/gai_strerror.c:75
msgid "Parameter string not correctly encoded"
msgstr "Неправильно закодований рядок параметрів"

#: lib/gai_strerror.c:87
msgid "Unknown error"
msgstr "Невідома помилка"

#: lib/getopt.c:575 lib/getopt.c:604
#, c-format
msgid "%s: option '%s' is ambiguous; possibilities:"
msgstr "%s: неоднозначний параметр «%s»; можливі варіанти:"

#: lib/getopt.c:619
#, c-format
msgid "%s: option '%s' is ambiguous\n"
msgstr "%s: параметр «%s» не є однозначним\n"

#: lib/getopt.c:654 lib/getopt.c:658
#, c-format
msgid "%s: option '--%s' doesn't allow an argument\n"
msgstr "%s: додавання аргументів до параметра «--%s» не передбачено\n"

#: lib/getopt.c:667 lib/getopt.c:672
#, c-format
msgid "%s: option '%c%s' doesn't allow an argument\n"
msgstr "%s: додавання аргументів до параметра «%c%s» не передбачено\n"

#: lib/getopt.c:715 lib/getopt.c:734
#, c-format
msgid "%s: option '--%s' requires an argument\n"
msgstr "%s: до параметра «--%s» слід додати аргумент\n"

#: lib/getopt.c:772 lib/getopt.c:775
#, c-format
msgid "%s: unrecognized option '--%s'\n"
msgstr "%s: невідомий параметр «--%s»\n"

#: lib/getopt.c:783 lib/getopt.c:786
#, c-format
msgid "%s: unrecognized option '%c%s'\n"
msgstr "%s: невідомий параметр «%c%s»\n"

#: lib/getopt.c:835 lib/getopt.c:838
#, c-format
msgid "%s: invalid option -- '%c'\n"
msgstr "%s: некоректний параметр — «%c»\n"

#: lib/getopt.c:891 lib/getopt.c:908 lib/getopt.c:1118 lib/getopt.c:1136
#, c-format
msgid "%s: option requires an argument -- '%c'\n"
msgstr "%s: до параметра слід додати аргумент — «%c»\n"

#: lib/getopt.c:964 lib/getopt.c:980
#, c-format
msgid "%s: option '-W %s' is ambiguous\n"
msgstr "%s: параметр «-W %s» не є однозначним\n"

#: lib/getopt.c:1004 lib/getopt.c:1022
#, c-format
msgid "%s: option '-W %s' doesn't allow an argument\n"
msgstr "%s: додавання аргументів до параметра «-W %s» не передбачено\n"

#: lib/getopt.c:1043 lib/getopt.c:1061
#, c-format
msgid "%s: option '-W %s' requires an argument\n"
msgstr "%s: до параметра «-W %s» слід додати аргумент\n"

#: lib/mkdir-p.c:179 src/install.c:512
#, c-format
msgid "cannot change permissions of %s"
msgstr "Не вдалося змінити права доступу до %s"

#: lib/mkdir-p.c:189 src/copy.c:2474 src/install.c:740 src/install.c:753
#, c-format
msgid "cannot create directory %s"
msgstr "Не вдалося створити каталог %s"

#: lib/obstack.c:338 lib/obstack.c:340 lib/xalloc-die.c:34 src/csplit.c:233
#: src/tac.c:442
#, c-format
msgid "memory exhausted"
msgstr "пам'ять вичерпано"

# c-format
#: lib/openat-die.c:38
#, c-format
msgid "unable to record current working directory"
msgstr "не вдалося зберегти поточний робочий каталог"

#: lib/openat-die.c:57 src/find-mount-point.c:107
#, c-format
msgid "failed to return to initial working directory"
msgstr "не вдалося повернутись до початкового робочого каталогу"

#. TRANSLATORS:
#. Get translations for open and closing quotation marks.
#. The message catalog should translate "`" to a left
#. quotation mark suitable for the locale, and similarly for
#. "'".  For example, a French Unicode local should translate
#. these to U+00AB (LEFT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), respectively.
#.
#. If the catalog has no translation, we will try to
#. use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and
#. Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the
#. current locale is not Unicode, locale_quoting_style
#. will quote 'like this', and clocale_quoting_style will
#. quote "like this".  You should always include translations
#. for "`" and "'" even if U+2018 and U+2019 are appropriate
#. for your locale.
#.
#. If you don't know what to put here, please see
#. <http://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>
#. and use glyphs suitable for your language.
#: lib/quotearg.c:354
msgid "`"
msgstr "«"

#: lib/quotearg.c:355
msgid "'"
msgstr "»"

#: lib/randread.c:128
#, c-format
msgid "%s: end of file"
msgstr "%s: кінець файла"

#: lib/randread.c:128 src/du.c:1074 src/md5sum.c:796 src/od.c:953 src/tac.c:251
#: src/tac.c:357 src/tac.c:515 src/tac.c:596 src/wc.c:791
#, c-format
msgid "%s: read error"
msgstr "%s: помилка читання"

#: lib/regcomp.c:135
msgid "Success"
msgstr "Виконано"

#: lib/regcomp.c:138
msgid "No match"
msgstr "Немає збігів"

#: lib/regcomp.c:141
msgid "Invalid regular expression"
msgstr "Неправильний регулярний вираз"

#: lib/regcomp.c:144
msgid "Invalid collation character"
msgstr "Неправильний символ порівняння"

#: lib/regcomp.c:147
msgid "Invalid character class name"
msgstr "Некоректна назва класу символу"

#: lib/regcomp.c:150
msgid "Trailing backslash"
msgstr "Зворотна коса риска наприкінці"

#: lib/regcomp.c:153
msgid "Invalid back reference"
msgstr "Неправильне зворотне посилання"

#: lib/regcomp.c:156
msgid "Unmatched [, [^, [:, [., or [="
msgstr "Вираз без парних [, [^, [:, [. або [="

#: lib/regcomp.c:159
msgid "Unmatched ( or \\("
msgstr "Непарна ( чи \\("

#: lib/regcomp.c:162
msgid "Unmatched \\{"
msgstr "Непарна \\{"

#: lib/regcomp.c:165
msgid "Invalid content of \\{\\}"
msgstr "Неприпустимий вміст \\{\\}"

#: lib/regcomp.c:168
msgid "Invalid range end"
msgstr "Неправильний кінець діапазону"

#: lib/regcomp.c:171
msgid "Memory exhausted"
msgstr "Скінчилась пам'ять"

#: lib/regcomp.c:174
msgid "Invalid preceding regular expression"
msgstr "Некоректний попередній регулярний вираз"

#: lib/regcomp.c:177
msgid "Premature end of regular expression"
msgstr "Передчасний кінець регулярного виразу"

#: lib/regcomp.c:180
msgid "Regular expression too big"
msgstr "Розмір виразу надто великий"

#: lib/regcomp.c:183
msgid "Unmatched ) or \\)"
msgstr "Непарна ) чи \\)"

#: lib/regcomp.c:687
msgid "No previous regular expression"
msgstr "Відсутній попередній регулярний вираз"

#: lib/root-dev-ino.h:37
#, c-format
msgid "it is dangerous to operate recursively on %s"
msgstr "небезпечно рекурсивно обробляти %s"

#: lib/root-dev-ino.h:41
#, c-format
msgid "it is dangerous to operate recursively on %s (same as %s)"
msgstr "небезпечно рекурсивно обробляти %s (те ж саме, що й %s)"

#: lib/root-dev-ino.h:43
#, c-format
msgid "use --no-preserve-root to override this failsafe"
msgstr ""
"використовуйте --no-preserve-root, щоб скасувати попередження про небезпеку"

#. TRANSLATORS: A regular expression testing for an affirmative answer
#. (english: "yes").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^yesexpr='
#: lib/rpmatch.c:150
msgid "^[yY]"
msgstr "^[yY]"

#. TRANSLATORS: A regular expression testing for a negative answer
#. (english: "no").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^noexpr='
#: lib/rpmatch.c:163
msgid "^[nN]"
msgstr "^[nN]"

#: lib/set-acl.c:46 src/copy.c:2497 src/cp.c:521
#, c-format
msgid "setting permissions for %s"
msgstr "встановлення прав доступу для %s"

#: lib/siglist.h:31
msgid "Hangup"
msgstr "Від'єднання"

#: lib/siglist.h:34
msgid "Interrupt"
msgstr "Переривання"

#: lib/siglist.h:37
msgid "Quit"
msgstr "Вихід"

#: lib/siglist.h:40
msgid "Illegal instruction"
msgstr "Помилкова інструкція"

#: lib/siglist.h:43
msgid "Trace/breakpoint trap"
msgstr "Переривання на точці зупину"

#: lib/siglist.h:46
msgid "Aborted"
msgstr "Перервано"

#: lib/siglist.h:49
msgid "Floating point exception"
msgstr "Помилка обчислень з рухомою комою"

#: lib/siglist.h:52
msgid "Killed"
msgstr "Вбито"

#: lib/siglist.h:55
msgid "Bus error"
msgstr "Помилка каналу обміну даними"

#: lib/siglist.h:58
msgid "Segmentation fault"
msgstr "Помилка адресування"

#: lib/siglist.h:61
msgid "Broken pipe"
msgstr "Канал обірвано"

#: lib/siglist.h:64
msgid "Alarm clock"
msgstr "Сигнал таймера"

#: lib/siglist.h:67
msgid "Terminated"
msgstr "Припинено"

#: lib/siglist.h:70
msgid "Urgent I/O condition"
msgstr "Термінова дія з введення-виведення"

#: lib/siglist.h:73
msgid "Stopped (signal)"
msgstr "Зупинено (сигнал)"

#: lib/siglist.h:76
msgid "Stopped"
msgstr "Зупинено"

#: lib/siglist.h:79
msgid "Continued"
msgstr "Поновлено"

#: lib/siglist.h:82
msgid "Child exited"
msgstr "Дочірній процес завершив роботу"

#: lib/siglist.h:85
msgid "Stopped (tty input)"
msgstr "Зупинено (ввід з термінала)"

#: lib/siglist.h:88
msgid "Stopped (tty output)"
msgstr "Зупинено (вивід на термінал)"

#: lib/siglist.h:91
msgid "I/O possible"
msgstr "Можливе введення-виведення"

#: lib/siglist.h:94
msgid "CPU time limit exceeded"
msgstr "Перевищено обмеження часу використання процесора"

#: lib/siglist.h:97
msgid "File size limit exceeded"
msgstr "Перевищено обмеження на розмір файла"

#: lib/siglist.h:100
msgid "Virtual timer expired"
msgstr "Збіг час на віртуальному таймері"

#: lib/siglist.h:103
msgid "Profiling timer expired"
msgstr "Збіг час профілювання"

#: lib/siglist.h:106
msgid "Window changed"
msgstr "Зміна вікна"

#: lib/siglist.h:109
msgid "User defined signal 1"
msgstr "Визначений користувачем сигнал 1"

#: lib/siglist.h:112
msgid "User defined signal 2"
msgstr "Визначений користувачем сигнал 2"

#: lib/siglist.h:117
msgid "EMT trap"
msgstr "Пастка емулятора"

#: lib/siglist.h:120
msgid "Bad system call"
msgstr "Помилковий системний виклик"

#: lib/siglist.h:123
msgid "Stack fault"
msgstr "Помилка роботи зі стеком"

#: lib/siglist.h:126
msgid "Information request"
msgstr "Інформаційний запит"

#: lib/siglist.h:128
msgid "Power failure"
msgstr "Відмова живлення"

#: lib/siglist.h:131
msgid "Resource lost"
msgstr "Втрачено ресурс"

#: lib/strsignal.c:114
#, c-format
msgid "Real-time signal %d"
msgstr "Сигнал реального часу %d"

#: lib/strsignal.c:118
#, c-format
msgid "Unknown signal %d"
msgstr "Невідомий сигнал %d"

#: lib/unicodeio.c:102
msgid "iconv function not usable"
msgstr "функцію iconv неможливо використати"

#: lib/unicodeio.c:104
msgid "iconv function not available"
msgstr "функція iconv недоступна"

#: lib/unicodeio.c:111
msgid "character out of range"
msgstr "символ поза діапазоном"

#: lib/unicodeio.c:181
#, c-format
msgid "cannot convert U+%04X to local character set"
msgstr "неможливо перетворити U+%04X у локальне кодування"

#: lib/unicodeio.c:183
#, c-format
msgid "cannot convert U+%04X to local character set: %s"
msgstr "неможливо перетворити U+%04X у локальне кодування: %s"

#: lib/userspec.c:106
msgid "invalid user"
msgstr "неправильний користувач"

#: lib/userspec.c:107
msgid "invalid group"
msgstr "неправильна група"

#: lib/userspec.c:108
msgid "invalid spec"
msgstr "неправильна специфікація"

#: lib/verror.c:73
#, c-format
msgid "unable to display error message"
msgstr "Неможливо вивести повідомлення про помилку"

#: lib/version-etc.c:74
#, c-format
msgid "Packaged by %s (%s)\n"
msgstr "Пакування виконано %s (%s)\n"

#: lib/version-etc.c:77
#, c-format
msgid "Packaged by %s\n"
msgstr "Пакування виконано %s\n"

#. TRANSLATORS: Translate "(C)" to the copyright symbol
#. (C-in-a-circle), if this symbol is available in the user's
#. locale.  Otherwise, do not translate "(C)"; leave it as-is.
#: lib/version-etc.c:84
msgid "(C)"
msgstr "©"

#: lib/version-etc.c:86
msgid ""
"\n"
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>.\n"
"This is free software: you are free to change and redistribute it.\n"
"There is NO WARRANTY, to the extent permitted by law.\n"
"\n"
msgstr ""
"\n"
"Умови ліцензування викладено у GPLv3+: GNU GPL версії 3 або новішій, <http://"
"gnu.org/licenses/gpl.html>\n"
"Це вільне програмне забезпечення: ви можете вільно змінювати і поширювати "
"його.\n"
"Вам не надається ЖОДНИХ ГАРАНТІЙ, окрім гарантій передбачених "
"законодавством.\n"

#. TRANSLATORS: %s denotes an author name.
#: lib/version-etc.c:102
#, c-format
msgid "Written by %s.\n"
msgstr "Автор програми %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:106
#, c-format
msgid "Written by %s and %s.\n"
msgstr "Автор програми %s та %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:110
#, c-format
msgid "Written by %s, %s, and %s.\n"
msgstr "Автор програми %s, %s та %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:117
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"Автор програми %s, %s, %s\n"
"та %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:124
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s та %s\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:131
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, and %s.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s, %s та %s\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:139
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, and %s.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s, %s, %s та %s\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:147
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s, %s, %s, %s та %s\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:156
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s, %s, %s, %s\n"
"%s та %s\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:167
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, %s, and others.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s, %s, %s, %s\n"
"%s, %s та інші.\n"

#. TRANSLATORS: The placeholder indicates the bug-reporting address
#. for this package.  Please add _another line_ saying
#. "Report translation bugs to <...>\n" with the address for translation
#. bugs (typically your translation team's web or email address).
#: lib/version-etc.c:245
#, c-format
msgid ""
"\n"
"Report bugs to: %s\n"
msgstr ""
"\n"
"Про вади повідомляйте за такою адресою: %s\n"

#: lib/version-etc.c:247
#, c-format
msgid "Report %s bugs to: %s\n"
msgstr "Про вади у %s повідомляйте на адресу %s\n"

#: lib/version-etc.c:251
#, c-format
msgid "%s home page: <%s>\n"
msgstr "Домашня сторінка %s: <%s>\n"

#: lib/version-etc.c:253
#, c-format
msgid "%s home page: <http://www.gnu.org/software/%s/>\n"
msgstr "%s домашня сторінка: <http://www.gnu.org/software/%s/>\n"

#: lib/version-etc.c:256
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Загальна довідка з ПЗ GNU: <http://www.gnu.org/gethelp/>\n"

#: lib/xbinary-io.c:34
#, c-format
msgid "failed to set file descriptor text/binary mode"
msgstr "не вдалося встановити текстовий/бінарний режим для дескриптора файла"

#: lib/xmemcoll.c:39 src/expr.c:877
#, c-format
msgid "string comparison failed"
msgstr "помилка порівняння рядків"

#: lib/xmemcoll.c:40
#, c-format
msgid "Set LC_ALL='C' to work around the problem."
msgstr "Щоб обійти цю проблему, встановіть LC_ALL='C'"

#: lib/xmemcoll.c:42
#, c-format
msgid "The strings compared were %s and %s."
msgstr "Помилка порівняння рядків %s та %s."

#: lib/xprintf.c:50 lib/xprintf.c:76
#, c-format
msgid "cannot perform formatted output"
msgstr "не вдалося виконати форматований вивід"

#: lib/xstrtol-error.c:63
#, c-format
msgid "invalid %s%s argument '%s'"
msgstr "некоректний аргумент %s%s — «%s»"

#: lib/xstrtol-error.c:68
#, c-format
msgid "invalid suffix in %s%s argument '%s'"
msgstr "некоректний суфікс у аргументі %s%s: «%s»"

#: lib/xstrtol-error.c:72
#, c-format
msgid "%s%s argument '%s' too large"
msgstr "%s%s, аргумент «%s» є занадто об'ємним"

#. This is a proper name. See the gettext manual, section Names.
#: src/base64.c:36
msgid "Simon Josefsson"
msgstr "Simon Josefsson"

#: src/base64.c:65
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]\n"
"Base%d encode or decode FILE, or standard input, to standard output.\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ФАЙЛ]\n"
"Кодування чи декодування файла чи стандартного потоку вводу у форматі\n"
"Base%d, і запис у стандартний потік виводу.\n"

#: src/base64.c:73
msgid ""
"  -d, --decode          decode data\n"
"  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\n"
"  -w, --wrap=COLS       wrap encoded lines after COLS character (default "
"76).\n"
"                          Use 0 to disable line wrapping\n"
"\n"
msgstr ""
"  -d, --decode          декодувати дані\n"
"  -i, --ignore-garbage  під час декодування пропускати символи поза абеткою\n"
"  -w, --wrap=СТОВПЧИК   переносити кодовані рядки після символу СТОВПЧИК "
"(типово 76).\n"
"                          0 вимикає перенесення рядків.\n"
"\n"

#: src/base64.c:82
#, c-format
msgid ""
"\n"
"The data are encoded as described for the %s alphabet in RFC 4648.\n"
"When decoding, the input may contain newlines in addition to the bytes of\n"
"the formal %s alphabet.  Use --ignore-garbage to attempt to recover\n"
"from any other non-alphabet bytes in the encoded stream.\n"
msgstr ""
"\n"
"Дані закодовані символами з алфавіту %s, відповідно до RFC 4648. При\n"
"декодуванні ввід може містити також переведення рядків окрім байтів\n"
"формального алфавіту %s. Вкажіть ключ --ignore-garbage, щоб\n"
"спробувати ігнорувати неалфавітні знаки в закодованому потоці.\n"

#: src/base64.c:201 src/base64.c:238 src/csplit.c:277 src/csplit.c:1473
#: src/join.c:465 src/shuf.c:233 src/shuf.c:282 src/shuf.c:564
#: src/tac-pipe.c:76 src/tee.c:263 src/tr.c:1612
#, c-format
msgid "read error"
msgstr "помилка читання"

#: src/base64.c:257
msgid "invalid input"
msgstr "неправильні вхідні дані"

#: src/base64.c:294
msgid "invalid wrap size"
msgstr "неправильна величина переносу"

#: src/base64.c:312 src/basename.c:176 src/comm.c:489 src/cp.c:622
#: src/date.c:470 src/dircolors.c:449 src/du.c:1019 src/hostid.c:74
#: src/hostname.c:113 src/id.c:190 src/install.c:983 src/join.c:975
#: src/link.c:86 src/ln.c:550 src/logname.c:72 src/mknod.c:182 src/mv.c:447
#: src/nproc.c:115 src/od.c:1869 src/ptx.c:2089 src/seq.c:619 src/shuf.c:501
#: src/sort.c:4592 src/split.c:1536 src/tr.c:1763 src/tsort.c:561 src/tty.c:112
#: src/uname.c:252 src/uniq.c:533 src/uniq.c:550 src/unlink.c:82
#: src/uptime.c:253 src/users.c:147 src/wc.c:724 src/who.c:830 src/whoami.c:80
#, c-format
msgid "extra operand %s"
msgstr "зайвий операнд %s"

#: src/base64.c:343 src/cat.c:764
msgid "closing standard input"
msgstr "закривається стандартний потік вводу"

#. This is a proper name. See the gettext manual, section Names.
#: src/basename.c:29 src/chgrp.c:38 src/chmod.c:39 src/chown.c:37 src/comm.c:39
#: src/cp.c:58 src/csplit.c:45 src/cut.c:46 src/date.c:40 src/dd.c:45
#: src/df.c:45 src/dirname.c:32 src/du.c:54 src/env.c:34 src/expand.c:49
#: src/fold.c:36 src/groups.c:36 src/head.c:47 src/id.c:42 src/install.c:51
#: src/ln.c:43 src/ls.c:127 src/mkdir.c:39 src/mkfifo.c:36 src/mknod.c:37
#: src/mv.c:42 src/nice.c:40 src/nl.c:42 src/paste.c:53 src/pathchk.c:32
#: src/pinky.c:38 src/printenv.c:44 src/printf.c:68 src/rm.c:41 src/rmdir.c:37
#: src/stty.c:68 src/sum.c:39 src/tac.c:58 src/tail.c:73 src/tee.c:38
#: src/touch.c:45 src/tty.c:43 src/uname.c:61 src/unexpand.c:50 src/uniq.c:43
#: src/uptime.c:47 src/users.c:37 src/wc.c:51 src/who.c:51 src/yes.c:33
msgid "David MacKenzie"
msgstr "David MacKenzie"

#: src/basename.c:48
#, c-format
msgid ""
"Usage: %s NAME [SUFFIX]\n"
"  or:  %s OPTION... NAME...\n"
msgstr ""
"Використання: %s НАЗВА [СУФІКС]\n"
"  чи:  %s КЛЮЧ... НАЗВА...\n"

#: src/basename.c:53
msgid ""
"Print NAME with any leading directory components removed.\n"
"If specified, also remove a trailing SUFFIX.\n"
msgstr ""
"Вивести НАЗВУ з вилученням компонента каталогу на початку рядка.\n"
"Також вилучити завершальний СУФІКС (якщо вказано).\n"

#: src/basename.c:60
msgid ""
"  -a, --multiple       support multiple arguments and treat each as a NAME\n"
"  -s, --suffix=SUFFIX  remove a trailing SUFFIX; implies -a\n"
"  -z, --zero           end each output line with NUL, not newline\n"
msgstr ""
"  -a, --multiple       увімкнути підтримку декількох аргументів, вважати "
"кожен з них НАЗВОЮ\n"
"  -s, --suffix=СУФІКС  вилучити кінцевий СУФІКС; додає -a\n"
"  -z, --zero           відокремлювати пункти у виведенні символом NUL, а не "
"символом нового рядка\n"

#: src/basename.c:67
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/sort          -> \"sort\"\n"
"  %s include/stdio.h .h     -> \"stdio\"\n"
"  %s -s .h include/stdio.h  -> \"stdio\"\n"
"  %s -a any/str1 any/str2   -> \"str1\" followed by \"str2\"\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s /usr/bin/sort          -> «sort»\n"
"  %s include/stdio.h .h     -> «stdio»\n"
"  %s -s .h include/stdio.h  -> «stdio»\n"
"  %s -a any/str1 any/str2   -> «str1», потім «str2»\n"

#: src/basename.c:170 src/chcon.c:536 src/chgrp.c:279 src/chmod.c:529
#: src/chown.c:280 src/chroot.c:278 src/comm.c:481 src/csplit.c:1407
#: src/dirname.c:116 src/expr.c:317 src/join.c:1165 src/link.c:78
#: src/mkdir.c:252 src/mkfifo.c:130 src/mknod.c:171 src/nohup.c:110
#: src/pathchk.c:147 src/printf.c:693 src/readlink.c:145 src/realpath.c:237
#: src/rm.c:323 src/rmdir.c:222 src/seq.c:613 src/sleep.c:120 src/stat.c:1638
#: src/stdbuf.c:371 src/tr.c:1748 src/unlink.c:76
#, c-format
msgid "missing operand"
msgstr "відсутній операнд"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:48 src/cp.c:57 src/df.c:44 src/du.c:53 src/factor.c:129
#: src/split.c:49
msgid "Torbjorn Granlund"
msgstr "Torbjorn Granlund"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:49 src/comm.c:38 src/ls.c:126 src/rm.c:42 src/split.c:50
#: src/tee.c:37 src/uniq.c:42
msgid "Richard M. Stallman"
msgstr "Richard M. Stallman"

#: src/cat.c:88 src/df.c:1455 src/expand.c:69 src/fold.c:66 src/head.c:110
#: src/ls.c:5008 src/nl.c:176 src/paste.c:437 src/pr.c:2743 src/rm.c:134
#: src/sum.c:59 src/tac.c:132 src/tail.c:258 src/tee.c:87 src/unexpand.c:78
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "Використання: %s [КЛЮЧ]... [ФАЙЛ]...\n"

#: src/cat.c:92
msgid "Concatenate FILE(s) to standard output.\n"
msgstr "Сполучити ФАЙЛ(и) і вивести дані до стандартного виведення.\n"

#: src/cat.c:98
msgid ""
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonempty output lines, overrides -n\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      suppress repeated empty output lines\n"
msgstr ""
"\n"
"  -A, --show-all           еквівалент -vET\n"
"  -b, --number-nonblank    кількість непорожніх рядків виводу\n"
"  -e                       еквівалент -vE\n"
"  -E, --show-ends          показувати $ наприкінці кожного рядка\n"
"  -n, --number             кількість усіх рядків виводу\n"
"  -s, --squeeze-blank      не більше ніж один порожній рядок\n"

#: src/cat.c:107
msgid ""
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
msgstr ""
"  -t                       еквівалент -vT\n"
"  -T, --show-tabs          відображати символи табуляцій як  ^I\n"
"  -u                       (ігнорується)\n"
"  -v, --show-nonprinting   використовувати нотацію ^ та M-, за винятком\n"
"                           переведення рядка та табуляції\n"

#: src/cat.c:115
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s f - g  Output f's contents, then standard input, then g's contents.\n"
"  %s        Copy standard input to standard output.\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s f - g  Виводить вміст f, потім стандартний потік вводу, потім вміст g.\n"
"  %s        Копіює дані зі стандартного потоку вводу у стандартний вивід.\n"

#: src/cat.c:327
#, c-format
msgid "cannot do ioctl on %s"
msgstr "помилка ioctl на %s"

#: src/cat.c:638 src/dd.c:2394 src/seq.c:287 src/sort.c:413 src/tee.c:207
#: src/yes.c:126
#, c-format
msgid "standard output"
msgstr "стандартний вивід"

#: src/cat.c:699
#, c-format
msgid "%s: input file is output file"
msgstr "%s: вхідний файл є файлом виводу"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:36 src/runcon.c:57
msgid "Russell Coker"
msgstr "Russell Coker"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:37 src/chgrp.c:39 src/chmod.c:40 src/chown.c:38 src/cp.c:59
#: src/cut.c:47 src/dirname.c:33 src/du.c:56 src/head.c:48 src/hostid.c:33
#: src/hostname.c:34 src/mktemp.c:36 src/mv.c:43 src/nohup.c:36 src/od.c:39
#: src/pathchk.c:33 src/pwd.c:32 src/rm.c:43 src/sleep.c:35 src/sync.c:33
#: src/tail.c:75 src/tr.c:38 src/true.c:33
msgid "Jim Meyering"
msgstr "Jim Meyering"

#: src/chcon.c:100 src/runcon.c:202 src/runcon.c:233
#, c-format
msgid "failed to create security context: %s"
msgstr "не вдалося створити контексту безпеки: %s"

#: src/chcon.c:112
#, c-format
msgid "failed to set %s security context component to %s"
msgstr "не вдалося встановити %s контекст безпеки компоненту %s"

#: src/chcon.c:156 src/chcon.c:547 src/copy.c:924 src/runcon.c:216
#: src/stat.c:781
#, c-format
msgid "failed to get security context of %s"
msgstr "не вдалося встановити контекст безпеки %s"

#: src/chcon.c:166
#, c-format
msgid "can't apply partial context to unlabeled file %s"
msgstr "не вдалося застосувати частковий контекст для непозначеного файла %s"

#: src/chcon.c:190
#, c-format
msgid "failed to change context of %s to %s"
msgstr "не вдалося змінити контекст %s на %s"

#: src/chcon.c:255 src/chmod.c:218 src/chown-core.c:324 src/copy.c:725
#: src/du.c:532 src/ls.c:3174
#, c-format
msgid "cannot access %s"
msgstr "не вдалося отримати доступ до %s"

#: src/chcon.c:266 src/chmod.c:231 src/chown-core.c:337 src/du.c:512
#, c-format
msgid "cannot read directory %s"
msgstr "не вдалося прочитати каталог %s"

#: src/chcon.c:293
#, c-format
msgid "changing security context of %s\n"
msgstr "зміна контексту безпеки для %s\n"

#: src/chcon.c:327 src/chmod.c:349 src/chown-core.c:538 src/remove.c:566
#: src/selinux.c:323
#, c-format
msgid "fts_read failed"
msgstr "помилка при операції fts_read"

#: src/chcon.c:338 src/chmod.c:360 src/chown-core.c:550 src/du.c:714
#: src/remove.c:580 src/selinux.c:334
#, c-format
msgid "fts_close failed"
msgstr "помилка fts_close"

#: src/chcon.c:352
#, c-format
msgid ""
"Usage: %s [OPTION]... CONTEXT FILE...\n"
"  or:  %s [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Використання:  %s [КЛЮЧ]... КОНТЕКСТ ФАЙЛ\n"
"       або:    %s [КЛЮЧ]... [-u КОРИСТУВАЧ] [-r РОЛЬ] [-l ДІАПАЗОН] [-t ТИП] "
"ФАЙЛ...\n"
"       або:    %s [КЛЮЧ]... --reference=ЗФАЙЛ ФАЙЛ...\n"

#: src/chcon.c:358
msgid ""
"Change the SELinux security context of each FILE to CONTEXT.\n"
"With --reference, change the security context of each FILE to that of "
"RFILE.\n"
msgstr ""
"Змінює контекст захисту SELinux кожного файла ФАЙЛ на КОНТЕКСТ.\n"
"З ключем  --reference, змінює контекст безпеки кожного ФАЙЛа на контекст "
"ЗФАЙЛа.\n"

#: src/chcon.c:365 src/chgrp.c:125 src/chown.c:95
msgid ""
"      --dereference      affect the referent of each symbolic link (this is\n"
"                         the default), rather than the symbolic link itself\n"
"  -h, --no-dereference   affect symbolic links instead of any referenced "
"file\n"
msgstr ""
"      --dereference      впливає на ціль кожного символічного посилання,\n"
"                         а не на саме символічне посилання\n"
"  -h, --no-dereference   обробити символічні посилання замість файлів, на "
"які вони посилаються\n"

#: src/chcon.c:370
msgid ""
"  -u, --user=USER        set user USER in the target security context\n"
"  -r, --role=ROLE        set role ROLE in the target security context\n"
"  -t, --type=TYPE        set type TYPE in the target security context\n"
"  -l, --range=RANGE      set range RANGE in the target security context\n"
msgstr ""
"  -u, --user=КОРИСТУВАЧ  встановити користувача КОРИСТУВАЧ у цільовому "
"контексті безпеки\n"
"  -r, --role=РОЛЬ        встановити роль РОЛЬ у цільовому контексті безпеки\n"
"  -t, --type=ТИП         встановити тип ТИП у цільовому контексті безпеки\n"
"  -l, --range=ДІАПАЗОН   встановити діапазон ДІАПАЗОН у цільовому контексті "
"безпеки\n"

#: src/chcon.c:376 src/chgrp.c:134 src/chmod.c:390 src/chown.c:111
msgid ""
"      --no-preserve-root  do not treat '/' specially (the default)\n"
"      --preserve-root    fail to operate recursively on '/'\n"
msgstr ""
"      --no-preserve-root  не трактувати '/' особливим чином (типово)\n"
"      --preserve-root    перешкоджати рекурсивному виконанню на '/'\n"

#: src/chcon.c:380
msgid ""
"      --reference=RFILE  use RFILE's security context rather than "
"specifying\n"
"                         a CONTEXT value\n"
msgstr ""
"      --reference=ЗФАЙЛА використовувати контекст ЗФАЙЛА замість явного\n"
"                         вказування КОНТЕКСТ\n"

#: src/chcon.c:384 src/chgrp.c:142 src/chown.c:119
msgid "  -R, --recursive        operate on files and directories recursively\n"
msgstr "  -R, --recursive        обробляти файли і каталоги рекурсивно\n"

#: src/chcon.c:387
msgid "  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""
"  -v, --verbose          вивести діагностичні дані для кожного з оброблених "
"файлів\n"

#: src/chcon.c:390 src/chgrp.c:145 src/chown.c:122
msgid ""
"\n"
"The following options modify how a hierarchy is traversed when the -R\n"
"option is also specified.  If more than one is specified, only the final\n"
"one takes effect.\n"
"\n"
"  -H                     if a command line argument is a symbolic link\n"
"                         to a directory, traverse it\n"
"  -L                     traverse every symbolic link to a directory\n"
"                         encountered\n"
"  -P                     do not traverse any symbolic links (default)\n"
"\n"
msgstr ""
"\n"
"Вказані нижче ключі впливають на спосіб обходу ієрархії каталогів при\n"
"заданому ключі -R.  Якщо вказано декілька цих ключів, діє\n"
"лише останній.\n"
"\n"
"  -H                     якщо аргумент командного рядка є символьним\n"
"                         посиланням на каталог, перейти за ним\n"
"  -L                     переходити за кожним символьним посиланням на\n"
"                         каталог\n"
"  -P                     не переходити за символьними посиланнями (типово)\n"
"\n"

#: src/chcon.c:517 src/chgrp.c:266 src/chown.c:267
msgid "-R --dereference requires either -H or -L"
msgstr "Для комбінації ключів -R --dereference слід вказати -H або -L"

#: src/chcon.c:523
msgid "-R -h requires -P"
msgstr "при вказуванні -R -h потрібно вказати -P"

#: src/chcon.c:538 src/chgrp.c:281 src/chmod.c:531 src/chown.c:282
#: src/comm.c:483 src/csplit.c:1409 src/join.c:1167 src/link.c:80
#: src/mknod.c:173 src/tr.c:1751
#, c-format
msgid "missing operand after %s"
msgstr "пропущений операнд після %s"

#: src/chcon.c:561 src/runcon.c:250
#, c-format
msgid "invalid context: %s"
msgstr "неправильний контекст: %s"

#: src/chcon.c:567
#, c-format
msgid "conflicting security context specifiers given"
msgstr "вказано конфліктні специфікатори контексту безпеки"

#: src/chcon.c:576 src/chgrp.c:289 src/chgrp.c:307 src/chmod.c:539
#: src/chmod.c:558 src/chown.c:290 src/chown.c:319 src/cp.c:429 src/cp.c:496
#: src/mv.c:98 src/pwd.c:277 src/rm.c:333 src/touch.c:348
#, c-format
msgid "failed to get attributes of %s"
msgstr "помилка отримання атрибутів %s"

#: src/chgrp.c:93
#, c-format
msgid "invalid group: %s"
msgstr "неправильна група: %s"

#: src/chgrp.c:110
#, c-format
msgid ""
"Usage: %s [OPTION]... GROUP FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... ГРУПА ФАЙЛ...\n"
"  чи:  %s [КЛЮЧ]... --reference=ЗФАЙЛА ФАЙЛ...\n"

#: src/chgrp.c:115
msgid ""
"Change the group of each FILE to GROUP.\n"
"With --reference, change the group of each FILE to that of RFILE.\n"
"\n"
msgstr ""
"Змінити групу кожного файла ФАЙЛ на ГРУПУ.\n"
"З ключем  --reference, змінює контекст безпеки кожного ФАЙЛА на контекст "
"ЗФАЙЛА.\n"
"\n"

#: src/chgrp.c:120 src/chmod.c:385 src/chown.c:90
msgid ""
"  -c, --changes          like verbose but report only when a change is made\n"
"  -f, --silent, --quiet  suppress most error messages\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""
"  -c, --changes          подібний до verbose, але повідомити про них, лише "
"якщо внесено зміни\n"
"  -f, --silent, --quiet  придушити всі повідомлення про помилки\n"
"  -v, --verbose          вивести діагностичні дані для кожного з оброблених "
"файлів\n"

#: src/chgrp.c:130 src/chown.c:100
msgid ""
"                         (useful only on systems that can change the\n"
"                         ownership of a symlink)\n"
msgstr ""
"                         (діє лише на системі з підтримкою зміни прав\n"
"                         власності символічних посилань)\n"

#: src/chgrp.c:138
msgid ""
"      --reference=RFILE  use RFILE's group rather than specifying a\n"
"                         GROUP value\n"
msgstr ""
"      --reference=ЗФАЙЛа використовувати групу ЗФАЙЛа замість явного\n"
"                         вказування ГРУПИ\n"

#: src/chgrp.c:160
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s staff /u      Change the group of /u to \"staff\".\n"
"  %s -hR staff /u  Change the group of /u and subfiles to \"staff\".\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s staff /u      Змінює групу /u на \"staff\".\n"
"  %s -hR staff /u  Змінює групу /u та вкладених файлів на \"staff\".\n"

#: src/chmod.c:127
#, c-format
msgid "getting new attributes of %s"
msgstr "отримуються нові атрибути %s"

#: src/chmod.c:151 src/chown-core.c:146
#, c-format
msgid "neither symbolic link %s nor referent has been changed\n"
msgstr ""
"ані символьне посилання %s, ані об'єкт на який воно вказує, не були змінені\n"

#: src/chmod.c:165
#, c-format
msgid "mode of %s changed from %04lo (%s) to %04lo (%s)\n"
msgstr "режим %s змінено з %04lo (%s) на %04lo (%s)\n"

#: src/chmod.c:168
#, c-format
msgid "failed to change mode of %s from %04lo (%s) to %04lo (%s)\n"
msgstr "не вдалося змінити режим %s з %04lo (%s) на %04lo (%s)\n"

#: src/chmod.c:171
#, c-format
msgid "mode of %s retained as %04lo (%s)\n"
msgstr "права доступу %s залишені як %04lo (%s)\n"

#: src/chmod.c:238
#, c-format
msgid "cannot operate on dangling symlink %s"
msgstr "обробка небезпечного символьного посилання %s неможлива"

#: src/chmod.c:278
#, c-format
msgid "changing permissions of %s"
msgstr "зміна прав доступу для %s"

#: src/chmod.c:314
#, c-format
msgid "%s: new permissions are %s, not %s"
msgstr "%s: нові права доступу %s, а не %s"

#: src/chmod.c:374
#, c-format
msgid ""
"Usage: %s [OPTION]... MODE[,MODE]... FILE...\n"
"  or:  %s [OPTION]... OCTAL-MODE FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... РЕЖИМ[,РЕЖИМ]... ФАЙЛ\n"
"       або:    %s [КЛЮЧ]... ВІСІМК-РЕЖИМ ФАЙЛ...\n"
"       або:    %s [КЛЮЧ]... --reference=ЗФАЙЛ ФАЙЛ...\n"

#: src/chmod.c:380
msgid ""
"Change the mode of each FILE to MODE.\n"
"With --reference, change the mode of each FILE to that of RFILE.\n"
"\n"
msgstr ""
"Змінити режим для всіх файлів на РЕЖИМ.\n"
"З ключем  --reference, змінює контекст безпеки кожного ФАЙЛУ на контекст "
"ЗФАЙЛА.\n"
"\n"

#: src/chmod.c:394
msgid "      --reference=RFILE  use RFILE's mode instead of MODE values\n"
msgstr ""
"      --reference=ЗФАЙЛ  використовувати режим ЗФАЙЛа, замість значень "
"РЕЖИМ\n"

#: src/chmod.c:397
msgid "  -R, --recursive        change files and directories recursively\n"
msgstr "  -R, --recursive        змінювати файли і каталоги рекурсивно\n"

#: src/chmod.c:402
msgid ""
"\n"
"Each MODE is of the form '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.\n"
msgstr ""
"\n"
"РЕЖИМ вказується у формі '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.\n"

#: src/chmod.c:516
#, c-format
msgid "cannot combine mode and --reference options"
msgstr "не можна використовувати разом ключі режиму та --reference"

#: src/chmod.c:547
#, c-format
msgid "invalid mode: %s"
msgstr "неправильний режим: %s"

#: src/chown-core.c:157
#, c-format
msgid "changed ownership of %s from %s to %s\n"
msgstr "змінено власника %s з %s на %s\n"

#: src/chown-core.c:158
#, c-format
msgid "changed group of %s from %s to %s\n"
msgstr "змінено групу %s з %s на %s\n"

#: src/chown-core.c:159
#, c-format
msgid "no change to ownership of %s\n"
msgstr "не змінений власник %s\n"

#: src/chown-core.c:164
#, c-format
msgid "failed to change ownership of %s from %s to %s\n"
msgstr "не вдалося змінити власника %s з %s на %s\n"

#: src/chown-core.c:165
#, c-format
msgid "failed to change group of %s from %s to %s\n"
msgstr "не вдалося змінити групу %s з %s на %s\n"

#: src/chown-core.c:166 src/chown-core.c:172
#, c-format
msgid "failed to change ownership of %s\n"
msgstr "не вдалося змінити власника %s\n"

#: src/chown-core.c:170
#, c-format
msgid "failed to change ownership of %s to %s\n"
msgstr "не вдалося змінити власника %s на %s\n"

#: src/chown-core.c:171
#, c-format
msgid "failed to change group of %s to %s\n"
msgstr "помилка зміни групи %s на %s\n"

#: src/chown-core.c:179
#, c-format
msgid "ownership of %s retained as %s\n"
msgstr "власник %s залишений як %s\n"

#: src/chown-core.c:180
#, c-format
msgid "group of %s retained as %s\n"
msgstr "група %s залишена як %s\n"

#: src/chown-core.c:181
#, c-format
msgid "ownership of %s retained\n"
msgstr "власник %s залишений без змін\n"

#: src/chown-core.c:378
#, c-format
msgid "cannot dereference %s"
msgstr "не вдалося перейти за символьним посиланням %s"

#: src/chown-core.c:466
#, c-format
msgid "changing ownership of %s"
msgstr "зміна власника %s"

#: src/chown-core.c:467
#, c-format
msgid "changing group of %s"
msgstr "зміна групи для %s"

#: src/chown.c:80
#, c-format
msgid ""
"Usage: %s [OPTION]... [OWNER][:[GROUP]] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ВЛАСНИК][:[ГРУПА]] ФАЙЛ...\n"
"       або:    %s [КЛЮЧ]... --reference=ЗФАЙЛ ФАЙЛ...\n"

#: src/chown.c:85
msgid ""
"Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
"With --reference, change the owner and group of each FILE to those of "
"RFILE.\n"
"\n"
msgstr ""
"Змінити власника і/або групу для кожного з ФАЙЛів на ВЛАСНИКА і/або ГРУПУ.\n"
"З ключем  --reference, змінити власника і групу всіх ФАЙЛів на значення "
"ЗФАЙЛа.\n"

#: src/chown.c:104
msgid ""
"      --from=CURRENT_OWNER:CURRENT_GROUP\n"
"                         change the owner and/or group of each file only if\n"
"                         its current owner and/or group match those "
"specified\n"
"                         here.  Either may be omitted, in which case a "
"match\n"
"                         is not required for the omitted attribute\n"
msgstr ""
"      --from=ПОТОЧНИЙ_ВЛАСНИК:ПОТОЧНА_ГРУПА\n"
"                         змінює власника та/або групу кожного файла\n"
"                         лише якщо поточний власник та/або група\n"
"                         відповідає вказаному виразу.\n"
"                         Як група, так і власник можуть бути опущені,\n"
"                         у цьому випадку відповідність атрибута\n"
"                         не обов'язкова.\n"

#: src/chown.c:115
msgid ""
"      --reference=RFILE  use RFILE's owner and group rather than\n"
"                         specifying OWNER:GROUP values\n"
msgstr ""
"      --reference=ЗФАЙЛ  використовувати власника та групу ЗФАЙЛа замість\n"
"                         явного вказування ВЛАСНИКА:ГРУПИ\n"

#: src/chown.c:137
msgid ""
"\n"
"Owner is unchanged if missing.  Group is unchanged if missing, but changed\n"
"to login group if implied by a ':' following a symbolic OWNER.\n"
"OWNER and GROUP may be numeric as well as symbolic.\n"
msgstr ""
"\n"
"Власник не змінюється, якщо він не вказаний у аргументі.  Група також не\n"
"змінюється, якщо не вказана; але якщо після символьного ВЛАСНИКА стоїть\n"
"знак ':', вважається зміна групи на основну групу поточного\n"
"користувача.\n"
"ВЛАСНИК та ГРУПА можуть бути як числовими, так і символьними.\n"

#: src/chown.c:143
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s root /u        Change the owner of /u to \"root\".\n"
"  %s root:staff /u  Likewise, but also change its group to \"staff\".\n"
"  %s -hR root /u    Change the owner of /u and subfiles to \"root\".\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s root /u        Змінює власника /u на \"root\".\n"
"  %s root:staff /u  То же, але ще міняє групу на \"staff\".\n"
"  %s -hR root /u    Змінює власника /u та вкладених файлів на \"root\".\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/chroot.c:39
msgid "Roland McGrath"
msgstr "Roland McGrath"

#: src/chroot.c:138 src/install.c:608
#, c-format
msgid "invalid group %s"
msgstr "неправильна група %s"

#: src/chroot.c:153
#, c-format
msgid "invalid group list %s"
msgstr "некоректний список груп %s"

#: src/chroot.c:186
#, c-format
msgid ""
"Usage: %s [OPTION] NEWROOT [COMMAND [ARG]...]\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s [ПАРАМЕТР] НОВИЙКОРІНЬ [КОМАНДА [АРГУМЕНТ]...]\n"
"  або:  %s ПАРАМЕТР\n"

#: src/chroot.c:191
msgid ""
"Run COMMAND with root directory set to NEWROOT.\n"
"\n"
msgstr ""
"Виконує КОМАНДУ з вказаним кореневим каталогом.\n"
"\n"

#: src/chroot.c:196
msgid "  --groups=G_LIST        specify supplementary groups as g1,g2,..,gN\n"
msgstr ""
"  --groups=СПИСОК_ГРУП   вказати додаткові групи у форматі гр1,гр2,…,грN\n"

#: src/chroot.c:199
msgid "  --userspec=USER:GROUP  specify user and group (ID or name) to use\n"
msgstr "  --userspec=КОР:ГРУПА   вказати користувача і групу (ід. або назву)\n"

#: src/chroot.c:202
#, c-format
msgid "  --skip-chdir           do not change working directory to %s\n"
msgstr "  --skip-chdir           не змінювати робочий каталог на %s\n"

#: src/chroot.c:208
msgid ""
"\n"
"If no command is given, run '${SHELL} -i' (default: '/bin/sh -i').\n"
msgstr ""
"\n"
"Якщо команду не вказано, виконати «${SHELL} -i» (типово «/bin/sh -i»).\n"

#: src/chroot.c:287
#, c-format
msgid "option --skip-chdir only permitted if NEWROOT is old %s"
msgstr ""
"параметром --skip-chdir можна користуватися, лише якщо НОВИЙКОРІНЬ є старим "
"%s"

#: src/chroot.c:330
#, c-format
msgid "cannot change root directory to %s"
msgstr "не вдалося змінити кореневий каталог на %s"

#: src/chroot.c:334
msgid "cannot chdir to root directory"
msgstr "не вдалося перейти до кореневого каталогу"

#: src/chroot.c:376
#, c-format
msgid "no group specified for unknown uid: %d"
msgstr "не вказано групи для невідомого UID: %d"

#: src/chroot.c:401
msgid "failed to get supplemental groups"
msgstr "не вдалося отримати список додаткових груп"

#: src/chroot.c:413
msgid "failed to set supplemental groups"
msgstr "не вдалося встановити список додаткових груп"

#: src/chroot.c:419
msgid "failed to set group-ID"
msgstr "не вдалося встановити ідентифікатор групи"

#: src/chroot.c:422
msgid "failed to set user-ID"
msgstr "не вдалося встановити ідентифікатор користувача"

#: src/chroot.c:428 src/nohup.c:229 src/stdbuf.c:392 src/timeout.c:490
#, c-format
msgid "failed to run command %s"
msgstr "не вдалося виконати команду %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/cksum.c:40
msgid "Q. Frank Xia"
msgstr "Q. Frank Xia"

#: src/cksum.c:216
#, c-format
msgid "%s: file too long"
msgstr "%s: файл надто великий"

#: src/cksum.c:263
#, c-format
msgid ""
"Usage: %s [FILE]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"Використання: %s [ФАЙЛ]...\n"
"       або:    %s КЛЮЧ\n"

#: src/cksum.c:268
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
msgstr ""
"Виводить контрольну суму (CRC) та число байт для кожного ФАЙЛА.\n"
"\n"

#: src/comm.c:112 src/join.c:192
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "Використання: %s [КЛЮЧ]... ФАЙЛ1 ФАЙЛ2\n"

#: src/comm.c:116
msgid "Compare sorted files FILE1 and FILE2 line by line.\n"
msgstr "Порівнює сортовані файли ФАЙЛ1 та ФАЙЛ2 по рядках.\n"

#: src/comm.c:119 src/join.c:201
msgid ""
"\n"
"When FILE1 or FILE2 (not both) is -, read standard input.\n"
msgstr ""
"\n"
"Якщо ФАЙЛ1 або ФАЙЛ2 (але не обидва) мають значення -, читати\n"
"зі стандартного джерела вхідних даних.\n"

#: src/comm.c:123
msgid ""
"\n"
"With no options, produce three-column output.  Column one contains\n"
"lines unique to FILE1, column two contains lines unique to FILE2,\n"
"and column three contains lines common to both files.\n"
msgstr ""
"\n"
"Якщо запущений без ключів виводить результат у три стовпчики. Перший\n"
"стовпчик містить рядки, унікальні для ФАЙЛА1, другий -- унікальні для\n"
"ФАЙЛА2, а третій -- спільні для обох файлів рядки.\n"

#: src/comm.c:129
msgid ""
"\n"
"  -1              suppress column 1 (lines unique to FILE1)\n"
"  -2              suppress column 2 (lines unique to FILE2)\n"
"  -3              suppress column 3 (lines that appear in both files)\n"
msgstr ""
"\n"
"  -1              не виводити стовпчик 1 (рядки, які є лише у ФАЙЛ1)\n"
"  -2              не виводити стовпчик 2 (рядки, які є лише у ФАЙЛ2)\n"
"  -3              не виводити стовпчик 3 (рядки, які є у обох файлах)\n"

#: src/comm.c:135
msgid ""
"\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
msgstr ""
"\n"
"  --check-order     перевіряти, що вхідний потік сортований, навіть\n"
"                      якщо усі вхідні рядки утворюють пари\n"
"  --nocheck-order   не перевіряти, що вхідний потік коректно сортований\n"

#: src/comm.c:141
msgid "  --output-delimiter=STR  separate columns with STR\n"
msgstr "  --output-delimiter=РЯД  розділяти стовпчику вставляючи РЯД\n"

#: src/comm.c:144
msgid "  --total           output a summary\n"
msgstr "  --total           вивести резюме\n"

#: src/comm.c:147 src/cut.c:178 src/head.c:134 src/numfmt.c:945 src/paste.c:453
#: src/tail.c:305
msgid "  -z, --zero-terminated    line delimiter is NUL, not newline\n"
msgstr ""
"  -z, --zero-terminated    завершувати рядки нульовим байтом, а не символом "
"нового рядка\n"

#: src/comm.c:152
msgid ""
"\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
msgstr ""
"\n"
"Зауважте, що під час порівняння використовуються правила LC_COLLATE.\n"

#: src/comm.c:156
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s -12 file1 file2  Print only lines present in both file1 and file2.\n"
"  %s -3 file1 file2  Print lines in file1 not in file2, and vice versa.\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s -12 файл1 файл2  Вивести лише рядки, які є спільними для файл1 і "
"файл2.\n"
"  %s -3 файл1 файл2   Вивести рядки у файл1, яких немає у файл2, і навпаки.\n"

#: src/comm.c:238
#, c-format
msgid "file %d is not in sorted order"
msgstr "файл %d не сортований"

#: src/comm.c:402 src/du.c:1137 src/ls.c:2814 src/wc.c:852
msgid "total"
msgstr "загалом"

#: src/comm.c:458
msgid "multiple output delimiters specified"
msgstr "задано декілька розділювачів виведених даних"

#: src/copy.c:193 src/copy.c:465
#, c-format
msgid "cannot lseek %s"
msgstr "не вдалося виконати lseek для %s"

#: src/copy.c:203 src/copy.c:571
#, c-format
msgid "error deallocating %s"
msgstr "помилка під час спроби скасування розміщення %s"

#: src/copy.c:241 src/dd.c:1825 src/dd.c:2159 src/du.c:1134 src/head.c:156
#: src/head.c:307 src/head.c:389 src/head.c:585 src/head.c:667 src/head.c:736
#: src/head.c:786 src/head.c:809 src/tail.c:417 src/tail.c:510 src/tail.c:559
#: src/tail.c:652 src/tail.c:780 src/tail.c:828 src/tail.c:865 src/tail.c:1940
#: src/tail.c:1973 src/uniq.c:473
#, c-format
msgid "error reading %s"
msgstr "помилка читання %s"

#: src/copy.c:274 src/dd.c:2223 src/dd.c:2286 src/head.c:184 src/tail.c:391
#, c-format
msgid "error writing %s"
msgstr "помилка запису %s"

#: src/copy.c:305
#, c-format
msgid "overflow reading %s"
msgstr "переповнення під час читання %s"

#: src/copy.c:418
#, c-format
msgid "%s: failed to get extents info"
msgstr "%s: не вдалося отримати дані щодо розширень"

#: src/copy.c:491
#, c-format
msgid "%s: write failed"
msgstr "%s: помилка під час спроби запису"

#: src/copy.c:564 src/copy.c:1308
#, c-format
msgid "failed to extend %s"
msgstr "не вдалося розширити %s"

#: src/copy.c:806
#, c-format
msgid "clearing permissions for %s"
msgstr "очищення прав доступу для %s"

#: src/copy.c:841 src/copy.c:2700 src/cp.c:325
#, c-format
msgid "failed to preserve ownership for %s"
msgstr "не вдалося зберегти власника %s"

#: src/copy.c:867
#, c-format
msgid "failed to lookup file %s"
msgstr "не вдалося найти файл %s"

#: src/copy.c:872
#, c-format
msgid "failed to preserve authorship for %s"
msgstr "не вдалося зберегти автора %s"

#: src/copy.c:909 src/cp.c:1200 src/install.c:959 src/mkdir.c:269
#: src/mkfifo.c:144 src/mknod.c:200
#, c-format
msgid "failed to set default file creation context to %s"
msgstr "помилка встановлення типового контексту для створення файлів %s"

#: src/copy.c:939
#, c-format
msgid "failed to set default file creation context for %s"
msgstr "помилка встановлення типового контексту для створення файлів %s"

#: src/copy.c:965
#, c-format
msgid "failed to set the security context of %s"
msgstr "не вдалося встановити контекст захисту %s"

#: src/copy.c:1038 src/csplit.c:655 src/du.c:1026 src/fmt.c:439 src/head.c:888
#: src/sort.c:4604 src/split.c:1552 src/tail.c:1914 src/wc.c:736
#, c-format
msgid "cannot open %s for reading"
msgstr "не вдалося відкрити %s для читання"

#: src/copy.c:1044 src/copy.c:1197 src/dd.c:1750 src/dd.c:2298 src/dd.c:2438
#: src/head.c:847 src/tail.c:1761 src/tail.c:1817 src/truncate.c:114
#, c-format
msgid "cannot fstat %s"
msgstr "не вдалося виконати fstat для %s"

#: src/copy.c:1054
#, c-format
msgid "skipping file %s, as it was replaced while being copied"
msgstr "пропущено файл %s, оскільки він був замінений під час копіювання"

#: src/copy.c:1094 src/copy.c:2148 src/remove.c:262 src/remove.c:279
#: src/remove.c:405 src/remove.c:431
#, c-format
msgid "cannot remove %s"
msgstr "не вдалося вилучити %s"

#: src/copy.c:1099 src/copy.c:1795 src/copy.c:2153 src/remove.c:375
#, c-format
msgid "removed %s\n"
msgstr "вилучено %s\n"

#: src/copy.c:1151
#, c-format
msgid "not writing through dangling symlink %s"
msgstr "запис через через висяче символьне посилання %s не виконується"

#: src/copy.c:1189
#, c-format
msgid "cannot create regular file %s"
msgstr "не вдалося створити звичайний файл %s"

#: src/copy.c:1210
#, c-format
msgid "failed to clone %s from %s"
msgstr "не вдалося клонувати %s з %s"

#: src/copy.c:1323 src/copy.c:2774
#, c-format
msgid "preserving times for %s"
msgstr "збереження відмітки про час %s"

#: src/copy.c:1400 src/copy.c:1406 src/head.c:896 src/sync.c:162
#: src/touch.c:173 src/truncate.c:392
#, c-format
msgid "failed to close %s"
msgstr "не вдалося закрити %s"

#: src/copy.c:1684
#, c-format
msgid "%s: replace %s, overriding mode %04lo (%s)? "
msgstr "%s: замінити %s, незважаючи на права доступу %04lo (%s)? "

#: src/copy.c:1685
#, c-format
msgid "%s: unwritable %s (mode %04lo, %s); try anyway? "
msgstr "%s: непридатний до запису %s (режим %04lo, %s); спробувати пори це? "

#: src/copy.c:1692
#, c-format
msgid "%s: overwrite %s? "
msgstr "%s: переписати %s? "

#: src/copy.c:1762
#, c-format
msgid " (backup: %s)"
msgstr " (резервна копія: %s)"

#: src/copy.c:1772
msgid "failed to restore the default file creation context"
msgstr "помилка при відновленні типового контексту при створенні файла"

#: src/copy.c:1790
#, c-format
msgid "cannot create hard link %s to %s"
msgstr "не вдалося створити жорстке посилання %s на %s"

#: src/copy.c:1854 src/copy.c:1911 src/copy.c:2485 src/copy.c:2838
#: src/find-mount-point.c:84 src/install.c:702 src/realpath.c:146
#: src/stat.c:1378 src/truncate.c:338
#, c-format
msgid "cannot stat %s"
msgstr "не вдалося виконати stat для %s"

#: src/copy.c:1863
#, c-format
msgid "-r not specified; omitting directory %s"
msgstr "-r не вказано; пропускаємо каталог %s"

#: src/copy.c:1864
#, c-format
msgid "omitting directory %s"
msgstr "пропуск каталогу %s"

#: src/copy.c:1879
#, c-format
msgid "warning: source file %s specified more than once"
msgstr "попередження: вхідний файл %s вказаний більше одного разу"

#: src/copy.c:1928 src/ln.c:263
#, c-format
msgid "%s and %s are the same file"
msgstr "%s та %s - один і той самий файл"

#: src/copy.c:2018
#, c-format
msgid "cannot overwrite non-directory %s with directory %s"
msgstr "не можна перезаписати файл %s, що не є каталогом, каталогом %s"

#: src/copy.c:2036 src/ln.c:231
#, c-format
msgid "will not overwrite just-created %s with %s"
msgstr "не переписується щойно створений %s %s"

#: src/copy.c:2054
#, c-format
msgid "cannot overwrite directory %s with non-directory"
msgstr "не можна перезаписувати каталог %s файлом, що не є каталогом"

#: src/copy.c:2068
#, c-format
msgid "cannot move directory onto non-directory: %s -> %s"
msgstr "не можна перейменувати каталог на файл, що не є каталогом: %s -> %s"

#: src/copy.c:2098
#, c-format
msgid "backing up %s would destroy source;  %s not moved"
msgstr "збереження запасної копії %s знищить оригінал; %s не перенесений"

#: src/copy.c:2099
#, c-format
msgid "backing up %s would destroy source;  %s not copied"
msgstr "збереження запасної копії %s знищить оригінал; %s не скопійовано"

#: src/copy.c:2122 src/ln.c:293
#, c-format
msgid "cannot backup %s"
msgstr "не вдалося створити резервну копію для %s"

#: src/copy.c:2187
#, c-format
msgid "will not copy %s through just-created symlink %s"
msgstr "не буде копіюватися %s через щойно створене символьне посилання %s"

#: src/copy.c:2264
#, c-format
msgid "cannot copy a directory, %s, into itself, %s"
msgstr "не вдалося скопіювати каталог, %s, у самого себе, %s"

#: src/copy.c:2272
#, c-format
msgid "warning: source directory %s specified more than once"
msgstr "попередження: каталог вхідних даних %s вказано декілька разів"

#: src/copy.c:2298
#, c-format
msgid "will not create hard link %s to directory %s"
msgstr "жорстке посилання %s на каталог %s не буде створено"

#: src/copy.c:2355
#, c-format
msgid "cannot move %s to a subdirectory of itself, %s"
msgstr "не вдалося перенести %s у свій власний підкаталог, %s"

#: src/copy.c:2398
#, c-format
msgid "cannot move %s to %s"
msgstr "не вдалося перемістити %s у %s"

#: src/copy.c:2414
#, c-format
msgid "inter-device move failed: %s to %s; unable to remove target"
msgstr ""
"помилка при переміщенні з пристрою %s на пристрій %s: не вдалося вилучити "
"цільовий файл"

#: src/copy.c:2454
#, c-format
msgid "cannot copy cyclic symbolic link %s"
msgstr "не вдалося скопіювати циклічне символьне посилання %s"

#: src/copy.c:2574
#, c-format
msgid "%s: can make relative symbolic links only in current directory"
msgstr ""
"%s: відносні символьні посилання можна створювати лише у поточному каталозі"

#: src/copy.c:2583
#, c-format
msgid "cannot create symbolic link %s to %s"
msgstr "не вдалося створити символьне посилання %s на %s"

#: src/copy.c:2637 src/mkfifo.c:170
#, c-format
msgid "cannot create fifo %s"
msgstr "не вдалося створити чергу %s"

#: src/copy.c:2646
#, c-format
msgid "cannot create special file %s"
msgstr "не вдалося створити спеціальній файл %s"

#: src/copy.c:2657 src/ls.c:3383 src/stat.c:1060
#, c-format
msgid "cannot read symbolic link %s"
msgstr "не вдалося прочитати символьне посилання %s"

#: src/copy.c:2684
#, c-format
msgid "cannot create symbolic link %s"
msgstr "не вдалося створити символьне посилання %s"

#: src/copy.c:2715
#, c-format
msgid "%s has unknown file type"
msgstr "%s має невідомий тип файла"

#: src/copy.c:2878 src/ln.c:362
#, c-format
msgid "cannot un-backup %s"
msgstr "не вдалося відновити %s з резервної копії"

#: src/copy.c:2882
#, c-format
msgid "%s -> %s (unbackup)\n"
msgstr "%s -> %s (відновлення)\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/coreutils.c:48
msgid "Alex Deymo"
msgstr "Alex Deymo"

#: src/coreutils.c:65
#, c-format
msgid "Usage: %s --coreutils-prog=PROGRAM_NAME [PARAMETERS]... \n"
msgstr "Користування: %s --coreutils-prog=НАЗВА_ПРОГРАМИ [ПАРАМЕТРИ]... \n"

#: src/coreutils.c:68
msgid ""
"Execute the PROGRAM_NAME built-in program with the given PARAMETERS.\n"
"\n"
msgstr ""
"Виконати вбудовану програму НАЗВА_ПРОГРАМИ із вказаними параметрами "
"ПАРАМЕТРИ.\n"
"\n"

#: src/coreutils.c:86
#, c-format
msgid ""
"\n"
"Use: '%s --coreutils-prog=PROGRAM_NAME --help' for individual program help.\n"
msgstr ""
"\n"
"Користування: «%s --coreutils-prog=НАЗВА_ПРОГРАМИ --help» для отримання "
"довідки із вказаної програми.\n"

#: src/coreutils.c:178 src/coreutils.c:203
#, c-format
msgid "unknown program %s"
msgstr "невідома програма, %s"

#: src/cp.c:158 src/mv.c:289
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [-T] ДЖЕРЕЛО ЦІЛЬ\n"
"       або:    %s [КЛЮЧ]... ДЖЕРЕЛО... КАТАЛОГ\n"
"       або:    %s [КЛЮЧ]... -t КАТАЛОГ ДЖЕРЕЛО...\n"

#: src/cp.c:164
msgid "Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n"
msgstr "Копіює ДЖЕРЕЛО у ЦІЛЬ, або декілька ДЖЕРЕЛ у КАТАЛОГ.\n"

#: src/cp.c:170
msgid ""
"  -a, --archive                same as -dR --preserve=all\n"
"      --attributes-only        don't copy the file data, just the "
"attributes\n"
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"      --copy-contents          copy contents of special files when "
"recursive\n"
"  -d                           same as --no-dereference --preserve=links\n"
msgstr ""
"  -a, --archive                те саме що та -dR --preserve=all\n"
"      --attributes-only        не копіювати даних файла, лише атрибути\n"
"      --backup[=CONTROL]       створити резервну копію перед вилученням\n"
"  -b                           те саме, що й --backup, але без аргументу\n"
"      --copy-contents          копіює зміст спеціальних файлів при\n"
"                               рекурсивному використанні\n"
"  -d                           те саме, що й --no-dereference --"
"preserve=link\n"

#: src/cp.c:179
msgid ""
"  -f, --force                  if an existing destination file cannot be\n"
"                                 opened, remove it and try again (this "
"option\n"
"                                 is ignored when the -n option is also "
"used)\n"
"  -i, --interactive            prompt before overwrite (overrides a previous "
"-n\n"
"                                  option)\n"
"  -H                           follow command-line symbolic links in SOURCE\n"
msgstr ""
"  -f, --force                  якщо не можна відкрити існуючий файл,\n"
"                                 вилучити його та спробувати ще раз\n"
"                                 (буде проігноровано, якщо вказано\n"
"                                  параметр -n )\n"
"  -i, --interactive            запитувати підтвердження перед переписом\n"
"                                 (перевизначає раніше вказаний параметрі -"
"n )\n"
"  -H                           слідувати за символьним посиланням у ДЖЕРЕЛО\n"

#: src/cp.c:188
msgid ""
"  -l, --link                   hard link files instead of copying\n"
"  -L, --dereference            always follow symbolic links in SOURCE\n"
msgstr ""
"  -l, --link                   створювати жорсткі посилання, а не копіювати\n"
"  -L, --dereference            завжди слідувати за символічним посиланням у "
"ДЖЕРЕЛО\n"

#: src/cp.c:192
msgid ""
"  -n, --no-clobber             do not overwrite an existing file (overrides\n"
"                                 a previous -i option)\n"
"  -P, --no-dereference         never follow symbolic links in SOURCE\n"
msgstr ""
"  -n, --no-clobber             не переписувати існуючий файл (перевизначає\n"
"                                 попередній параметр -i)\n"
"  -P, --no-dereference         ніколи не йти за символічними посиланнями у "
"ДЖЕРЕЛО\n"

#: src/cp.c:197
msgid ""
"  -p                           same as --preserve=mode,ownership,timestamps\n"
"      --preserve[=ATTR_LIST]   preserve the specified attributes (default:\n"
"                                 mode,ownership,timestamps), if possible\n"
"                                 additional attributes: context, links, "
"xattr,\n"
"                                 all\n"
msgstr ""
"  -p                           те саме, що й --preserve=mode,ownership,"
"timestamps\n"
"      --preserve[=СПИС_АТТР]   зберігати вказані атрибути (типово:\n"
"                                 mode,ownership,timestamps), якщо можливо\n"
"                                 додаткові атрибути: context, links, xattr, "
"all\n"

#: src/cp.c:205
msgid ""
"      --no-preserve=ATTR_LIST  don't preserve the specified attributes\n"
"      --parents                use full source file name under DIRECTORY\n"
msgstr ""
"      --no-preserve=СПИС_АТТР  не зберігати вказані атрибути\n"
"      --parents                добавить вихідний шлях до КАТАЛОГУ\n"

#: src/cp.c:209
msgid ""
"  -R, -r, --recursive          copy directories recursively\n"
"      --reflink[=WHEN]         control clone/CoW copies. See below\n"
"      --remove-destination     remove each existing destination file before\n"
"                                 attempting to open it (contrast with --"
"force)\n"
msgstr ""
"  -R, -r, --recursive          копіювати каталоги рекурсивно\n"
"      --reflink[=КОЛИ]         керувати копіями clone/CoW. Див. нижче.\n"
"      --remove-destination     вилучати кожен цільовий файл, перш ніж\n"
"                                 копіювати його (протилежність до --force)\n"

#: src/cp.c:215
msgid ""
"      --sparse=WHEN            control creation of sparse files. See below\n"
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
msgstr ""
"      --sparse=КОЛИ            керує створенням розріджених файлів. Див. "
"нижче.\n"
"      --strip-trailing-slashes вилучає усі кінцеві похилі риски з кожного\n"
"                               аргументу ДЖЕРЕЛО\n"

#: src/cp.c:220
msgid ""
"  -s, --symbolic-link          make symbolic links instead of copying\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
msgstr ""
"  -s, --symbolic-link          створювати символьні посилання а не "
"копіювати\n"
"  -S, --suffix=СУФІКС          використовувати для запасних копій вказаний "
"СУФІКС\n"
"      --target-directory=КАТАЛОГ  скопіювати всі ДЖЕРЕЛА у КАТАЛОГ\n"
"  -T, --no-target-directory    вважати ЦІЛЬ звичайним файлом\n"

#: src/cp.c:226
msgid ""
"  -u, --update                 copy only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -x, --one-file-system        stay on this file system\n"
msgstr ""
"  -u, --update                 копіювати лише тоді коли вихідний файл\n"
"                                 новіший ніж цільовий файл, або коли\n"
"                                 цільовий файл відсутній\n"
"  -v, --verbose                пояснювати що зроблено\n"
"  -x, --one-file-system        залишатись у межах однієї файлової системи\n"

#: src/cp.c:233
msgid ""
"  -Z                           set SELinux security context of destination\n"
"                                 file to default type\n"
"      --context[=CTX]          like -Z, or if CTX is specified then set the\n"
"                                 SELinux or SMACK security context to CTX\n"
msgstr ""
"  -Z                   встановити типовий тип контексту безпеки SELinux\n"
"                         для файла призначення\n"
"      --context[=CTX]  подібний до -Z, якщо вказано CTX, встановити контекст "
"безпеки\n"
"                         SELinux або SMACK відповідно до вказаного значення\n"
"                         контексту CTX\n"

#: src/cp.c:241
msgid ""
"\n"
"By default, sparse SOURCE files are detected by a crude heuristic and the\n"
"corresponding DEST file is made sparse as well.  That is the behavior\n"
"selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\n"
"file whenever the SOURCE file contains a long enough sequence of zero "
"bytes.\n"
"Use --sparse=never to inhibit creation of sparse files.\n"
"\n"
"When --reflink[=always] is specified, perform a lightweight copy, where the\n"
"data blocks are copied only when modified.  If this is not possible the "
"copy\n"
"fails, or if --reflink=auto is specified, fall back to a standard copy.\n"
msgstr ""
"\n"
"Типово розріджені файли ДЖЕРЕЛА розпізнається за допомогою грубої\n"
"евристичної процедури та відповідно створюється розріджений файл\n"
"ПРИЗНАЧЕННЯ. Таку поведінку можна визначити за допомогою\n"
"параметра --sparse=auto. З параметром --sparse=always ПРТИЗНАЧЕННЯ\n"
"завжди створюється розрідженим, незалежно від того, чи містить\n"
"файл ДЖЕРЕЛА довгі послідовності нульових байтів.\n"
"Скористайтеся параметром --sparse=never для заборони створення розріджених\n"
"файлів.\n"
"\n"
"Якщо вказано параметр --reflink[=always], буде виконано полегшене "
"копіювання,\n"
"за якого блоки даних копіюватимуться лише у разі внесення змін. Якщо це\n"
"неможливо, копіювання зазнає невдачі або, якщо вказано --reflink=auto,\n"
"повернеться до стандартного режиму.\n"

#: src/cp.c:254
msgid ""
"\n"
"As a special case, cp makes a backup of SOURCE when the force and backup\n"
"options are given and SOURCE and DEST are the same name for an existing,\n"
"regular file.\n"
msgstr ""
"\n"
"Коли вказані ключі -f та -b, та SOURCE збігається з DEST cp створює\n"
"резервну копію DEST.\n"

#: src/cp.c:313
#, c-format
msgid "failed to preserve times for %s"
msgstr "не вдалося зберегти мітки часу для %s"

#: src/cp.c:344
#, c-format
msgid "failed to preserve permissions for %s"
msgstr "не вдалося зберегти права доступу для %s"

#: src/cp.c:480
#, c-format
msgid "cannot make directory %s"
msgstr "не вдалося створити каталог %s"

#: src/cp.c:529 src/cp.c:560
#, c-format
msgid "%s exists but is not a directory"
msgstr "%s існує, але не є каталогом"

#: src/cp.c:587 src/cp.c:1086 src/install.c:407 src/install.c:941 src/ln.c:134
#: src/ln.c:198 src/ln.c:219 src/ln.c:502 src/mv.c:157 src/mv.c:389
#, c-format
msgid "failed to access %s"
msgstr "не вдалося отримати доступ до %s"

#: src/cp.c:607 src/install.c:968 src/ln.c:533 src/mv.c:432 src/shred.c:1298
#: src/touch.c:430 src/truncate.c:329
#, c-format
msgid "missing file operand"
msgstr "пропущений операнд, що вказує файл"

#: src/cp.c:609 src/install.c:970 src/ln.c:547 src/mv.c:434
#, c-format
msgid "missing destination file operand after %s"
msgstr "після %s пропущений операнд, що вказує цільовий файл"

#: src/cp.c:618 src/install.c:979 src/mv.c:443
msgid "cannot combine --target-directory (-t) and --no-target-directory (-T)"
msgstr ""
"не можна використовувати водночас --target-directory (-t) і --no-target-"
"directory (-T)"

#: src/cp.c:634 src/cp.c:1089 src/install.c:409 src/install.c:944
#: src/install.c:992 src/ln.c:136 src/ln.c:505 src/ln.c:561 src/mv.c:392
#: src/mv.c:457
#, c-format
msgid "target %s is not a directory"
msgstr "вказана ціль %s не є каталогом"

#: src/cp.c:745
#, c-format
msgid "with --parents, the destination must be a directory"
msgstr "при заданому --parents ціль повинна бути каталогом"

#: src/cp.c:1081 src/install.c:881 src/ln.c:497 src/mv.c:384
msgid "multiple target directories specified"
msgstr "вказано декілька цільових каталогів"

#: src/cp.c:1123 src/install.c:917
#, c-format
msgid "warning: ignoring --context; it requires an SELinux-enabled kernel"
msgstr ""
"попередження: ігноруємо --context; для його використання потрібне ядро з "
"підтримкою SELinux"

#: src/cp.c:1144
#, c-format
msgid "cannot make both hard and symbolic links"
msgstr "не можна створювати жорстке та символьне посилання одночасно"

#: src/cp.c:1151 src/mv.c:464
#, c-format
msgid "options --backup and --no-clobber are mutually exclusive"
msgstr "параметри --backup і --no-clobber не можна використовувати одночасно"

#: src/cp.c:1157
#, c-format
msgid "--reflink can be used only with --sparse=auto"
msgstr "--reflink можна використовувати лише разом з --sparse=auto"

#: src/cp.c:1162 src/install.c:949 src/ln.c:566 src/mv.c:469
msgid "backup type"
msgstr "тип резервної копії"

#: src/cp.c:1185 src/install.c:955
msgid "cannot set target context and preserve it"
msgstr "не можна одночасно встановлювати контекст призначення і зберігати його"

#: src/cp.c:1189
msgid "cannot preserve security context without an SELinux-enabled kernel"
msgstr "не можна зберігати контекст безпеки, якщо ядро не підтримує SELinux"

#: src/cp.c:1205
msgid "cannot preserve extended attributes, cp is built without xattr support"
msgstr "не вдалося зберегти розширені атрибути, cp зібрано без підтримки xattr"

#. This is a proper name. See the gettext manual, section Names.
#: src/csplit.c:44 src/dd.c:46
msgid "Stuart Kemp"
msgstr "Stuart Kemp"

#: src/csplit.c:545
msgid "input disappeared"
msgstr "ввід став недоступний"

#: src/csplit.c:676 src/csplit.c:688
#, c-format
msgid "%s: line number out of range"
msgstr "%s: номер рядка поза допустимими межами"

#: src/csplit.c:718
#, c-format
msgid "%s: %s: line number out of range"
msgstr "%s: %s: номер рядка поза допустимими межами"

#: src/csplit.c:721 src/csplit.c:777
#, c-format
msgid " on repetition %s\n"
msgstr " при повторі %s\n"

#: src/csplit.c:771
#, c-format
msgid "%s: %s: match not found"
msgstr "%s: %s: відповідність не знайдено"

#: src/csplit.c:838 src/csplit.c:878 src/nl.c:356 src/tac.c:286
#, c-format
msgid "error in regular expression search"
msgstr "помилка пошуку регулярного виразу"

#: src/csplit.c:1011 src/csplit.c:1058
#, c-format
msgid "write error for %s"
msgstr "помилка запису для %s"

#: src/csplit.c:1093
#, c-format
msgid "%s: integer expected after delimiter"
msgstr "%s: після розділювача очікується ціле число"

#: src/csplit.c:1110
#, c-format
msgid "%s: '}' is required in repeat count"
msgstr "%s: при вказуванні числа повторів слід додати «}»"

#: src/csplit.c:1121
#, c-format
msgid "%s}: integer required between '{' and '}'"
msgstr "%s: між «{» та «}» має бути вказано ціле число"

#: src/csplit.c:1148
#, c-format
msgid "%s: closing delimiter '%c' missing"
msgstr "%s: пропущено кінцевий роздільник «%c»"

#: src/csplit.c:1165
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s: неприпустимий регулярний вираз: %s"

#: src/csplit.c:1198
#, c-format
msgid "%s: invalid pattern"
msgstr "%s: неприпустимий шаблон"

#: src/csplit.c:1201
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s: номер рядка повинен бути більше нуля"

#: src/csplit.c:1206
#, c-format
msgid "line number %s is smaller than preceding line number, %s"
msgstr "номер рядка %s менше номеру попереднього рядка, %s"

#: src/csplit.c:1212
#, c-format
msgid "warning: line number %s is the same as preceding line number"
msgstr "попередження: номер рядка %s дорівнює попередньому номеру рядка"

#: src/csplit.c:1290
msgid "missing conversion specifier in suffix"
msgstr "пропущений специфікатор перетворення у суфіксі"

#: src/csplit.c:1295
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "неправильний специфікатор перетворення у суфіксі: %c"

#: src/csplit.c:1298
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "неправильний специфікатор перетворення у суфіксі: \\%.3o"

#: src/csplit.c:1303
#, c-format
msgid "invalid flags in conversion specification: %%%c%c"
msgstr "некоректні прапорці у специфікації перетворення: %%%c%c"

#: src/csplit.c:1320
#, c-format
msgid "too many %% conversion specifications in suffix"
msgstr "надто багато описів перетворення (%%) у суфіксі"

#: src/csplit.c:1334
#, c-format
msgid "missing %% conversion specification in suffix"
msgstr "пропущено опис перетворення (%%) у суфіксі"

#: src/csplit.c:1380 src/dd.c:1459 src/nproc.c:105 src/tail.c:2067
msgid "invalid number"
msgstr "некоректне число"

#: src/csplit.c:1487
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "Використання: %s [КЛЮЧ]... ФАЙЛ ШАБЛОН...\n"

#: src/csplit.c:1491
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files 'xx00', 'xx01', ...,\n"
"and output byte counts of each piece to standard output.\n"
msgstr ""
"Виводить частини ФАЙЛА, розділені ШАБЛОНОМ (ШАБЛОНАМИ), до файлів 'xx00',\n"
"'xx01', ... та виводить число байт у кожній частині на стандартний вивід.\n"

#: src/csplit.c:1495
msgid ""
"\n"
"Read standard input if FILE is -\n"
msgstr ""
"\n"
"Якщо ФАЙЛ вказано як -, читає стандартне введення.\n"

#: src/csplit.c:1502
#, c-format
msgid ""
"  -b, --suffix-format=FORMAT  use sprintf FORMAT instead of %02d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of 'xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
msgstr ""
"  -b, --suffix-format=ФОРМАТ використовувати ФОРМАТ як у sprintf замість "
"%02d\n"
"  -f, --prefix=ПРЕФІКС       використовувати ПРЕФІКС замість 'xx'\n"
"  -k, --keep-files           не вилучати файли виводу при помилках\n"

#: src/csplit.c:1507
msgid "      --suppress-matched     suppress the lines matching PATTERN\n"
msgstr ""
"      --suppress-matched     не виводити рядки, що відповідають зразку\n"

#: src/csplit.c:1510
msgid ""
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
msgstr ""
"  -n, --digits=ЦИФРИ         використовувати вказане число ЦИФР замість 2\n"
"  -s, --quiet, --silent      не виводити розміри вихідних файлів\n"
"  -z, --elide-empty-files    вилучати порожні файли виводу\n"

#: src/csplit.c:1517
msgid ""
"\n"
"Each PATTERN may be:\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %REGEXP%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required '+' or '-' followed by a positive integer.\n"
msgstr ""
"\n"
"\n"
"Варіанти параметра ШАБЛОН:\n"
"  ЦІЛЕ              копіювати до рядка з вказаним номером, але не включно\n"
"  /REGEXP/[ЗСУВ]    копіювати до відповідного рядка, але не включно\n"
"  %%REGEXP%%[ЗСУВ]  пропустити до відповідного рядка, але не включно\n"
"  {ЦІЛЕ}            повторити попередній шаблон вказане число раз\n"
"  {*}               повторити попередній шаблон максимальну кількість разів\n"
"\n"
"Додатковий ЗСУВ рядків -- це обов'язковий символ '+' або '-' з попереднім\n"
"додатнім цілим числом.\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/cut.c:45 src/paste.c:52
msgid "David M. Ihnat"
msgstr "David M. Ihnat"

#: src/cut.c:147
#, c-format
msgid "Usage: %s OPTION... [FILE]...\n"
msgstr "Використання: %s КЛЮЧ... [ФАЙЛ]...\n"

#: src/cut.c:151
msgid "Print selected parts of lines from each FILE to standard output.\n"
msgstr ""
"Виводить вибрані частини рядків з кожного ФАЙЛА на стандартний вивід.\n"

#: src/cut.c:158
msgid ""
"  -b, --bytes=LIST        select only these bytes\n"
"  -c, --characters=LIST   select only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
msgstr ""
"  -b, --bytes=СПИСОК             вибрати лише вказані байти\n"
"  -c, --characters=СПИСОК        вибрати лише вказані знаки\n"
"  -d, --delimiter=РОЗДІЛЮВАЧ     використовувати РОЗДІЛЮВАЧ для розділення\n"
"                                 полів замість табуляції\n"

#: src/cut.c:163
msgid ""
"  -f, --fields=LIST       select only these fields;  also print any line\n"
"                            that contains no delimiter character, unless\n"
"                            the -s option is specified\n"
"  -n                      (ignored)\n"
msgstr ""
"  -f, --fields=СПИСОК            вибрати лише вказані поля; також виводити\n"
"                                 всі рядки, що не містять розділювачів,\n"
"                                 якщо не вказаний ключ -s\n"
"  -n                             (ігнорується)\n"

#: src/cut.c:169
msgid ""
"      --complement        complement the set of selected bytes, characters\n"
"                            or fields\n"
msgstr ""
"      --complement        доповнити множину вибраних байтів, знаків "
"або                             полів.\n"

#: src/cut.c:173
msgid ""
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
msgstr ""
"  -s, --only-delimited          не виводити рядки, що не містять "
"розділювачів\n"
"      --output-delimiter=РЯДОК  використовувати РЯДОК для розділення полів\n"
"                                при виводі, типово використовується\n"
"                                розділювач для вводу\n"

#: src/cut.c:183
msgid ""
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Selected input is written\n"
"in the same order that it is read, and is written exactly once.\n"
msgstr ""
"\n"
"Використовуйте один, і лише один, з ключів -b, -c чи -f.  Кожен СПИСОК\n"
"складається з одного діапазону, або кількох діапазонів, розділених комами.\n"
"Вибрані частини вхідного файла виводяться у тому порядку, у якому вони,\n"
"з'являються на вході, та виводяться рівно один раз.\n"

#: src/cut.c:189
msgid ""
"Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
msgstr ""
"Варіанти діапазонів:\n"
"\n"
"  Н     Н-ний байт, знак або поле; відлік ведеться від 1\n"
"  Н-    від Н-го байта, знаку або поля до кінця рядка\n"
"  Н-М   від Н-го до М-го (включно) байта, знаку або поля\n"
"  -М    від першого до М-го (включно) байта, знаку або поля\n"

#: src/cut.c:511 src/cut.c:519
msgid "only one type of list may be specified"
msgstr "можна вказати лише один тип списку"

#: src/cut.c:528 src/numfmt.c:1521
msgid "the delimiter must be a single character"
msgstr "розділювач повинен бути одним символом"

#: src/cut.c:567
msgid "you must specify a list of bytes, characters, or fields"
msgstr "треба вказати список байт, символів або полів"

#: src/cut.c:570
msgid "an input delimiter may be specified only when operating on fields"
msgstr "розділювач для вхідних даних можна вказувати лише при обробці полів"

#: src/cut.c:574
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"заборона виводу рядків, що не містять розділювачів,\n"
"має сенс лише при роботі з полями"

#: src/date.c:130
#, c-format
msgid ""
"Usage: %s [OPTION]... [+FORMAT]\n"
"  or:  %s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [+ФОРМАТ]\n"
"       або:    %s [-u|--utc|--universal] [ММДДррхх[[СС]РР][.сс]]\n"

#: src/date.c:135
msgid "Display the current time in the given FORMAT, or set the system date.\n"
msgstr ""
"Показати поточний час у вказаному ФОРМАТі або встановити системну дату.\n"

#: src/date.c:141
msgid ""
"  -d, --date=STRING          display time described by STRING, not 'now'\n"
msgstr ""
"  -d, --date=РЯДОК          показати час, описаний РЯДКОМ, а не поточний.\n"

#: src/date.c:144
msgid ""
"      --debug                annotate the parsed date,\n"
"                              and warn about questionable usage to stderr\n"
msgstr ""
"      --debug                анотувати оброблену дату,\n"
"                              і попередити щодо проблем до stderr\n"

#: src/date.c:148
msgid ""
"  -f, --file=DATEFILE        like --date; once for each line of DATEFILE\n"
msgstr ""
"  -f, --file=ФАЙЛ_ДАТИ      подібний до --date для кожного з рядків "
"ФАЙЛ_ДАТИ\n"

#: src/date.c:151
msgid ""
"  -I[FMT], --iso-8601[=FMT]  output date/time in ISO 8601 format.\n"
"                               FMT='date' for date only (the default),\n"
"                               'hours', 'minutes', 'seconds', or 'ns'\n"
"                               for date and time to the indicated "
"precision.\n"
"                               Example: 2006-08-14T02:34:56-06:00\n"
msgstr ""
"  -I[СПЕЦЧАСУ], --iso-8601[=СПЕЦЧАСУ] вивести дату і час у форматі ISO "
"8601.\n"
"                            СПЕЦЧАСУ='date' визначає лише дату (типово),\n"
"                            'hours', 'minutes', 'seconds' і 'ns' -- дата і\n"
"                            час із відповідною точністю.\n"
"                            Приклад: 2006-08-14T02:34:56-06:00\n"

#: src/date.c:158
msgid ""
"  -R, --rfc-email            output date and time in RFC 5322 format.\n"
"                               Example: Mon, 14 Aug 2006 02:34:56 -0600\n"
msgstr ""
"  -R,  --rfc-email           виводити час відповідно до RFC 5322\n"
"                            Приклад: Mon, 14 Aug 2006 02:34:56 -0600\n"

#: src/date.c:162
msgid ""
"      --rfc-3339=FMT         output date/time in RFC 3339 format.\n"
"                               FMT='date', 'seconds', or 'ns'\n"
"                               for date and time to the indicated "
"precision.\n"
"                               Example: 2006-08-14 02:34:56-06:00\n"
msgstr ""
"       --rfc-3339[=СПЕЦ]     вивести дату/час у форматі RFC 3339\n"
"                               СПЕЦ='date', 'seconds' або 'ns' для "
"отримання\n"
"                               дати та часу з вказаною точністю.\n"
"                               Приклад: 2006-08-14 02:34:56-06:00\n"

#: src/date.c:168
msgid ""
"  -r, --reference=FILE       display the last modification time of FILE\n"
msgstr "  -r,  --reference=ФАЙЛ     показати час останньої зміни ФАЙЛа\n"

#: src/date.c:171
msgid ""
"  -s, --set=STRING           set time described by STRING\n"
"  -u, --utc, --universal     print or set Coordinated Universal Time (UTC)\n"
msgstr ""
"  -s,  --set=РЯДОК          встановити час, що описується РЯДКОМ\n"
"  -u, --utc, --universal    показати або встановити універсальний\n"
"                            координований час (UTC)\n"

#: src/date.c:177
msgid ""
"\n"
"FORMAT controls the output.  Interpreted sequences are:\n"
"\n"
"  %%   a literal %\n"
"  %a   locale's abbreviated weekday name (e.g., Sun)\n"
msgstr ""
"\n"
"ФОРМАТ керує виводом.  Розпізнаються послідовності:\n"
"\n"
"  %%   знак %\n"
"  %a   місцева скорочена назва дня тижня (напр., нед)\n"

#: src/date.c:184
msgid ""
"  %A   locale's full weekday name (e.g., Sunday)\n"
"  %b   locale's abbreviated month name (e.g., Jan)\n"
"  %B   locale's full month name (e.g., January)\n"
"  %c   locale's date and time (e.g., Thu Mar  3 23:05:25 2005)\n"
msgstr ""
"  %A   місцева повна назва дня тижня (напр., понеділок)\n"
"  %b   місцева скорочена назва місяця (напр., січ)\n"
"  %B   місцева повна назва місяця (напр., січень)\n"
"  %c   місцевий час та дата (напр., Чтв 3 Мар 23:05:25 2005)\n"

#: src/date.c:190
msgid ""
"  %C   century; like %Y, except omit last two digits (e.g., 20)\n"
"  %d   day of month (e.g., 01)\n"
"  %D   date; same as %m/%d/%y\n"
"  %e   day of month, space padded; same as %_d\n"
msgstr ""
"  %C   століття; як %Y, але без двох останніх цифр (наприклад 20)\n"
"  %d   день місяця (наприклад 01)\n"
"  %D   дата; те саме, що і %m/%d/%y\n"
"  %e   день місяця, доповнений пробілами; те саме, що і %_d\n"

#: src/date.c:196
msgid ""
"  %F   full date; same as %Y-%m-%d\n"
"  %g   last two digits of year of ISO week number (see %G)\n"
"  %G   year of ISO week number (see %V); normally useful only with %V\n"
msgstr ""
"  %F   повна дата; еквівалентно %Y-%m-%d\n"
"  %g   останні дві цифри року для номера тижня ISO (см. %G)\n"
"  %G   рік для номера тижня ISO (см. %V); звичайно буває корисно лише з %V\n"

#: src/date.c:201
msgid ""
"  %h   same as %b\n"
"  %H   hour (00..23)\n"
"  %I   hour (01..12)\n"
"  %j   day of year (001..366)\n"
msgstr ""
"  %h   те саме, що й %b\n"
"  %H   час (00..23)\n"
"  %I   час (01..12)\n"
"  %j   номер дня у році (001..366)\n"

#: src/date.c:207
msgid ""
"  %k   hour, space padded ( 0..23); same as %_H\n"
"  %l   hour, space padded ( 1..12); same as %_I\n"
"  %m   month (01..12)\n"
"  %M   minute (00..59)\n"
msgstr ""
"  %k   час з доповненням пробілом ( 0..23); те саме, що і %_H\n"
"  %l   час з доповненням пробілом ( 1..12); те саме, що і %_I\n"
"  %m   місяць (01..12)\n"
"  %M   хвилини (00..59)\n"

#: src/date.c:213
msgid ""
"  %n   a newline\n"
"  %N   nanoseconds (000000000..999999999)\n"
"  %p   locale's equivalent of either AM or PM; blank if not known\n"
"  %P   like %p, but lower case\n"
"  %q   quarter of year (1..4)\n"
"  %r   locale's 12-hour clock time (e.g., 11:11:04 PM)\n"
"  %R   24-hour hour and minute; same as %H:%M\n"
"  %s   seconds since 1970-01-01 00:00:00 UTC\n"
msgstr ""
"  %n   новий рядок\n"
"  %N   наносекунди (000000000..999999999)\n"
"  %p   місцевий еквівалент AM або PM; пропускається якщо невідомо\n"
"  %P   як %p, але малими літерами\n"
"  %q   квартал року (від 1 до 4)\n"
"  %r   час відповідно до локалі, 12-годинний формат (напр., 11:11:04 PM)\n"
"  %R   години та хвилини відповідно до локалі, 24-годинний формат; аналог %H:"
"%M\n"
"  %s   число секунд, що минули з 1970-01-01 00:00:00  UTC\n"

#: src/date.c:223
msgid ""
"  %S   second (00..60)\n"
"  %t   a tab\n"
"  %T   time; same as %H:%M:%S\n"
"  %u   day of week (1..7); 1 is Monday\n"
msgstr ""
"  %S   секунди (00..60)\n"
"  %t   табуляція\n"
"  %T   час, аналог %H:%M:%S\n"
"  %u   день тижня (1..7);  1 означає понеділок\n"

#: src/date.c:229
msgid ""
"  %U   week number of year, with Sunday as first day of week (00..53)\n"
"  %V   ISO week number, with Monday as first day of week (01..53)\n"
"  %w   day of week (0..6); 0 is Sunday\n"
"  %W   week number of year, with Monday as first day of week (00..53)\n"
msgstr ""
"  %U   номер тижня у році, якщо перший день тижня -- неділя (00..53)\n"
"  %V   номер тижня по ISO, якщо перший день тижня -- понеділок (01..52)\n"
"  %w   день тижня (0..6), 0 означає неділю\n"
"  %W   номер тижня у році, якщо перший день тижня -- понеділок (00..53)\n"

#: src/date.c:235
msgid ""
"  %x   locale's date representation (e.g., 12/31/99)\n"
"  %X   locale's time representation (e.g., 23:13:48)\n"
"  %y   last two digits of year (00..99)\n"
"  %Y   year\n"
msgstr ""
"  %x   місцеве представлення дати (напр., дд/мм/рр)\n"
"  %X   місцеве представлення часу (напр.,  23:13:48)\n"
"  %y   останні дві цифри року (00..99)\n"
"  %Y   рік\n"

#: src/date.c:241
msgid ""
"  %z   +hhmm numeric time zone (e.g., -0400)\n"
"  %:z  +hh:mm numeric time zone (e.g., -04:00)\n"
"  %::z  +hh:mm:ss numeric time zone (e.g., -04:00:00)\n"
"  %:::z  numeric time zone with : to necessary precision (e.g., -04, "
"+05:30)\n"
"  %Z   alphabetic time zone abbreviation (e.g., EDT)\n"
"\n"
"By default, date pads numeric fields with zeroes.\n"
msgstr ""
"  %z   +ггхх часовий пояс (наприклад -0400)\n"
"  %:z  +гг:хх часовий пояс (наприклад -04:00)\n"
"  %::z +гг:хх:сс часовий пояс (наприклад -04:00:00)\n"
"  %:::z часовий пояс з достатньою кількістю двокрапок (наприклад -04, "
"+05:30)\n"
"  %Z   алфавітне скорочення часового поясу (наприклад EDT)\n"
"\n"
"Типово date доповнює числові поля нулями.\n"

#: src/date.c:250
msgid ""
"The following optional flags may follow '%':\n"
"\n"
"  -  (hyphen) do not pad the field\n"
"  _  (underscore) pad with spaces\n"
"  0  (zero) pad with zeros\n"
"  ^  use upper case if possible\n"
"  #  use opposite case if possible\n"
msgstr ""
"Після '%' можуть йти наступні необов'язкові ознаки:\n"
"\n"
"  - (дефіс) не доповнювати це поле\n"
"  _ (підкреслення) доповнювати пробілами\n"
"  0 (нуль) доповнювати нулями\n"
"  ^ використовувати верхній регістр, якщо можливо\n"
"  # використовувати протилежний регістр, якщо можливо\n"

#: src/date.c:259
msgid ""
"\n"
"After any flags comes an optional field width, as a decimal number;\n"
"then an optional modifier, which is either\n"
"E to use the locale's alternate representations if available, or\n"
"O to use the locale's alternate numeric symbols if available.\n"
msgstr ""
"\n"
"Після будь-якої з ознак йде необов'язкова ширина поля у вигляді "
"десяткового;\n"
"числа потім необов'язковий модифікатор, один з наступних:\n"
"E -- якщо можливо, вживати альтернативне представлення для поточної локалі\n"
"O -- якщо можливо, використовувати альтернативні числові символи локалі.\n"

#: src/date.c:266
msgid ""
"\n"
"Examples:\n"
"Convert seconds since the epoch (1970-01-01 UTC) to a date\n"
"  $ date --date='@2147483647'\n"
"\n"
"Show the time on the west coast of the US (use tzselect(1) to find TZ)\n"
"  $ TZ='America/Los_Angeles' date\n"
"\n"
"Show the local time for 9AM next Friday on the west coast of the US\n"
"  $ date --date='TZ=\"America/Los_Angeles\" 09:00 next Fri'\n"
msgstr ""
"\n"
"Приклади:\n"
"Перетворити секунди з початку епохи (1970-01-01 UTC) у дату\n"
"  $ date --date='@2147483647'\n"
"\n"
"Показати час у Києві США (скористайтеся tzselect(1) для визначення TZ)\n"
"  $ TZ='Europe/Kiev' date\n"
"\n"
"Показати локальний час для 9:00 наступної п'ятниці у Києві\n"
"  $ date --date='TZ=\"Europe/Kiev\" 09:00 next Fri'\n"

#: src/date.c:300 src/dd.c:2377 src/head.c:880 src/md5sum.c:664
#: src/md5sum.c:1091 src/od.c:914 src/od.c:1982 src/pr.c:1149 src/pr.c:1351
#: src/pr.c:1473 src/stty.c:1381 src/tac.c:574 src/tail.c:340 src/tee.c:174
#: src/tr.c:1906 src/tsort.c:536 src/wc.c:205
msgid "standard input"
msgstr "стандартний ввід"

#: src/date.c:329 src/date.c:557
#, c-format
msgid "invalid date %s"
msgstr "неправильна дата %s"

#: src/date.c:443 src/date.c:477
msgid "multiple output formats specified"
msgstr "задано декілька вихідних форматів"

#: src/date.c:455
#, c-format
msgid "the options to specify dates for printing are mutually exclusive"
msgstr "ключі для виводу дати взаємно виключають друг друга"

#: src/date.c:462
#, c-format
msgid "the options to print and set the time may not be used together"
msgstr ""
"ключі для встановлення та для відображення часу не можуть застосовуватись "
"разом"

#: src/date.c:483
#, c-format
msgid ""
"the argument %s lacks a leading '+';\n"
"when using an option to specify date(s), any non-option\n"
"argument must be a format string beginning with '+'"
msgstr ""
"аргумент %s не починається зі знаку '+';\n"
"При вказуванні дати, кожен аргумент, що не є ключем, повинен мати\n"
"символьний формат та починатись зі знаку '+'."

#: src/date.c:565
#, c-format
msgid "cannot set date"
msgstr "не вдалося встановити дату"

#: src/date.c:599 src/du.c:388
#, c-format
msgid "time %s is out of range"
msgstr "час %s поза допустимим діапазоном"

#. This is a proper name. See the gettext manual, section Names.
#: src/dd.c:44 src/factor.c:128 src/rm.c:40 src/tail.c:72 src/touch.c:42
#: src/wc.c:50
msgid "Paul Rubin"
msgstr "Paul Rubin"

#: src/dd.c:555
#, c-format
msgid ""
"Usage: %s [OPERAND]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s [ОПЕРАНД]...\n"
"       або:    %s КЛЮЧ\n"

#: src/dd.c:560
msgid ""
"Copy a file, converting and formatting according to the operands.\n"
"\n"
"  bs=BYTES        read and write up to BYTES bytes at a time\n"
"  cbs=BYTES       convert BYTES bytes at a time\n"
"  conv=CONVS      convert the file as per the comma separated symbol list\n"
"  count=N         copy only N input blocks\n"
"  ibs=BYTES       read up to BYTES bytes at a time (default: 512)\n"
msgstr ""
"Копіює файл, перетворює та форматує залежно від операндів.\n"
"\n"
"  bs=ЧИСЛО        примусово вести запис і читання порціями у ЧИСЛО байтів\n"
"  cbs=ЧИСЛО       перетворювати вказане ЧИСЛО байт за раз\n"
"  conv=СПИСОК     перетворювати файл відповідно до СПИСКУ символів,\n"
"                  елементи має бути розділено комами\n"
"  count=ЧИСЛО     копіювати лише вказане ЧИСЛО вхідних блоків\n"
"  ibs=ЧИСЛО       читати вказане ЧИСЛО байт за раз (типово 512)\n"

#: src/dd.c:569
msgid ""
"  if=FILE         read from FILE instead of stdin\n"
"  iflag=FLAGS     read as per the comma separated symbol list\n"
"  obs=BYTES       write BYTES bytes at a time (default: 512)\n"
"  of=FILE         write to FILE instead of stdout\n"
"  oflag=FLAGS     write as per the comma separated symbol list\n"
"  seek=N          skip N obs-sized blocks at start of output\n"
"  skip=N          skip N ibs-sized blocks at start of input\n"
"  status=LEVEL    The LEVEL of information to print to stderr;\n"
"                  'none' suppresses everything but error messages,\n"
"                  'noxfer' suppresses the final transfer statistics,\n"
"                  'progress' shows periodic transfer statistics\n"
msgstr ""
"  if=ФАЙЛ         читати ФАЙЛ, а не стандартне введення\n"
"  iflag=СПИСОК    читати відповідно до СПИСКУ символів,\n"
"                  пункти слід відокремлювати комами\n"
"  obs=ЧИСЛО       записувати вказане ЧИСЛО байт за раз (типово 512)\n"
"  of=ФАЙЛ         записувати у ФАЙЛ, а не у стандартне виведення\n"
"  oflag=СПИСОК    записувати відповідно до списку символів,\n"
"                  пункти слід відокремлювати комами\n"
"  seek=N          пропустити з початку виводу N блоків розміром obs\n"
"  skip=N          пропустити з початку вводу N блоків розміром ibs\n"
"  status=РЕЖИМ    РЕЖИМ придушення виведення даних до stderr;\n"
"                  «noxfer» — придушити виведення статистики передавання,\n"
"                  «none» — придушити виведення будь-яких даних,\n"
"                  «progress» — періодично показувати статистику роботи\n"

#: src/dd.c:582
msgid ""
"\n"
"N and BYTES may be followed by the following multiplicative suffixes:\n"
"c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, xM =M,\n"
"GB =1000*1000*1000, G =1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"\n"
"Each CONV symbol may be:\n"
"\n"
msgstr ""
"\n"
"Після ЧИСЛА і БАЙТів може бути вказано один з множників:\n"
"c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, xM =M,\n"
"GB =1000*1000*1000, G =1024*1024*1024 тощо для T, P, E, Z, Y.\n"
"\n"
"Кожен елемент СПИСКУ для conv може бути:\n"
"\n"

#: src/dd.c:591
msgid ""
"  ascii     from EBCDIC to ASCII\n"
"  ebcdic    from ASCII to EBCDIC\n"
"  ibm       from ASCII to alternate EBCDIC\n"
"  block     pad newline-terminated records with spaces to cbs-size\n"
"  unblock   replace trailing spaces in cbs-size records with newline\n"
"  lcase     change upper case to lower case\n"
"  ucase     change lower case to upper case\n"
"  sparse    try to seek rather than write the output for NUL input blocks\n"
"  swab      swap every pair of input bytes\n"
"  sync      pad every input block with NULs to ibs-size; when used\n"
"            with block or unblock, pad with spaces rather than NULs\n"
msgstr ""
"  ascii     з EBCDIC на ASCII\n"
"  ebcdic    з ASCII на EBCDIC\n"
"  ibm       з ASCII на альтернативну EBCDIC\n"
"  block     заповнювати записи, що закінчуються переносом рядка, пробілами\n"
"            до розміру cbs\n"
"  unblock   замінювати кінцеві пробіли у записах з розміром cbs переносом "
"рядка\n"
"  lcase     змінювати регістр з верхнього на нижній\n"
"  ucase     змінювати регістр з нижнього на верхній\n"
"  sparse    спробувати виконати позиціювання замість запису до виведення для "
"вхідних\n"
"              блоків NUL\n"
"  swab      міняти місцями кожну пару вхідних байтів\n"
"  sync      доповнювати кожен вхідний блок нулями до розміру ibs; якщо\n"
"              вживається разом з block або unblock, доповнювати пробілами\n"

#: src/dd.c:604
msgid ""
"  excl      fail if the output file already exists\n"
"  nocreat   do not create the output file\n"
"  notrunc   do not truncate the output file\n"
"  noerror   continue after read errors\n"
"  fdatasync  physically write output file data before finishing\n"
"  fsync     likewise, but also write metadata\n"
msgstr ""
"  excl      завершаться помилкою, якщо файл виводу уже існує\n"
"  nocreat   не створювати файл виводу\n"
"  notrunc   не обрізати файл виводу\n"
"  noerror   продовжувати після помилок читання\n"
"  fdatasync фізично записати файл виводу перед завершенням\n"
"  fsync     аналогічно, але записати також метадані\n"

#: src/dd.c:612
msgid ""
"\n"
"Each FLAG symbol may be:\n"
"\n"
"  append    append mode (makes sense only for output; conv=notrunc "
"suggested)\n"
msgstr ""
"\n"
"Символ-ОЗНАКА може бути таким:\n"
"\n"
"  append    режим додавання (має сенс для виводу; рекомендується  "
"conv=notrunc)\n"

#: src/dd.c:619
msgid "  cio       use concurrent I/O for data\n"
msgstr "  cio       використовувати конкурентне введення-виведення для дати\n"

#: src/dd.c:621
msgid "  direct    use direct I/O for data\n"
msgstr "  direct    використовувати прямий ввід/вивід для даних\n"

#: src/dd.c:623
msgid "  directory  fail unless a directory\n"
msgstr "  directory  помилка, якщо не є каталогом\n"

#: src/dd.c:625
msgid "  dsync     use synchronized I/O for data\n"
msgstr "  dsync     використовувати синхронізований ввід/вивід для даних\n"

#: src/dd.c:627
msgid "  sync      likewise, but also for metadata\n"
msgstr "  sync      те саме, але також для метаданих\n"

#: src/dd.c:628
msgid "  fullblock  accumulate full blocks of input (iflag only)\n"
msgstr "  fullblock  акумулювати повні блоки вводу (лише iflag)\n"

#: src/dd.c:631
msgid "  nonblock  use non-blocking I/O\n"
msgstr "  nonblock  використовувати ввід/вивід без блокування\n"

#: src/dd.c:633
msgid "  noatime   do not update access time\n"
msgstr "  noatime   не оновлювати час останнього доступу\n"

#: src/dd.c:636
msgid "  nocache   Request to drop cache.  See also oflag=sync\n"
msgstr ""
"  nocache   надіслати запит щодо відкидання кеш. Див. також oflag=sync\n"

#: src/dd.c:640
msgid "  noctty    do not assign controlling terminal from file\n"
msgstr "  noctty    не призначати керівний термінал з файла\n"

#: src/dd.c:643
msgid "  nofollow  do not follow symlinks\n"
msgstr "  nofollow  не слідувати за символьним посиланням\n"

#: src/dd.c:645
msgid "  nolinks   fail if multiply-linked\n"
msgstr "  nolinks   помилка, якщо знайдено декілька посилань\n"

#: src/dd.c:647
msgid "  binary    use binary I/O for data\n"
msgstr "  binary    використовувати двійковий ввід/вивід для даних\n"

#: src/dd.c:649
msgid "  text      use text I/O for data\n"
msgstr "  text      використовувати текстовий ввід/вивід для даних\n"

#: src/dd.c:651
msgid "  count_bytes  treat 'count=N' as a byte count (iflag only)\n"
msgstr ""
"  count_bytes  вважати «count=N» визначенням кількості байтів (лише для "
"iflag)\n"

#: src/dd.c:654
msgid "  skip_bytes  treat 'skip=N' as a byte count (iflag only)\n"
msgstr ""
"  skip_bytes  вважати «skip=N» визначенням кількості байтів (лише для "
"iflag)\n"

#: src/dd.c:657
msgid "  seek_bytes  treat 'seek=N' as a byte count (oflag only)\n"
msgstr ""
"  seek_bytes  вважати «seek=N» визначенням кількості байтів (лише для "
"oflag)\n"

#: src/dd.c:661
#, c-format
msgid ""
"\n"
"Sending a %s signal to a running 'dd' process makes it\n"
"print I/O statistics to standard error and then resume copying.\n"
"\n"
"Options are:\n"
"\n"
msgstr ""
"\n"
"Надсилання сигналу %s до запущеного процесу «dd» призводить до\n"
"виведення даних щодо введення-виведення до стандартного буфера\n"
"помилок з наступним відновленням копіювання.\n"
"\n"
"Параметри:\n"
"\n"

#: src/dd.c:697
#, c-format
msgid "memory exhausted by input buffer of size %<PRIuMAX> bytes (%s)"
msgstr ""
"пам'ять вичерпано буфером введення даних розміром у %<PRIuMAX> байтів (%s)"

#: src/dd.c:725
#, c-format
msgid "memory exhausted by output buffer of size %<PRIuMAX> bytes (%s)"
msgstr ""
"пам'ять вичерпано буфером виведення даних розміром у %<PRIuMAX> байтів (%s)"

#: src/dd.c:791
msgid "Infinity B"
msgstr "Нескінченість"

#: src/dd.c:809
#, c-format
msgid "%<PRIuMAX> byte copied, %g s, %s/s"
msgid_plural "%<PRIuMAX> bytes copied, %g s, %s/s"
msgstr[0] "скопійовано %<PRIuMAX> байт, %g с, %s/с"
msgstr[1] "скопійовано %<PRIuMAX> байти, %g с, %s/с"
msgstr[2] "скопійовано %<PRIuMAX> байтів, %g с, %s/с"

#: src/dd.c:815
#, c-format
msgid "%<PRIuMAX> bytes (%s) copied, %g s, %s/s"
msgstr "скопійовано %<PRIuMAX> байтів (%s), %g с, %s/с"

#: src/dd.c:818
#, c-format
msgid "%<PRIuMAX> bytes (%s, %s) copied, %g s, %s/s"
msgstr "скопійовано %<PRIuMAX> байтів (%s, %s), %g с, %s/с"

#: src/dd.c:844
#, c-format
msgid ""
"%<PRIuMAX>+%<PRIuMAX> records in\n"
"%<PRIuMAX>+%<PRIuMAX> records out\n"
msgstr ""
"%<PRIuMAX>+%<PRIuMAX> записів прочитано\n"
"%<PRIuMAX>+%<PRIuMAX> записів записано\n"

#: src/dd.c:850
#, c-format
msgid "%<PRIuMAX> truncated record\n"
msgid_plural "%<PRIuMAX> truncated records\n"
msgstr[0] "%<PRIuMAX> обрізаний запис\n"
msgstr[1] "%<PRIuMAX> обрізані записи\n"
msgstr[2] "%<PRIuMAX> обрізаних записів\n"

#: src/dd.c:935
#, c-format
msgid "closing input file %s"
msgstr "закриття вхідного файла %s"

#: src/dd.c:942
#, c-format
msgid "closing output file %s"
msgstr "закриття файла виводу %s"

#: src/dd.c:1157
#, c-format
msgid "failed to turn off O_DIRECT: %s"
msgstr "не вдалося вимкнути O_DIRECT: %s"

#: src/dd.c:1228 src/dd.c:2103
#, c-format
msgid "writing to %s"
msgstr "запис у %s"

#: src/dd.c:1347
#, c-format
msgid "warning: %s is a zero multiplier; use %s if that is intended"
msgstr ""
"попередження: %s є нульовим множником; скористайтеся %s, якщо так було "
"зроблено зумисне"

#: src/dd.c:1386 src/dd.c:1447
#, c-format
msgid "unrecognized operand %s"
msgstr "операнд %s не розпізнаний"

#: src/dd.c:1398
msgid "invalid conversion"
msgstr "неприпустиме перетворення"

#: src/dd.c:1401 src/dd.c:1490
msgid "invalid input flag"
msgstr "неприпустима ознака входу"

#: src/dd.c:1404 src/dd.c:1484 src/dd.c:1496
msgid "invalid output flag"
msgstr "неприпустимий ознака виводу"

#: src/dd.c:1407
msgid "invalid status level"
msgstr "некоректний рівень стану"

#: src/dd.c:1542
msgid "cannot combine any two of {ascii,ebcdic,ibm}"
msgstr "не можна одночасно використовувати будь-які два з {ascii,ebcdic,ibm}"

#: src/dd.c:1544
msgid "cannot combine block and unblock"
msgstr "не можна одночасно використовувати block та unblock"

#: src/dd.c:1546
msgid "cannot combine lcase and ucase"
msgstr "не можна одночасно використовувати lcase та ucase"

#: src/dd.c:1548
msgid "cannot combine excl and nocreat"
msgstr "не можна одночасно використовувати excl та nocreat"

#: src/dd.c:1551
msgid "cannot combine direct and nocache"
msgstr "не можна одночасно використовувати direct і nocache"

#: src/dd.c:1709
#, c-format
msgid ""
"warning: working around lseek kernel bug for file (%s)\n"
"  of mt_type=0x%0lx -- see <sys/mtio.h> for the list of types"
msgstr ""
"попередження: обходиться помилка lseek у ядрі для файла (%s)\n"
"  mt_type=0x%0lx -- см. <sys/mtio.h> для списку типів"

#: src/dd.c:1797
#, c-format
msgid "%s: cannot skip"
msgstr "%s: не вдалося пропустити"

#: src/dd.c:1799 src/dd.c:1830 src/dd.c:1891
#, c-format
msgid "%s: cannot seek"
msgstr "%s: не вдалося зсунути вказівник файла"

#: src/dd.c:1871
#, c-format
msgid "offset overflow while reading file %s"
msgstr "переповнення зсуву при читанні файла %s"

#: src/dd.c:1883
#, c-format
msgid "warning: invalid file offset after failed read"
msgstr "попередження: некоректний зсув файла після помилки читання"

#: src/dd.c:1887
#, c-format
msgid "cannot work around kernel bug after all"
msgstr "не вдалося обійти помилку ядра"

#: src/dd.c:2030
#, c-format
msgid "setting flags for %s"
msgstr "встановлення ознак для %s"

#: src/dd.c:2084
#, c-format
msgid "%s: cannot skip to specified offset"
msgstr "%s: не вдалося перемістити вказівник позиції на вказану кількість"

#: src/dd.c:2309
#, c-format
msgid "failed to truncate to %<PRIdMAX> bytes in output file %s"
msgstr "не вдалося обрізати до %<PRIdMAX> у файлі виведення даних %s"

#: src/dd.c:2322
#, c-format
msgid "fdatasync failed for %s"
msgstr "операція fdatasync для %s завершилась помилкою"

#: src/dd.c:2332
#, c-format
msgid "fsync failed for %s"
msgstr "операція fsync для %s завершилась помилкою"

#: src/dd.c:2383 src/dd.c:2413 src/nohup.c:160 src/nohup.c:162
#, c-format
msgid "failed to open %s"
msgstr "не вдалося відкрити %s"

#: src/dd.c:2423
#, c-format
msgid ""
"offset too large: cannot truncate to a length of seek=%<PRIuMAX> (%lu-byte) "
"blocks"
msgstr ""
"зсув надто великий: не вдалося обрізати до величини seek=%<PRIuMAX> (%lu-"
"байтних) блоків"

#: src/dd.c:2444
#, c-format
msgid "failed to truncate to %<PRIuMAX> bytes in output file %s"
msgstr "не вдалося обрізати до %<PRIuMAX> у файлі виведення даних %s"

#: src/dd.c:2461 src/dd.c:2467
#, c-format
msgid "failed to discard cache for: %s"
msgstr "помилка під час відкидання кешу для %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/df.c:46 src/du.c:55 src/expr.c:152 src/kill.c:34 src/pathchk.c:31
#: src/shuf.c:41 src/sleep.c:36 src/sort.c:68
msgid "Paul Eggert"
msgstr "Paul Eggert"

#: src/df.c:178
msgid "Filesystem"
msgstr "Ф. система"

#: src/df.c:181
msgid "Type"
msgstr "Тип"

#: src/df.c:184 src/df.c:551
msgid "blocks"
msgstr "блоків"

#: src/df.c:187
msgid "Used"
msgstr "Вик"

#: src/df.c:190
msgid "Available"
msgstr "Доступно"

#: src/df.c:193
msgid "Use%"
msgstr "Вик%"

#: src/df.c:196
msgid "Inodes"
msgstr "І-вузлів"

#: src/df.c:199
msgid "IUsed"
msgstr "Викор"

#: src/df.c:202
msgid "IFree"
msgstr "Вільн"

#: src/df.c:205
msgid "IUse%"
msgstr "Вик%"

#: src/df.c:208
msgid "Mounted on"
msgstr "змонтований на"

#: src/df.c:211
msgid "File"
msgstr "Файл"

#: src/df.c:391
#, c-format
msgid "option --output: field %s unknown"
msgstr "параметр --output: поле %s є невідомим"

#: src/df.c:398
#, c-format
msgid "option --output: field %s used more than once"
msgstr "параметр --output: поле %s використано декілька разів"

#: src/df.c:419 src/df.c:458
msgid "Size"
msgstr "Розм"

#: src/df.c:423 src/df.c:460
msgid "Avail"
msgstr "Дост"

#: src/df.c:483
msgid "Capacity"
msgstr "Всього"

#. TRANSLATORS: this is the "1K-blocks" header in "df" output.
#. TRANSLATORS: this is the "1024-blocks" header in "df -P".
#: src/df.c:554 src/df.c:563
#, c-format
msgid "%s-%s"
msgstr "%s-%s"

#: src/df.c:1287
#, c-format
msgid "cannot access %s: over-mounted by another device"
msgstr "не вдалося отримати доступ до %s: повторно змонтовано іншим пристроєм"

#: src/df.c:1456
msgid ""
"Show information about the file system on which each FILE resides,\n"
"or all file systems by default.\n"
msgstr ""
"Показати інформацію про файлову систему, на якій розташований кожен\n"
"з ФАЙЛІВ, або, типово, про усі файлові системи.\n"

#. TRANSLATORS: The thousands and decimal separators are best
#. adjusted to an appropriate default for your locale.
#: src/df.c:1465
msgid ""
"  -a, --all             include pseudo, duplicate, inaccessible file "
"systems\n"
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes;\n"
"                           see SIZE format below\n"
"  -h, --human-readable  print sizes in powers of 1024 (e.g., 1023M)\n"
"  -H, --si              print sizes in powers of 1000 (e.g., 1.1G)\n"
msgstr ""
"  -a, --all             включати несправжні, дубльовані, недоступні файлові "
"системи\n"
"  -B, --block-size=РОЗМІР використовувати блоки вказаного РОЗМІРУ. Приклад:\n"
"                           «-BM» виводить розміри у одиницях у 1.048.576 "
"байтів.\n"
"                           Формат РОЗМІР описано нижче.\n"
"  -h, --human-readable  виводити розміри у зручному для людини вигляді\n"
"                         (наприклад, 1023M)\n"
"  -H, --si              те саме, але використовувати степені 1000 "
"(наприклад, 1.1G)\n"

#: src/df.c:1473
msgid ""
"  -i, --inodes          list inode information instead of block usage\n"
"  -k                    like --block-size=1K\n"
"  -l, --local           limit listing to local file systems\n"
"      --no-sync         do not invoke sync before getting usage info "
"(default)\n"
msgstr ""
"  -i, --inodes          вивести інформацію про індексні дескриптори, а не "
"про\n"
"                        використання блоків\n"
"  -k                    аналог --block-size=1K\n"
"  -l, --local           перерахувати лише локальні файлові системи\n"
"      --no-sync         не викликати sync перед отриманням інформації про\n"
"                        використання блоків (типово)\n"

#: src/df.c:1480
msgid ""
"      --output[=FIELD_LIST]  use the output format defined by FIELD_LIST,\n"
"                               or print all fields if FIELD_LIST is "
"omitted.\n"
"  -P, --portability     use the POSIX output format\n"
"      --sync            invoke sync before getting usage info\n"
msgstr ""
"      --output[=СПИСОК_ПОЛІВ]  використовувати формат виведення, визначений "
"СПИСКОМ_ПОЛІВ,\n"
"                               або вивести всі поля, якщо СПИСОК_ПОЛІВ не "
"вказано.\n"
"  -P, --portability     виводити у форматі POSIX\n"
"      --sync            викликати sync перед отриманням інформації про\n"
"                        використання блоків\n"

#: src/df.c:1486
msgid ""
"      --total           elide all entries insignificant to available space,\n"
"                          and produce a grand total\n"
msgstr ""
"      --total           пропустити усі записи, які не пов’язано із доступним "
"місцем,\n"
"                          і вивести загальні підсумки\n"

#: src/df.c:1490
msgid ""
"  -t, --type=TYPE       limit listing to file systems of type TYPE\n"
"  -T, --print-type      print file system type\n"
"  -x, --exclude-type=TYPE   limit listing to file systems not of type TYPE\n"
"  -v                    (ignored)\n"
msgstr ""
"  -t, --type=ТИП        перерахувати лише файлові системи вказаного ТИПУ\n"
"  -T, --print-type      виводити тип файлової системи\n"
"  -x, --exclude-type=ТИП  виключати файлові системи вказаного ТИПУ\n"
"  -v                    (ігнорується)\n"

#: src/df.c:1500
msgid ""
"\n"
"FIELD_LIST is a comma-separated list of columns to be included.  Valid\n"
"field names are: 'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent',\n"
"'size', 'used', 'avail', 'pcent', 'file' and 'target' (see info page).\n"
msgstr ""
"\n"
"СПИСОК_ПОЛІВ — відокремлений комами список стовпчиків, які слід включити.\n"
"Можливі назви стовпчиків: 'source', 'fstype', 'itotal', 'iused', 'iavail', "
"'ipcent',\n"
"'size', 'used', 'avail', 'pcent', 'file'  і 'target' (див. сторінку info).\n"

#: src/df.c:1537
#, c-format
msgid "options %s and %s are mutually exclusive"
msgstr "параметри %s і %s не можна використовувати одночасно"

#: src/df.c:1687
#, c-format
msgid "file system type %s both selected and excluded"
msgstr "файлова система типа %s і вибрана, і виключена"

#: src/df.c:1747
msgid "Warning: "
msgstr "Попередження: "

#: src/df.c:1749 src/stat.c:893
msgid "cannot read table of mounted file systems"
msgstr "%помилка при читані змонтованих файлових систем"

#: src/df.c:1788
msgid "no file systems processed"
msgstr "не вказана жодна файлова система"

#. This is a proper name. See the gettext manual, section Names.
#: src/dircolors.c:37
msgid "H. Peter Anvin"
msgstr "H. Peter Anvin"

#: src/dircolors.c:99 src/uptime.c:199 src/users.c:106
#, c-format
msgid "Usage: %s [OPTION]... [FILE]\n"
msgstr "Використання: %s [КЛЮЧ]... [ФАЙЛ]\n"

#: src/dircolors.c:100
msgid ""
"Output commands to set the LS_COLORS environment variable.\n"
"\n"
"Determine format of output:\n"
"  -b, --sh, --bourne-shell    output Bourne shell code to set LS_COLORS\n"
"  -c, --csh, --c-shell        output C shell code to set LS_COLORS\n"
"  -p, --print-database        output defaults\n"
msgstr ""
"Видає команди для встановлення змінної оточення LS_COLORS.\n"
"\n"
"Вказати формат виводу:\n"
"  -b, --sh, --bourne-shell    вивести код для встановлення LS_COLORS у\n"
"                               Bourne shell\n"
"  -c, --csh, --c-shell        вивести код для встановлення LS_COLORS у C "
"shell\n"
"  -p, --print-database        вивести типові параметри\n"
"      --help                  показати довідку та вийти\n"
"      --version               вивести інформацію про версію та вийти\n"

#: src/dircolors.c:110
msgid ""
"\n"
"If FILE is specified, read it to determine which colors to use for which\n"
"file types and extensions.  Otherwise, a precompiled database is used.\n"
"For details on the format of these files, run 'dircolors --print-database'.\n"
msgstr ""
"\n"
"Якщо вказаний FILE, то читати його щоб дізнатись які кольори яким\n"
"розширенням призначені. Інакше використовувати типову базу даних. Для\n"
"докладнішого опису формату FILE запустите dircolors --print-database.\n"

#: src/dircolors.c:288
#, c-format
msgid "%s:%lu: invalid line;  missing second token"
msgstr "%s:%lu: неправильний рядок; пропущена друга лексема"

#: src/dircolors.c:360
#, c-format
msgid "%s:%lu: unrecognized keyword %s"
msgstr "%s:%lu ключове слово %s не розпізнано"

#: src/dircolors.c:361
msgid "<internal>"
msgstr "<внутрішній>"

#: src/dircolors.c:442
#, c-format
msgid ""
"the options to output dircolors' internal database and\n"
"to select a shell syntax are mutually exclusive"
msgstr ""
"ключі для виводу внутрішньої бази даних dircolors та ключі для вибору\n"
"синтаксису оболонки взаємно виключають друг друга"

#: src/dircolors.c:452
msgid "file operands cannot be combined with --print-database (-p)"
msgstr ""
"Операнди-файли не можна одночасно використовувати з --print-database (-p)"

#: src/dircolors.c:475
msgid "no SHELL environment variable, and no shell type option given"
msgstr "або змінна оточення SHELL відсутня, або не вказаний тип інтерпретатору"

#: src/dirname.c:50
#, c-format
msgid "Usage: %s [OPTION] NAME...\n"
msgstr "Використання: %s [КЛЮЧ] НАЗВА...\n"

#: src/dirname.c:54
msgid ""
"Output each NAME with its last non-slash component and trailing slashes\n"
"removed; if NAME contains no /'s, output '.' (meaning the current "
"directory).\n"
"\n"
msgstr ""
"Виводить всі НАЗВИ, вилучаючи компоненту праворуч від останньої похилої "
"риски;\n"
"якщо НАЗВА не містить похилої риски, виводить «.» (тобто поточний каталог).\n"
"\n"

#: src/dirname.c:59
msgid "  -z, --zero     end each output line with NUL, not newline\n"
msgstr ""
"  -z, --zero     завершувати кожен рядок нуль-байтом замість розриву рядка\n"

#: src/dirname.c:64
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/          -> \"/usr\"\n"
"  %s dir1/str dir2/str  -> \"dir1\" followed by \"dir2\"\n"
"  %s stdio.h            -> \".\"\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s /usr/bin/          -> «/usr»\n"
"  %s dir1/str dir2/str  -> «dir1», потім «dir2»\n"
"  %s stdio.h            -> «.»\n"

#: src/du.c:284 src/sort.c:423 src/wc.c:115
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [OPTION]... --files0-from=F\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ФАЙЛ]...\n"
"       або:    %s [КЛЮЧ]... --files0-from=Ф\n"

#: src/du.c:288
msgid ""
"Summarize disk usage of the set of FILEs, recursively for directories.\n"
msgstr ""
"Сумарне використання дискового простору набору ФАЙЛів, рекурсивно для "
"каталогів.\n"

#: src/du.c:294
msgid ""
"  -0, --null            end each output line with NUL, not newline\n"
"  -a, --all             write counts for all files, not just directories\n"
"      --apparent-size   print apparent sizes, rather than disk usage; "
"although\n"
"                          the apparent size is usually smaller, it may be\n"
"                          larger due to holes in ('sparse') files, internal\n"
"                          fragmentation, indirect blocks, and the like\n"
msgstr ""
"  -0, --null            завершувати кожен рядок виведених даних нуль-байтом "
"замість символу\n"
"                          нового рядка\n"
"  -a, --all             виводить обсяг для усіх файлів, а не лише каталогів\n"
"      --apparent-size   виводить дійсні розміри, а не зайнятий дисковий\n"
"                          простір; хоча справжній розмір звичайно менший,\n"
"                          іноді він може бути більшим через дірки у файлах,\n"
"                          внутрішньої фрагментації, непрямих блоків та т.і.\n"

#: src/du.c:303
msgid ""
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes;\n"
"                           see SIZE format below\n"
"  -b, --bytes           equivalent to '--apparent-size --block-size=1'\n"
"  -c, --total           produce a grand total\n"
"  -D, --dereference-args  dereference only symlinks that are listed on the\n"
"                          command line\n"
"  -d, --max-depth=N     print the total for a directory (or file, with --"
"all)\n"
"                          only if it is N or fewer levels below the command\n"
"                          line argument;  --max-depth=0 is the same as\n"
"                          --summarize\n"
msgstr ""
"  -B, --block-size=РОЗМІР використовувати блоки вказаного РОЗМІРУ. Приклад:\n"
"                           «-BM» виводить розміри у одиницях у 1.048.576 "
"байтів.\n"
"                           Формат РОЗМІР описано нижче.\n"
"  -b, --bytes           еквівалент «--apparent-size --block-size=1»\n"
"  -c, --total           підбивати підсумок\n"
"  -D, --dereference-args  розіменовувати символьні посилання у командному\n"
"                          рядку\n"
"  -d, --max-depth=Н     виводити підсумки для каталогу (або файла, якщо "
"вказано --all),\n"
"                          лише, якщо він перебуває на Н-му або нижчому рівні "
"відносно\n"
"                          аргументу командного рядка;  --max-depth=0 — те "
"саме, що і для\n"
"                          --summarize\n"

#: src/du.c:316
msgid ""
"      --files0-from=F   summarize disk usage of the\n"
"                          NUL-terminated file names specified in file F;\n"
"                          if F is -, then read names from standard input\n"
"  -H                    equivalent to --dereference-args (-D)\n"
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
"      --inodes          list inode usage information instead of block usage\n"
msgstr ""
"      --files0-from=Ф   вивести звіт про файли, чиї назви (завершені\n"
"                          нулем) перераховані у файлі Ф\n"
"                          Якщо Ф вказано - назви беруться зі стандартного "
"вводу\n"
"  -H                    еквівалент ключа --dereference-args (-D)\n"
"  -h, --human-readable  виводити розміри у зручному для людини вигляді\n"
"                          (наприклад 1K 234M 2G)\n"
"      --inodes          вивести дані щодо використання inode замість даних "
"щодо використання блоків\n"

#: src/du.c:325
msgid ""
"  -k                    like --block-size=1K\n"
"  -L, --dereference     dereference all symbolic links\n"
"  -l, --count-links     count sizes many times if hard linked\n"
"  -m                    like --block-size=1M\n"
msgstr ""
"  -k                    як --block-size=1K\n"
"  -L, --dereference     розіменувати всі символічні посилання\n"
"  -l, --count-links     прочитати кожне жорстке посилання як окремий файл\n"
"  -m                    як --block-size=1M\n"

#: src/du.c:331
msgid ""
"  -P, --no-dereference  don't follow any symbolic links (this is the "
"default)\n"
"  -S, --separate-dirs   for directories do not include size of "
"subdirectories\n"
"      --si              like -h, but use powers of 1000 not 1024\n"
"  -s, --summarize       display only a total for each argument\n"
msgstr ""
"  -P, --no-dereference  не слідувати за символьним посиланням (типово)\n"
"  -S, --separate-dirs   не включати розмір підкаталогів\n"
"      --si              подібне до -h, але з використанням мір, кратних до "
"1000, а не 1024\n"
"  -s, --summarize       виводити лише зведення для кожного аргументу\n"

#: src/du.c:337
msgid ""
"  -t, --threshold=SIZE  exclude entries smaller than SIZE if positive,\n"
"                          or entries greater than SIZE if negative\n"
"      --time            show time of the last modification of any file in "
"the\n"
"                          directory, or any of its subdirectories\n"
"      --time=WORD       show time as WORD instead of modification time:\n"
"                          atime, access, use, ctime or status\n"
"      --time-style=STYLE  show times using STYLE, which can be:\n"
"                            full-iso, long-iso, iso, or +FORMAT;\n"
"                            FORMAT is interpreted like in 'date'\n"
msgstr ""
"  -t, --threshold=РОЗМІР  виключити записи, менші за РОЗМІР, якщо додатне,\n"
"                          або записи, більші за РОЗМІР, якщо від'ємне\n"
"      --time            виводити час останньої зміни будь-якого файла у\n"
"                          каталозі або усіх його підкаталогів\n"
"      --time=СЛОВО      виводити вказаний у СЛОВО час, а не час \n"
"                          зміни: atime, access, use, ctime або status\n"
"      --time-style=СТИЛЬ виводити час, використовуючи СТИЛЬ:\n"
"                          full-iso, long-iso, iso, +ФОРМАТ\n"
"                          ФОРМАТ інтерпретується як у 'date'\n"

#: src/du.c:348
msgid ""
"  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n"
"      --exclude=PATTERN    exclude files that match PATTERN\n"
"  -x, --one-file-system    skip directories on different file systems\n"
msgstr ""
"  -X, --exclude-from=ФАЙЛ  виключити файли, назви яких відповідають зразку з "
"ФАЙЛа\n"
"      --exclude=ЗРАЗОК     виключити файли, назви яких відповідають ЗРАЗКУ\n"
"  -x, --one-file-system    пропускати каталоги на різних файлових системах\n"

#: src/du.c:400
msgid "Infinity"
msgstr "Нескінченість"

#: src/du.c:696
#, c-format
msgid "fts_read failed: %s"
msgstr "помилка fts_read: %s"

#: src/du.c:820
#, c-format
msgid "invalid maximum depth %s"
msgstr "неприпустима максимальна глибина %s"

#: src/du.c:849
msgid "invalid --threshold argument '-0'"
msgstr "некоректний аргумент --threshold «-0»"

#: src/du.c:932
#, c-format
msgid "cannot both summarize and show all entries"
msgstr "не можна одночасно підбивати зведення та виводити всі елементи"

#: src/du.c:939
#, c-format
msgid "warning: summarizing is the same as using --max-depth=0"
msgstr "попередження: підбиття зведення це те ж саме, що й --max-depth=0"

#: src/du.c:945
#, c-format
msgid "warning: summarizing conflicts with --max-depth=%lu"
msgstr "попередження: підбиття зведення конфліктує з --max-depth=%lu"

#: src/du.c:956
#, c-format
msgid "warning: options --apparent-size and -b are ineffective with --inodes"
msgstr ""
"попередження: параметри --apparent-size і -b не працюватимуть з --inodes"

#: src/du.c:1021 src/sort.c:4594 src/wc.c:726
msgid "file operands cannot be combined with --files0-from"
msgstr "операнди-файли не можна використовувати разом з --files0-from"

#: src/du.c:1088 src/sort.c:4623 src/wc.c:805
#, c-format
msgid "when reading file names from stdin, no file name of %s allowed"
msgstr "при читанні імен файлів з stdin, не допускаються назви файлів %s"

#: src/du.c:1105 src/du.c:1113 src/wc.c:818 src/wc.c:826
msgid "invalid zero-length file name"
msgstr "неправильна назва файла нульової довжини"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:26
msgid "Brian Fox"
msgstr "Brian Fox"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:27
msgid "Chet Ramey"
msgstr "Chet Ramey"

#: src/echo.c:41
#, c-format
msgid ""
"Usage: %s [SHORT-OPTION]... [STRING]...\n"
"  or:  %s LONG-OPTION\n"
msgstr ""
"Використання: %s [СКОРОЧЕНИЙ-ПАРАМЕТР]... [РЯДОК]...\n"
"  або  %s ДОВГИЙ-ПАРАМЕТР\n"

#: src/echo.c:45
msgid ""
"Echo the STRING(s) to standard output.\n"
"\n"
"  -n             do not output the trailing newline\n"
msgstr ""
"Виводить РЯДОК(РЯДКА) на стандартний вивід.\n"
"\n"
"  -n             не виводити завершальне переведення рядка\n"

#: src/echo.c:51
msgid ""
"  -e             enable interpretation of backslash escapes (default)\n"
"  -E             disable interpretation of backslash escapes\n"
msgstr ""
"  -e             інтерпретувати керівні послідовності (типово)\n"
"  -E             не інтерпретувати керівні послідовності\n"

#: src/echo.c:54
msgid ""
"  -e             enable interpretation of backslash escapes\n"
"  -E             disable interpretation of backslash escapes (default)\n"
msgstr ""
"  -e             інтерпретувати керівні послідовності\n"
"  -E             не інтерпретувати керівні послідовності (типово)\n"

#: src/echo.c:60
msgid ""
"\n"
"If -e is in effect, the following sequences are recognized:\n"
"\n"
msgstr ""
"\n"
"Якщо задіяно -e, розпізнаються такі послідовності:\n"
"\n"

#: src/echo.c:65 src/printf.c:110
msgid ""
"  \\\\      backslash\n"
"  \\a      alert (BEL)\n"
"  \\b      backspace\n"
"  \\c      produce no further output\n"
"  \\e      escape\n"
"  \\f      form feed\n"
"  \\n      new line\n"
"  \\r      carriage return\n"
"  \\t      horizontal tab\n"
"  \\v      vertical tab\n"
msgstr ""
"  \\\\      зворотна риска\n"
"  \\a      дзвінок (BEL)\n"
"  \\b      backspace\n"
"  \\c      не виводити завершальний символ нового рядка\n"
"  \\e      escape\n"
"  \\f      нова сторінка\n"
"  \\n      новий рядок\n"
"  \\r      переведення каретки\n"
"  \\t      горизонтальна табуляція\n"
"  \\v      вертикальна табуляція\n"

#: src/echo.c:77
msgid ""
"  \\0NNN   byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
msgstr ""
"  \\0NNN   байт з вісімковим значенням NNN (від 1 до 3 цифр)\n"
"  \\xHH    байт з шістнадцятковим значенням HH (від 1 до 2 цифр)\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/env.c:33 src/printenv.c:45 src/whoami.c:36
msgid "Richard Mlynarik"
msgstr "Richard Mlynarik"

#: src/env.c:53
#, c-format
msgid "Usage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [-] [НАЗВА=ЗНАЧЕННЯ]... [КОМАНДА [АРГ]...]\n"

#: src/env.c:56
msgid "Set each NAME to VALUE in the environment and run COMMAND.\n"
msgstr ""
"Встановлює кожній НАЗВІ відповідне ЗНАЧЕННЯ та запускає КОМАНДУ у цьому\n"
"середовищі.\n"

#: src/env.c:62
msgid ""
"  -i, --ignore-environment  start with an empty environment\n"
"  -0, --null           end each output line with NUL, not newline\n"
"  -u, --unset=NAME     remove variable from the environment\n"
msgstr ""
"  -i, --ignore-environment   почати з порожнім оточенням\n"
"  -0, --null                 завершувати кожен з виведених рядків нуль-"
"байтом, а не розривом рядка\n"
"  -u, --unset=НАЗВА          вилучити з оточення НАЗВИ\n"

#: src/env.c:69
msgid ""
"\n"
"A mere - implies -i.  If no COMMAND, print the resulting environment.\n"
msgstr ""
"\n"
"Просто '-' -- синонім для '-i'.  Якщо не вказана КОМАНДА, виводить отримане\n"
"оточення.\n"

#: src/env.c:125
#, c-format
msgid "cannot unset %s"
msgstr "не вдалося вилучити %s"

#: src/env.c:136
#, c-format
msgid "cannot set %s"
msgstr "не вдалося встановити %s"

#: src/env.c:153
#, c-format
msgid "cannot specify --null (-0) with command"
msgstr "не можна вказувати --null (-0) з командою"

#: src/expand-common.c:86
msgid "tabs are too far apart"
msgstr "позиції табуляції надто далеко одна від одної"

#: src/expand-common.c:99
#, c-format
msgid "'/' specifier only allowed with the last value"
msgstr "специфікатор «/» можна використовувати лише із останнім значенням"

#: src/expand-common.c:142
#, c-format
msgid "'/' specifier not at start of number: %s"
msgstr "специфікатор «/» не розташовано на початку числа: %s"

#: src/expand-common.c:162
#, c-format
msgid "tab stop is too large %s"
msgstr "розмір табуляції надто великий %s"

#: src/expand-common.c:170
#, c-format
msgid "tab size contains invalid character(s): %s"
msgstr "розмір табуляції містить неприпустимий знак (знаки): %s"

#: src/expand-common.c:201
msgid "tab size cannot be 0"
msgstr "розмір табуляції не може дорівнювати нулю"

#: src/expand-common.c:203
msgid "tab sizes must be ascending"
msgstr "номера позицій табуляції повинні зростати"

#: src/expand.c:73
msgid "Convert tabs in each FILE to spaces, writing to standard output.\n"
msgstr ""
"Перетворити табуляції у кожному з ФАЙЛів на пробіли, записати до\n"
"стандартного виведення.\n"

#: src/expand.c:80
msgid ""
"  -i, --initial       do not convert tabs after non blanks\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
msgstr ""
"  -i, --initial       не перетворювати знаки табуляції після знаків "
"пробілів\n"
"  -t, --tabs=ЧИСЛО    встановлює ширину табуляції, типово 8\n"

#: src/expand.c:84
msgid ""
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
msgstr ""
"  -t, --tabs=СПИСОК   використовувати розділений комами список позицій "
"табуляції\n"

#: src/expand.c:148 src/expand.c:167 src/unexpand.c:181 src/unexpand.c:226
msgid "input line is too long"
msgstr "вхідний рядок надто великий"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:150 src/ln.c:42 src/mv.c:41 src/tee.c:36
msgid "Mike Parker"
msgstr "Mike Parker"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:151 src/groups.c:37
msgid "James Youngman"
msgstr "James Youngman"

#: src/expr.c:202
#, c-format
msgid ""
"Usage: %s EXPRESSION\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s ВИРАЗ\n"
"       або:    %s КЛЮЧ\n"

#: src/expr.c:210
msgid ""
"\n"
"Print the value of EXPRESSION to standard output.  A blank line below\n"
"separates increasing precedence groups.  EXPRESSION may be:\n"
"\n"
"  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n"
"\n"
"  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0\n"
msgstr ""
"\n"
"Виводить значення ВИРАЗУ на стандартний вивід.  Нижче порожніми рядками\n"
"розділені групи за зростанням пріоритету.  Можливі ВИРАЗИ:\n"
"\n"
"  АРГ1 | АРГ2       АРГ1, якщо він відмінний від нуля, інакше АРГ2\n"
"\n"
"  АРГ1 & АРГ2       АРГ1, якщо обидва відмінні від нуля, інакше 0\n"

#: src/expr.c:219
msgid ""
"\n"
"  ARG1 < ARG2       ARG1 is less than ARG2\n"
"  ARG1 <= ARG2      ARG1 is less than or equal to ARG2\n"
"  ARG1 = ARG2       ARG1 is equal to ARG2\n"
"  ARG1 != ARG2      ARG1 is unequal to ARG2\n"
"  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2\n"
"  ARG1 > ARG2       ARG1 is greater than ARG2\n"
msgstr ""
"\n"
"  АРГ1 < АРГ2       АРГ1 менше АРГ2\n"
"  АРГ1 <= АРГ2      АРГ1 менше або дорівнює АРГ2\n"
"  АРГ1 = АРГ2       АРГ1 дорівнює АРГ2\n"
"  АРГ1 != АРГ2      АРГ1 не дорівнює АРГ2\n"
"  АРГ1 >= АРГ2      АРГ1 більше або дорівнює АРГ2\n"
"  АРГ1 > АРГ2       АРГ1 більше АРГ2\n"

#: src/expr.c:228
msgid ""
"\n"
"  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2\n"
"  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2\n"
msgstr ""
"\n"
"  АРГ1 + АРГ2       арифметична сума АРГ1 та АРГ2\n"
"  АРГ1 - АРГ2       арифметична різниця АРГ1 та АРГ2\n"

#: src/expr.c:235
#, no-c-format
msgid ""
"\n"
"  ARG1 * ARG2       arithmetic product of ARG1 and ARG2\n"
"  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2\n"
"  ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2\n"
msgstr ""
"\n"
"  АРГ1 * АРГ2       арифметичний добуток АРГ1 та АРГ2\n"
"  АРГ1 / АРГ2       арифметична частка від АРГ1 та АРГ2\n"
"  АРГ1 % AРГ2       арифметичний залишок від ділення АРГ1 на АРГ2\n"

#: src/expr.c:241
msgid ""
"\n"
"  STRING : REGEXP   anchored pattern match of REGEXP in STRING\n"
"\n"
"  match STRING REGEXP        same as STRING : REGEXP\n"
"  substr STRING POS LENGTH   substring of STRING, POS counted from 1\n"
"  index STRING CHARS         index in STRING where any CHARS is found, or 0\n"
"  length STRING              length of STRING\n"
msgstr ""
"\n"
"  РЯДОК : REGEXP   перевірка відповідності REGEXP початку або кінцю РЯДКА\n"
"\n"
"  match РЯДОК REGEXP        те саме, що та РЯДОК : REGEXP\n"
"  substr РЯДОК ПОЗ ДОВЖИНА  частина РЯДКА, позиція відраховується від 1\n"
"  index РЯДОК СИМВОЛИ       позиція у РЯДКУ, де першим знайдений будь-який\n"
"                            з СИМВОЛІВ, інакше 0\n"
"  length РЯДОК              довжина РЯДКА\n"

#: src/expr.c:250
msgid ""
"  + TOKEN                    interpret TOKEN as a string, even if it is a\n"
"                               keyword like 'match' or an operator like '/'\n"
"\n"
"  ( EXPRESSION )             value of EXPRESSION\n"
msgstr ""
"  + ЛЕКСЕМА                  сприймати ЛЕКСЕМУ як рядок, навіть якщо це\n"
"                             ключове слово, як 'match', або оператор, як "
"'/'\n"
"\n"
"  ( ВИРАЗ )                  значення ВИРАЗУ\n"

#: src/expr.c:256
msgid ""
"\n"
"Beware that many operators need to be escaped or quoted for shells.\n"
"Comparisons are arithmetic if both ARGs are numbers, else lexicographical.\n"
"Pattern matches return the string matched between \\( and \\) or null; if\n"
"\\( and \\) are not used, they return the number of characters matched or "
"0.\n"
msgstr ""
"\n"
"Пам'ятайте, що при використанні у оболонці деякі оператори повинні бути\n"
"взяті у дужки.  Якщо обидва аргументу АРГ є числами, то виконується\n"
"арифметичний порівняння, інакше вони порівнюються як рядки.  При "
"відповідності\n"
"шаблону повертається відповідний рядок рядок між \\( та \\) або порожній "
"рядок;\n"
"якщо \\( та \\) не використовуються, то повертається кількість відповідних "
"символів.\n"

#: src/expr.c:263
msgid ""
"\n"
"Exit status is 0 if EXPRESSION is neither null nor 0, 1 if EXPRESSION is "
"null\n"
"or 0, 2 if EXPRESSION is syntactically invalid, and 3 if an error occurred.\n"
msgstr ""
"\n"
"Статус завершення дорівнює 0, якщо ВИРАЗ не порожній та не 0; 1, якщо\n"
"ВИРАЗ порожній або 0; 2, якщо ВИРАЗ синтаксично неправильний; та 3,\n"
"якщо виникла помилка.\n"

#: src/expr.c:277
msgid "syntax error"
msgstr "синтаксична помилка"

#: src/expr.c:590 src/ptx.c:284
msgid "error in regular expression matcher"
msgstr "помилка у механізмі відповідності регулярних виразів"

#: src/expr.c:782 src/expr.c:819
msgid "non-integer argument"
msgstr "не цілочисловий аргумент"

#: src/expr.c:784 src/truncate.c:289
msgid "division by zero"
msgstr "ділення на нуль"

#: src/expr.c:878 src/sort.c:2106
#, c-format
msgid "set LC_ALL='C' to work around the problem"
msgstr "Щоб обійти цю проблему, встановіть LC_ALL='C'"

#: src/expr.c:880
#, c-format
msgid "the strings compared were %s and %s"
msgstr "рядки, що порівнювались %s та %s."

#. This is a proper name. See the gettext manual, section Names.
#: src/factor.c:130
msgid "Niels Moller"
msgstr "Niels Moller"

#: src/factor.c:1276 src/factor.c:1376 src/factor.c:1452
#, c-format
msgid "Lucas prime test failure.  This should not happen"
msgstr "Не вдалося перевірити простоту за тестом Люка. Цього не мало статися."

#: src/factor.c:2103
msgid "squfof queue overflow"
msgstr "переповнення черги squfof"

#: src/factor.c:2525
#, c-format
msgid "%s is not a valid positive integer"
msgstr "%s не є правильним цілим додатнім числом"

#: src/factor.c:2549 src/od.c:1695 src/od.c:1776
#, c-format
msgid "%s is too large"
msgstr "%s надто велике"

#: src/factor.c:2561
#, c-format
msgid ""
"Usage: %s [NUMBER]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s [ЧИСЛО]...\n"
"       або:    %s КЛЮЧ\n"

#: src/factor.c:2566
msgid ""
"Print the prime factors of each specified integer NUMBER.  If none\n"
"are specified on the command line, read them from standard input.\n"
"\n"
msgstr ""
"Виводить прості множники для кожного вказаного цілого ЧИСЛА. Якщо\n"
"числа не вказано у командному рядку, читати дані зі стандартного джерела.\n"
"\n"

#: src/find-mount-point.c:40
#, c-format
msgid "cannot get current directory"
msgstr "поточний каталог недоступний"

#: src/find-mount-point.c:50 src/find-mount-point.c:64
#: src/find-mount-point.c:92
#, c-format
msgid "cannot change to directory %s"
msgstr "не вдалося змінити каталог на %s"

#: src/find-mount-point.c:70
#, c-format
msgid "cannot stat current directory (now %s)"
msgstr "не вдалося виконати stat для поточного каталогу (наразі %s)"

#. This is a proper name. See the gettext manual, section Names.
#: src/fmt.c:37
msgid "Ross Paterson"
msgstr "Ross Paterson"

#: src/fmt.c:269
#, c-format
msgid "Usage: %s [-WIDTH] [OPTION]... [FILE]...\n"
msgstr "Використання: %s [-ШИРИНА] [ПАРАМЕТР]... [ФАЙЛ]...\n"

#: src/fmt.c:270
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"The option -WIDTH is an abbreviated form of --width=DIGITS.\n"
msgstr ""
"Переформатує кожен абзац у ФАЙЛІ(ах) та виводить на стандартне виведення.\n"
"Параметр -ШИРИНА є скороченою формою --width=ЧИСЛО.\n"

#: src/fmt.c:278
msgid ""
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       reformat only lines beginning with STRING,\n"
"                              reattaching the prefix to reformatted lines\n"
"  -s, --split-only          split long lines, but do not refill\n"
msgstr ""
"  -c, --crown-margin       зберігати відступи двох перших рядків\n"
"  -p, --prefix=РЯДОК       форматувати лише рядки, що починаються з РЯДОК,\n"
"                             зберігаючи при цьому префікс рядків\n"
"  -s, --split-only         розбивати довгі рядки, але не заповнювати\n"

#: src/fmt.c:287
#, no-c-format
msgid ""
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=WIDTH         maximum line width (default of 75 columns)\n"
"  -g, --goal=WIDTH          goal width (default of 93% of width)\n"
msgstr ""
"  -t, --tagged-paragraph   відступ першого рядка, відмінний від другого\n"
"  -u, --uniform-spacing    один пробіл після слова, два після речення\n"
"  -w, --width=ЧИСЛО        максимальна довжина рядка (типово 75 позицій)\n"
"  -g, --goal=ДОВЖИНА       остаточна довжина (типово 93% довжини)\n"

#: src/fmt.c:355
#, c-format
msgid ""
"invalid option -- %c; -WIDTH is recognized only when it is the first\n"
"option; use -w N instead"
msgstr ""
"неправильний ключ -- %c; -ШИРИНА розпізнається, лише якщо це перший\n"
"аргумент, у іншому випадку вказуйте -w N"

#: src/fmt.c:399 src/fmt.c:406
msgid "invalid width"
msgstr "некоректна ширина"

#: src/fold.c:70
msgid "Wrap input lines in each FILE, writing to standard output.\n"
msgstr ""
"Розбиває рядки у ФАЙЛІ(ах) та виводить результат до стандартного\n"
"виведення.\n"

#: src/fold.c:77
msgid ""
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""
"  -b, --bytes         прочитати байти, а не стовпчики\n"
"  -s, --spaces        розбивати лише на пробілах\n"
"  -w, --width=ЧИСЛО   використовувати вказане ЧИСЛО стовпчиків, а не 80\n"

#: src/fold.c:284 src/pr.c:840
msgid "invalid number of columns"
msgstr "некоректна кількість стовпчиків"

#. This is a proper name. See the gettext manual, section Names.
#: src/getlimits.c:30 src/md5sum.c:107 src/realpath.c:33 src/stdbuf.c:38
#: src/timeout.c:78 src/truncate.c:38
msgid "Padraig Brady"
msgstr "Padraig Brady"

#: src/getlimits.c:66
#, c-format
msgid "Usage: %s\n"
msgstr "Використання: %s\n"

#: src/getlimits.c:70
msgid ""
"Output platform dependent limits in a format useful for shell scripts.\n"
"\n"
msgstr ""
"Ліміти платформи виводу обмежені у форматі придатному для використання у "
"сценаріях.\n"
"\n"

#: src/group-list.c:69 src/id.c:415
#, c-format
msgid "failed to get groups for user %s"
msgstr "помилка при отриманні груп користувачів %s"

#: src/group-list.c:74 src/id.c:418
#, c-format
msgid "failed to get groups for the current process"
msgstr "не вдалося отримати групи для поточного процесу"

#: src/group-list.c:114
#, c-format
msgid "cannot find name for group ID %lu"
msgstr "не вдалося визначити назву групи для ID %lu"

#: src/groups.c:54
#, c-format
msgid "Usage: %s [OPTION]... [USERNAME]...\n"
msgstr "Використання: %s [КЛЮЧ]... [КОРИСТУВАЧ]...\n"

#: src/groups.c:55
msgid ""
"Print group memberships for each USERNAME or, if no USERNAME is specified, "
"for\n"
"the current process (which may differ if the groups database has changed).\n"
msgstr ""
"Вивести дані щодо участі у групах для кожного ІМЕНІ КОРИСТУВАЧА, якщо імені "
"не\n"
"вказано, буде показано дані для поточного процесу (може бути іншим, якщо "
"було\n"
"змінено базу даних груп).\n"

#: src/groups.c:106 src/id.c:277
msgid "cannot get real UID"
msgstr "не вдалося встановити справжній UID"

#: src/groups.c:111 src/id.c:285
msgid "cannot get effective GID"
msgstr "не вдалося отримати ефективний GID"

#: src/groups.c:116 src/id.c:290
msgid "cannot get real GID"
msgstr "не вдалося встановити справжній GID"

#: src/groups.c:129 src/id.c:249
#, c-format
msgid "%s: no such user"
msgstr "%s: такого користувача не існує"

#: src/head.c:114
#, c-format
msgid ""
"Print the first %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
msgstr ""
"Виводить перші %d рядків кожного з ФАЙЛІВ до стандартного виведення.\n"
"Якщо задано декілька ФАЙЛІВ, спочатку виводить перед даними заголовок із "
"назвою файла.\n"

#: src/head.c:122
#, c-format
msgid ""
"  -c, --bytes=[-]NUM       print the first NUM bytes of each file;\n"
"                             with the leading '-', print all but the last\n"
"                             NUM bytes of each file\n"
"  -n, --lines=[-]NUM       print the first NUM lines instead of the first "
"%d;\n"
"                             with the leading '-', print all but the last\n"
"                             NUM lines of each file\n"
msgstr ""
"  -c, --bytes=[-]K         вивести перші K байтів кожного файла;\n"
"                             якщо перед K стоїть «-», вивести всі, крім K\n"
"                             останніх байтів кожного файла\n"
"  -n, --lines=[-]K         вивести перші K рядків кожного файла, а не %d;\n"
"                             якщо перед K стоїть «-», вивести всі, крім K\n"
"                             останніх рядків кожного файла\n"

#: src/head.c:130
msgid ""
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
msgstr ""
"  -q, --quiet, --silent   не виводити заголовки з назвами файлів\n"
"  -v, --verbose           завжди виводити заголовки з назвами файлів\n"

#: src/head.c:139
msgid ""
"\n"
"NUM may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
msgstr ""
"\n"
"Після ЧИСЛА блоків та байт може стоять один з множників:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024 тощо для T, P, E, Z, Y.\n"

#: src/head.c:159
#, c-format
msgid "%s: file has shrunk too much"
msgstr "%s: файл надто скоротився"

#: src/head.c:231 src/tail.c:460
#, c-format
msgid "%s: cannot seek to offset %s"
msgstr "%s: не вдалося перейти до позиції %s"

#: src/head.c:232 src/tail.c:464
#, c-format
msgid "%s: cannot seek to relative offset %s"
msgstr "%s: не вдалося перемістити вказівник позиції на %s"

#: src/head.c:274
#, c-format
msgid "%s: number of bytes is too large"
msgstr "%s: число байт надто великий"

#: src/head.c:912 src/split.c:1356 src/split.c:1517 src/tail.c:2108
msgid "invalid number of lines"
msgstr "неправильна кількість рядків"

#: src/head.c:913 src/head.c:1077 src/split.c:1348 src/split.c:1364
#: src/tail.c:2109
msgid "invalid number of bytes"
msgstr "неправильна кількість байт"

#: src/head.c:1003 src/head.c:1065
#, c-format
msgid "invalid trailing option -- %c"
msgstr "неправильний завершальний ключ -- '%c'"

#: src/hostid.c:42
#, c-format
msgid ""
"Usage: %s [OPTION]\n"
"Print the numeric identifier (in hexadecimal) for the current host.\n"
"\n"
msgstr ""
"Використання: %s [ПАРАМЕТР]\n"
"Вивести числовий ідентифікатор (шістнадцяткове) для поточного вузла.\n"
"\n"

#: src/hostname.c:57
#, c-format
msgid ""
"Usage: %s [NAME]\n"
"  or:  %s OPTION\n"
"Print or set the hostname of the current system.\n"
"\n"
msgstr ""
"Використання: %s [НАЗВА]\n"
"       або:    %s КЛЮЧ\n"
"Виводить або встановлює назву цієї системи.\n"
"\n"

#: src/hostname.c:95
#, c-format
msgid "cannot set name to %s"
msgstr "не вдалося встановити назву у %s"

#: src/hostname.c:99
msgid "cannot set hostname; this system lacks the functionality"
msgstr "не вдалося встановити основну назву -- ця система не має такої функції"

#: src/hostname.c:107
msgid "cannot determine hostname"
msgstr "не вдалося визначити назву машини"

#. This is a proper name. See the gettext manual, section Names.
#: src/id.c:41 src/touch.c:43
msgid "Arnold Robbins"
msgstr "Arnold Robbins"

#: src/id.c:85
#, c-format
msgid "Usage: %s [OPTION]... [USER]\n"
msgstr "Використання: %s [КЛЮЧ]... [КОРИСТУВАЧ]\n"

#: src/id.c:86
msgid ""
"Print user and group information for the specified USER,\n"
"or (when USER omitted) for the current user.\n"
"\n"
msgstr ""
"Вивести дані щодо користувача і групи для вказаного користувача\n"
"або (якщо користувача не вказано) для поточного користувача.\n"
"\n"

#: src/id.c:91
msgid ""
"  -a             ignore, for compatibility with other versions\n"
"  -Z, --context  print only the security context of the process\n"
"  -g, --group    print only the effective group ID\n"
"  -G, --groups   print all group IDs\n"
"  -n, --name     print a name instead of a number, for -ugG\n"
"  -r, --real     print the real ID instead of the effective ID, with -ugG\n"
"  -u, --user     print only the effective user ID\n"
"  -z, --zero     delimit entries with NUL characters, not whitespace;\n"
"                   not permitted in default format\n"
msgstr ""
"  -a              ігнорувати, визначено лише для сумісності\n"
"  -Z, --context   виводити лише контекст безпеки процесу\n"
"  -g, --group     виводити лише ID групи\n"
"  -G, --groups    виводити лише додаткові групи\n"
"  -n, --name      виводити назва замість номера, для ключів -ugG\n"
"  -r, --real      виводити дійсні, а не ефективні ID, для ключів -ugG\n"
"  -u, --user      виводити лише ID користувача\n"
"  -z, --zero      розмежовувати записи символами NUL, а не пробілами;\n"
"                    не можна використовувати у типовому форматі\n"

#: src/id.c:104
msgid ""
"\n"
"Without any OPTION, print some useful set of identified information.\n"
msgstr ""
"\n"
"Якщо КЛЮЧІ не вказані, виводить стандартний набір корисних відомостей.\n"

#: src/id.c:152
msgid "--context (-Z) works only on an SELinux/SMACK-enabled kernel"
msgstr "--context (-Z) працює, якщо ядро має підтримку SELinux або SMACK"

#: src/id.c:157
msgid "--context (-Z) works only on an SELinux-enabled kernel"
msgstr "--context (-Z) працює, якщо ядро має підтримку SELinux"

#: src/id.c:196
msgid "cannot print security context when user specified"
msgstr "не можна виводити контекст безпеки, коли вказано користувача"

#: src/id.c:199
msgid "cannot print \"only\" of more than one choice"
msgstr "не можна виводити \"only\" для більш ніж одного варіанту"

#: src/id.c:208
msgid "cannot print only names or real IDs in default format"
msgstr "не можна виводити лише назви або дійсні ID у типовому форматі"

#: src/id.c:212
msgid "option --zero not permitted in default format"
msgstr "у типовому форматі не можна використовувати параметр --zero"

#: src/id.c:228
msgid "can't get process context"
msgstr "не можна отримати контекст процесу"

#: src/id.c:268
msgid "cannot get effective UID"
msgstr "не вдалося отримати ефективний UID"

#: src/id.c:357
#, c-format
msgid "cannot find name for user ID %s"
msgstr "не вдалося визначити ім'я користувача для ID %s"

#: src/id.c:375
#, c-format
msgid "uid=%s"
msgstr "uid=%s"

#: src/id.c:380
#, c-format
msgid " gid=%s"
msgstr " gid=%s"

#: src/id.c:387
#, c-format
msgid " euid=%s"
msgstr " euid=%s"

#: src/id.c:395
#, c-format
msgid " egid=%s"
msgstr " egid=%s"

#: src/id.c:424
msgid " groups="
msgstr " групи="

#: src/id.c:440
#, c-format
msgid " context=%s"
msgstr " контекст=%s"

#: src/install.c:378
#, c-format
msgid "warning: %s: failed to change context to %s"
msgstr "попередження: %s: не вдалося змінити контекст у %s"

#: src/install.c:420
#, c-format
msgid "creating directory %s"
msgstr "створення каталогу %s"

#: src/install.c:432 src/mkdir.c:128 src/mkdir.c:161
#, c-format
msgid "failed to set default creation context for %s"
msgstr "помилка встановлення типового контексту для створення %s"

#: src/install.c:462 src/mkdir.c:181
#, c-format
msgid "failed to restore context for %s"
msgstr "не вдалося зберегти мітки часу для %s"

#: src/install.c:510
#, c-format
msgid "cannot change ownership of %s"
msgstr "не вдалося змінити власника %s"

#: src/install.c:534
#, c-format
msgid "cannot set timestamps for %s"
msgstr "не вдалося встановити часові позначки для %s"

#: src/install.c:556 src/split.c:519 src/timeout.c:477
#, c-format
msgid "fork system call failed"
msgstr "системний виклик fork завершився помилкою"

#: src/install.c:560
#, c-format
msgid "cannot run %s"
msgstr "не вдалося запустити %s"

#: src/install.c:563
#, c-format
msgid "waiting for strip"
msgstr "очікування strip"

#: src/install.c:565
#, c-format
msgid "strip process terminated abnormally"
msgstr "процес strip завершився помилкою"

#: src/install.c:589
#, c-format
msgid "invalid user %s"
msgstr "неправильний користувач %s"

#: src/install.c:627
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
"  or:  %s [OPTION]... -d DIRECTORY...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [-T] ДЖЕРЕЛО ПРИЗНАЧЕННЯ\n"
"       або    %s [КЛЮЧ]... ДЖЕРЕЛО... КАТАЛОГ\n"
"       або    %s [КЛЮЧ]... -t КАТАЛОГ ДЖЕРЕЛО...\n"
"       або    %s [КЛЮЧ]... -d КАТАЛОГ...\n"

#: src/install.c:634
msgid ""
"\n"
"This install program copies files (often just compiled) into destination\n"
"locations you choose.  If you want to download and install a ready-to-use\n"
"package on a GNU/Linux system, you should instead be using a package "
"manager\n"
"like yum(1) or apt-get(1).\n"
"\n"
"In the first three forms, copy SOURCE to DEST or multiple SOURCE(s) to\n"
"the existing DIRECTORY, while setting permission modes and owner/group.\n"
"In the 4th form, create all components of the given DIRECTORY(ies).\n"
msgstr ""
"\n"
"Ця програма для встановлення копіює файли (часто щойно зібрані) до "
"вказаного\n"
"вами місця призначення. Якщо вам потрібно отримати і встановити готовий до\n"
"використання пакунок у системі GNU/Linux, вам краще скористатися програмою\n"
"для керування пакунками, зокрема yum(1) або apt-get(1).\n"
"\n"
"У перших трьох формах копіює ДЖЕРЕЛО до ПРИЗНАЧЕННЯ або декілька\n"
"ДЖЕРЕЛ до вже створеного КАТАЛОГу, встановлюючи режими доступу та\n"
"власника/групу.  В четвертій формі створює всі компоненти вказаних\n"
"КАТАЛОГІВ.\n"

#: src/install.c:648
msgid ""
"      --backup[=CONTROL]  make a backup of each existing destination file\n"
"  -b                  like --backup but does not accept an argument\n"
"  -c                  (ignored)\n"
"  -C, --compare       compare each pair of source and destination files, "
"and\n"
"                        in some cases, do not modify the destination at all\n"
"  -d, --directory     treat all arguments as directory names; create all\n"
"                        components of the specified directories\n"
msgstr ""
"      --backup[=CONTROL]  створити резервну копію перед вилученням\n"
"  -b                  те саме, що і --backup, але без аргументу\n"
"  -c                  (ігнорується)\n"
"  -C, --compare       порівняти кожну пару файлів джерела і призначення і,\n"
"                        за певних умов, не змінювати призначення\n"
"  -d, --directory     вважати всі аргументи каталогами; створювати всі\n"
"                        компоненти вказаних каталогів\n"

#: src/install.c:657
msgid ""
"  -D                  create all leading components of DEST except the "
"last,\n"
"                        or all components of --target-directory,\n"
"                        then copy SOURCE to DEST\n"
"  -g, --group=GROUP   set group ownership, instead of process' current "
"group\n"
"  -m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-xr-"
"x\n"
"  -o, --owner=OWNER   set ownership (super-user only)\n"
msgstr ""
"  -D                  створювати всі початкові складові ЦІЛІ крім\n"
"                        останньої, або усі компоненти --target-directory,\n"
"                        потім копіювати ДЖЕРЕЛО у ЦІЛЬ\n"
"  -g, --group=ГРУПА   встановлювати ГРУПУ, а не групу поточного процесу\n"
"  -m, --mode=РЕЖИМ    встановлювати РЕЖИМ (як chmod), а не rwxr-xr-x\n"
"  -o, --owner=ВЛАСНИК встановлювати ВЛАСНИКА (лише для суперкористувача)\n"

#: src/install.c:665
msgid ""
"  -p, --preserve-timestamps   apply access/modification times of SOURCE "
"files\n"
"                        to corresponding destination files\n"
"  -s, --strip         strip symbol tables\n"
"      --strip-program=PROGRAM  program used to strip binaries\n"
"  -S, --suffix=SUFFIX  override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory  treat DEST as a normal file\n"
"  -v, --verbose       print the name of each directory as it is created\n"
msgstr ""
"  -p, --preserve-timestamps встановлювати цільовим файлам час\n"
"                        доступу/зміни як у їх файлів-ДЖЕРЕЛ\n"
"  -s, --strip         вилучати таблиці символів\n"
"      --strip-program=ПРОГРАМА  програма, що використовується для вилучення\n"
"  -S, --suffix=СУФІКС використовувати для резервних копій заданий СУФІКС\n"
"  -t, --target-directory=КАТАЛОГ копіювати всі аргументи-ДЖЕРЕЛА у КАТАЛОГ\n"
"  -T, --no-target-directory вважати ЦІЛЬ звичайним файлом\n"
"  -v, --verbose       виводити назву кожного створюваного каталогу\n"

#: src/install.c:675
msgid ""
"      --preserve-context  preserve SELinux security context\n"
"  -Z                      set SELinux security context of destination\n"
"                            file and each created directory to default type\n"
"      --context[=CTX]     like -Z, or if CTX is specified then set the\n"
"                            SELinux or SMACK security context to CTX\n"
msgstr ""
"      --preserve-context  зберігати контекст безпеки SELinux\n"
"      -Z                  встановити типовий тип контексту безпеки SELinux\n"
"                            для файла призначення і кожного створеного "
"каталогу\n"
"      --context[=CTX]     подібний до -Z, якщо вказано CTX, встановити "
"контекст безпеки\n"
"                            SELinux або SMACK відповідно до вказаного "
"значення\n"
"                            контексту CTX\n"

#: src/install.c:711 src/unlink.c:87
#, c-format
msgid "cannot unlink %s"
msgstr "не вдалося вилучити посилання %s"

#: src/install.c:891
#, c-format
msgid ""
"WARNING: ignoring --preserve-context; this kernel is not SELinux-enabled"
msgstr ""
"Попередження: --preserve-context ігнорується; ядро не підтримує SELinux."

#: src/install.c:931
msgid "the strip option may not be used when installing a directory"
msgstr "при встановленні каталогу не можна вживати ключ strip"

#: src/install.c:934
msgid "target directory not allowed when installing a directory"
msgstr "при встановленні каталогу не можна вказувати цільовий каталог"

#: src/install.c:1000 src/mkdir.c:284 src/stdbuf.c:352
#, c-format
msgid "invalid mode %s"
msgstr "неправильний режим %s"

#: src/install.c:1007
#, c-format
msgid "WARNING: ignoring --strip-program option as -s option was not specified"
msgstr ""
"ПОПЕРЕДЖЕННЯ: ігноруємо параметр --strip-program, оскільки параметр -s не "
"вказано"

#: src/install.c:1012
#, c-format
msgid "options --compare (-C) and --preserve-timestamps are mutually exclusive"
msgstr ""
"параметри --compare (-C) і --preserve-timestamps не можна використовувати "
"одночасно"

#: src/install.c:1019
#, c-format
msgid "options --compare (-C) and --strip are mutually exclusive"
msgstr "параметри --compare (-C) і --strip не можна використовувати одночасно"

#: src/install.c:1025
#, c-format
msgid ""
"the --compare (-C) option is ignored when you specify a mode with non-"
"permission bits"
msgstr ""
"параметр --compare (-C) пропускається, якщо ви вкажете режим з заборонними "
"бітами"

#. This is a proper name. See the gettext manual, section Names.
#: src/join.c:41 src/sort.c:67
msgid "Mike Haertel"
msgstr "Mike Haertel"

#: src/join.c:196
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited by blanks.\n"
msgstr ""
"Для кожної пари вхідних рядків з однаковими полями виводить рядок\n"
"до стандартного виведення. Типово спільне поле вважається першим, поля\n"
"розділюються знаками пробілів.\n"

#: src/join.c:205
msgid ""
"\n"
"  -a FILENUM        also print unpairable lines from file FILENUM, where\n"
"                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
msgstr ""
"\n"
"  -a НОМЕР           виводити рядки що не мають пари з файла з вказаним\n"
"                       номером (1 або 2)\n"
"  -e РЯДОК           замінювати при виводі порожні рядки вказаним РЯДКОМ\n"

#: src/join.c:211
msgid ""
"  -i, --ignore-case  ignore differences in case when comparing fields\n"
"  -j FIELD          equivalent to '-1 FIELD -2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
msgstr ""
"  -i, --ignore-case  ігнорувати регістр літер при порівнянні полів\n"
"  -j ПОЛЕ            еквівалентно '-1 ПОЛЕ -2 ПОЛЕ'\n"
"  -o ФОРМАТ          виводити відповідно до ФОРМАТУ\n"
"  -t ЗНАК            використовувати ЗНАК розділення полів вводу та виводу\n"

#: src/join.c:217
msgid ""
"  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
"  --header          treat the first line in each file as field headers,\n"
"                      print them without trying to pair them\n"
msgstr ""
"  -v НОМЕР          як -а НОМЕР, але не виводити наявні пари рядків\n"
"  -1 ПОЛЕ           вважати спільним вказане ПОЛЕ файла 1\n"
"  -2 ПОЛЕ           вважати спільним вказане ПОЛЕ файла 2\n"
"  --check-order     перевірити, чи впорядковано належним чином введення,\n"
"                      навіть якщо для всіх вхідних рядків є пари\n"
"  --nocheck-order   не перевіряти, чи впорядковано вхідні дані\n"
"  --header          вважати перший рядок кожного файла заголовками полів,\n"
"                      вивести їх без спроб знайти для них пари\n"

#: src/join.c:227 src/shuf.c:83 src/sort.c:508 src/uniq.c:206
msgid "  -z, --zero-terminated     line delimiter is NUL, not newline\n"
msgstr ""
"  -z, --zero-terminated     завершувати рядки нульовим байтом, а не символом "
"нового рядка\n"

#: src/join.c:232
msgid ""
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n"
"line of each file determines the number of fields output for each line.\n"
"\n"
"Important: FILE1 and FILE2 must be sorted on the join fields.\n"
"E.g., use \"sort -k 1b,1\" if 'join' has no options,\n"
"or use \"join -t ''\" if 'sort' has no options.\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
"If the input is not sorted and some lines cannot be joined, a\n"
"warning message will be given.\n"
msgstr ""
"\n"
"Якщо не вказано -t ЗНАК, початкові знаки пробілів розділяють поля та\n"
"ігноруються, у іншому випадку поля розділюються ЗНАКОМ. ПОЛЕ — це\n"
"номер поля, що відраховується від 1. ФОРМАТ — це один або декілька\n"
"розділених комами або знаками пробілів описів формату:\n"
"«НОМЕР_ФАЙЛА.ПОЛЕ» або «0». Типово ФОРМАТ виводить спільне поле,\n"
"інші поля з ФАЙЛА1 та інші поля з ФАЙЛА2, розділені ЗНАКом.\n"
"Якщо ФОРМАТом є ключове слово «auto», перший рядок кожного з файлів\n"
"визначає кількість полів виведення для кожного рядка.\n"
"\n"
"Важливе: ФАЙЛ1 та ФАЙЛ2 має бути впорядковано за спільними полями.\n"
"Наприклад, скористайтеся командою « sort -k 1b,1 » якщо «join» вказано без\n"
"параметрів, або « join -t '' », якщо «sort» вказано без параметрів.\n"
"Зауважте, що під час порівняння буде використано правила, вказані за\n"
"допомогою змінної LC_COLLATE. Якщо вхідні дані не впорядковано і\n"
"якісь з рядків не може бути об'єднано, буде показано повідомлення\n"
"з попередженням про це.\n"

#: src/join.c:417
#, c-format
msgid "%s:%<PRIuMAX>: is not sorted: %.*s"
msgstr "%s:%<PRIuMAX>: не впорядковано: %.*s"

#: src/join.c:854 src/join.c:1052
#, c-format
msgid "invalid field number: %s"
msgstr "неправильний номер поля: %s"

#: src/join.c:875 src/join.c:884
#, c-format
msgid "invalid field specifier: %s"
msgstr "неправильна специфікація поля: %s"

#: src/join.c:891
#, c-format
msgid "invalid file number in field spec: %s"
msgstr "неправильний номер файла у специфікації поля: %s"

#: src/join.c:935
#, c-format
msgid "incompatible join fields %lu, %lu"
msgstr "поля об'єднання %lu, %lu несумісні"

#: src/join.c:1063
msgid "conflicting empty-field replacement strings"
msgstr "конфліктуючі рядки заміни для порожнього поля"

#: src/join.c:1115 src/sort.c:4529
#, c-format
msgid "multi-character tab %s"
msgstr "багатознакова табуляція %s"

#: src/join.c:1119 src/sort.c:4534
msgid "incompatible tabs"
msgstr "несумісна табуляція"

#: src/join.c:1192
msgid "both files cannot be standard input"
msgstr "замість обох файлів не можна вказувати одночасно стандартний ввід"

#: src/kill.c:77
#, c-format
msgid ""
"Usage: %s [-s SIGNAL | -SIGNAL] PID...\n"
"  or:  %s -l [SIGNAL]...\n"
"  or:  %s -t [SIGNAL]...\n"
msgstr ""
"Використання: %s [-s СИГНАЛ | -СИГНАЛ] PID...\n"
"      або:  %s -l [СИГНАЛ]...\n"
"      або:  %s -t [СИГНАЛ]...\n"

#: src/kill.c:83
msgid "Send signals to processes, or list signals.\n"
msgstr "Надсилає процесам сигнали або виводить сигнали.\n"

#: src/kill.c:89
msgid ""
"  -s, --signal=SIGNAL, -SIGNAL\n"
"                   specify the name or number of the signal to be sent\n"
"  -l, --list       list signal names, or convert signal names to/from "
"numbers\n"
"  -t, --table      print a table of signal information\n"
msgstr ""
"  -s, --signal=СИГНАЛ, -СИГНАЛ\n"
"              вказує назву або номер сигналу, що надсилається\n"
"  -l, --list  виводить назви сигналів або переводить назви у номери та "
"назад\n"
"  -t, --table виводить таблицю з інформацією про сигнали\n"

#: src/kill.c:97
msgid ""
"\n"
"SIGNAL may be a signal name like 'HUP', or a signal number like '1',\n"
"or the exit status of a process terminated by a signal.\n"
"PID is an integer; if negative it identifies a process group.\n"
msgstr ""
"\n"
"СИГНАЛ може бути назвою сигналу, як HUP, або номером сигналу, як\n"
"'1', або кодом завершення процесу, перерваного сигналом.\n"
"PID є цілим числом; якщо воно є від'ємним, то означає групу\n"
"процесів.\n"

#: src/kill.c:206
#, c-format
msgid "%s: invalid process id"
msgstr "%s: неправильний ідентифікатор процесу"

#: src/kill.c:260
#, c-format
msgid "invalid option -- %c"
msgstr "неправильний ключ -- '%c'"

#: src/kill.c:269
#, c-format
msgid "%s: multiple signals specified"
msgstr "%s: задано декілька сигналів"

#: src/kill.c:284
#, c-format
msgid "multiple -l or -t options specified"
msgstr "задано декілька ключів -l або -t"

#: src/kill.c:301
#, c-format
msgid "cannot combine signal with -l or -t"
msgstr "не можна об'єднувати сигнал з -l або -t"

#: src/kill.c:307
#, c-format
msgid "no process ID specified"
msgstr "не вказаний ідентифікатор процесу"

#: src/libstdbuf.c:112
#, c-format
msgid "failed to allocate a %<PRIuMAX> byte stdio buffer\n"
msgstr "не вдалося розмістити буфер stdio у %<PRIuMAX> байтів\n"

#: src/libstdbuf.c:119
#, c-format
msgid "invalid buffering mode %s for %s\n"
msgstr "некоректний режим буферизації %s для %s\n"

#: src/libstdbuf.c:127
#, c-format
msgid "could not set buffering of %s to mode %s\n"
msgstr "не вдалося змінити режим буферизації %s у значення %s\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/link.c:37 src/unlink.c:37 src/who.c:52
msgid "Michael Stone"
msgstr "Michael Stone"

#: src/link.c:46
#, c-format
msgid ""
"Usage: %s FILE1 FILE2\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s ФАЙЛ1 ФАЙЛ2\n"
"       або:    %s КЛЮЧ\n"

#: src/link.c:49
msgid ""
"Call the link function to create a link named FILE2 to an existing FILE1.\n"
"\n"
msgstr ""
"Викликає функцію link для створення посилання з назвою ФАЙЛ2 на існуючий "
"ФАЙЛ1.\n"
"\n"

#: src/link.c:91
#, c-format
msgid "cannot create link %s to %s"
msgstr "не вдалося створити посилання %s на %s"

#: src/ln.c:207
#, c-format
msgid "%s: hard link not allowed for directory"
msgstr "%s: не допускається створювати жорсткі посилання на каталоги"

#: src/ln.c:272
#, c-format
msgid "%s: cannot overwrite directory"
msgstr "%s: не вдалося перезаписати каталог"

#: src/ln.c:277
#, c-format
msgid "%s: replace %s? "
msgstr "%s: замінити %s? "

#: src/ln.c:349
#, c-format
msgid "failed to create symbolic link %s"
msgstr "не вдалося створити символічне посилання %s"

#: src/ln.c:350
#, c-format
msgid "failed to create symbolic link %s -> %s"
msgstr "не вдалося створити символічне посилання %s -> %s"

#: src/ln.c:352
#, c-format
msgid "failed to create hard link to %.0s%s"
msgstr "не вдалося створити жорстке посилання на %.0s%s"

#: src/ln.c:355
#, c-format
msgid "failed to create hard link %s"
msgstr "не вдалося створити жорстке посилання %s"

#: src/ln.c:356
#, c-format
msgid "failed to create hard link %s => %s"
msgstr "не вдалося створити жорстке посилання %s => %s"

#: src/ln.c:378
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] TARGET LINK_NAME   (1st form)\n"
"  or:  %s [OPTION]... TARGET                  (2nd form)\n"
"  or:  %s [OPTION]... TARGET... DIRECTORY     (3rd form)\n"
"  or:  %s [OPTION]... -t DIRECTORY TARGET...  (4th form)\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [-T] ПРИЗНАЧЕННЯ ПОСИЛАННЯ  (1-а форма)\n"
"         або  %s [КЛЮЧ]... ПРИЗНАЧЕННЯ                 (2-а форма)\n"
"         або  %s [КЛЮЧ]... ПРИЗНАЧЕННЯ... КАТАЛОГ      (3-я форма)\n"
"         або  %s [КЛЮЧ]... -t КАТАЛОГ ПРИЗНАЧЕННЯ...   (4-а форма)\n"

#: src/ln.c:385
msgid ""
"In the 1st form, create a link to TARGET with the name LINK_NAME.\n"
"In the 2nd form, create a link to TARGET in the current directory.\n"
"In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.\n"
"Create hard links by default, symbolic links with --symbolic.\n"
"By default, each destination (name of new link) should not already exist.\n"
"When creating hard links, each TARGET must exist.  Symbolic links\n"
"can hold arbitrary text; if later resolved, a relative link is\n"
"interpreted in relation to its parent directory.\n"
msgstr ""
"У першій формі створюється посилання на ПРИЗНАЧЕННЯ з назвою ПОСИЛАННЯ.\n"
"У другий формі створюється посилання на ПРИЗНАЧЕННЯ у поточному каталозі.\n"
"У третій та четвертій формах створюється посилання на кожне ПРИЗНАЧЕННЯ у\n"
"вказаному КАТАЛОЗІ. Типово створюються жорсткі посилання, а з ключем --"
"symbolic\n"
"— символічні. Типово, кожне призначення (назва нового посилання) не повинно\n"
"існувати. У разі створення жорстких посилань кожне ПРИЗНАЧЕННЯ має "
"існувати.\n"
"Символічні посилання можуть містити довільний текст. Під час пізнішого\n"
"визначення ПРИЗНАЧЕННЯ відносне посилання визначатиметься на основі\n"
"батьківського каталогу посилання.\n"

#: src/ln.c:398
msgid ""
"      --backup[=CONTROL]      make a backup of each existing destination "
"file\n"
"  -b                          like --backup but does not accept an argument\n"
"  -d, -F, --directory         allow the superuser to attempt to hard link\n"
"                                directories (note: will probably fail due "
"to\n"
"                                system restrictions, even for the "
"superuser)\n"
"  -f, --force                 remove existing destination files\n"
msgstr ""
"      --backup[=КОНТРОЛЬ]     робити резервну копію кожного цільового файла\n"
"  -b                          те ж, що й --backup, але не приймає аргумент\n"
"  -d, -F, --directory         дозволяє суперкористувачу створювати жорсткі\n"
"                              посилання на каталоги (примітка: ймовірно, це\n"
"                              не вийде через системні обмеження, навіть для\n"
"                              суперкористувача)\n"
"  -f, --force                 вилучати вже створені цільові файли\n"

#: src/ln.c:406
msgid ""
"  -i, --interactive           prompt whether to remove destinations\n"
"  -L, --logical               dereference TARGETs that are symbolic links\n"
"  -n, --no-dereference        treat LINK_NAME as a normal file if\n"
"                                it is a symbolic link to a directory\n"
"  -P, --physical              make hard links directly to symbolic links\n"
"  -r, --relative              create symbolic links relative to link "
"location\n"
"  -s, --symbolic              make symbolic links instead of hard links\n"
msgstr ""
"  -i, --interactive           запитувати, чи слід вилучати призначення\n"
"  -L, --logical               розіменувати призначення, які є символічними\n"
"                                посиланнями\n"
"  -n, --no-dereference        вважати посилання звичайним файлом, якщо воно\n"
"                                є символічним посиланням на каталог\n"
"  -P, --physical              створювати жорсткі посилання безпосередньо на\n"
"                                символічні посилання\n"
"  -r, --relative              створювати символічні посилання відносно "
"розташування\n"
"                                посилання\n"
"  -s, --symbolic              створювати символічні посилання, замість "
"жорстких\n"

#: src/ln.c:415
msgid ""
"  -S, --suffix=SUFFIX         override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  specify the DIRECTORY in which to "
"create\n"
"                                the links\n"
"  -T, --no-target-directory   treat LINK_NAME as a normal file always\n"
"  -v, --verbose               print name of each linked file\n"
msgstr ""
"  -S, --suffix=СУФІКС         вказує СУФІКС для резервних копій\n"
"  -t, --target-directory=КАТАЛОГ  вказує КАТАЛОГ, у якому створювати\n"
"                                 посилання\n"
"  -T, --no-target-directory   завжди вважати НАЗВУ_ПОСИЛАННЯ звичайним "
"файлом\n"
"  -v, --verbose               виводити назву кожного файла перед створенням "
"посилання\n"

#: src/ln.c:425
#, c-format
msgid ""
"\n"
"Using -s ignores -L and -P.  Otherwise, the last option specified controls\n"
"behavior when a TARGET is a symbolic link, defaulting to %s.\n"
msgstr ""
"\n"
"Використання -s призводить до ігнорування -L і -P. Інакше, останній "
"параметр\n"
"визначає роботу програми, якщо призначенням є символічне посилання.\n"
"Типове значення: %s.\n"

#: src/ln.c:541
msgid "cannot combine --target-directory and --no-target-directory"
msgstr ""
"не можна одночасно використовувати --target-directory і --no-target-directory"

#: src/ln.c:572
msgid "cannot do --relative without --symbolic"
msgstr "не можна виконувати --relative без --symbolic"

#. This is a proper name. See the gettext manual, section Names.
#: src/logname.c:31
msgid "FIXME: unknown"
msgstr "FIXME: невідомо"

#: src/logname.c:40
#, c-format
msgid "Usage: %s [OPTION]\n"
msgstr "Використання: %s [КЛЮЧ]\n"

#: src/logname.c:41
msgid ""
"Print the name of the current user.\n"
"\n"
msgstr ""
"Виводить ім'я поточного користувача.\n"
"\n"

#: src/logname.c:80
msgid "no login name"
msgstr "реєстраційне ім'я відсутнє"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:758
msgid "%b %e  %Y"
msgstr "%b %e  %Y"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:771
msgid "%b %e %H:%M"
msgstr "%b %e %H:%M"

#: src/ls.c:1718
#, c-format
msgid "ignoring invalid width in environment variable COLUMNS: %s"
msgstr "проігноровано неправильну довжину змінної середовища COLUMNS: %s"

#: src/ls.c:1746
#, c-format
msgid "ignoring invalid tab size in environment variable TABSIZE: %s"
msgstr ""
"проігноровано неправильний розмір табуляції змінної оточення TABSIZE: %s"

#: src/ls.c:1864
msgid "invalid line width"
msgstr "некоректна довжина рядка"

#: src/ls.c:1933
msgid "invalid tab size"
msgstr "некоректний розмір табуляції"

#: src/ls.c:2150
#, c-format
msgid "invalid time style format %s"
msgstr "неправильний формат часу %s"

#: src/ls.c:2174
msgid "Valid arguments are:\n"
msgstr "Коректні аргументи:\n"

#: src/ls.c:2178
msgid "  - +FORMAT (e.g., +%H:%M) for a 'date'-style format\n"
msgstr "  - +ФОРМАТ (наприклад +%H:%M) для формату у стилі 'date'\n"

#: src/ls.c:2553
#, c-format
msgid "unrecognized prefix: %s"
msgstr "не розпізнаний префікс: %s"

#: src/ls.c:2583
#, c-format
msgid "unparsable value for LS_COLORS environment variable"
msgstr "незрозуміле значення змінної оточення LS_COLORS"

#: src/ls.c:2613 src/stat.c:1027
#, c-format
msgid "ignoring invalid value of environment variable QUOTING_STYLE: %s"
msgstr "проігноровано неправильне значення змінної оточення QUOTING_STYLE: %s"

#: src/ls.c:2679 src/pwd.c:165
#, c-format
msgid "cannot open directory %s"
msgstr "не вдалося відкрити каталог %s"

#: src/ls.c:2694
#, c-format
msgid "cannot determine device and inode of %s"
msgstr "не вдалося визначити пристрій та inode для %s"

#: src/ls.c:2703
#, c-format
msgid "%s: not listing already-listed directory"
msgstr "%s: пропущено вже перелічений каталогу"

#: src/ls.c:2780 src/pwd.c:233
#, c-format
msgid "reading directory %s"
msgstr "читання каталогу %s"

#: src/ls.c:2795
#, c-format
msgid "closing directory %s"
msgstr "закриття каталогу %s"

#: src/ls.c:3500
#, c-format
msgid "cannot compare file names %s and %s"
msgstr "не вдалося порівняти назви файлів %s та %s"

#: src/ls.c:5009
msgid ""
"List information about the FILEs (the current directory by default).\n"
"Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n"
msgstr ""
"Виводить дані щодо ФАЙЛів (типово у поточному каталозі).\n"
"Впорядковує у алфавітному порядку, якщо не вказано ні --sort, ні один з\n"
"параметрів -cftuSUX.\n"

#: src/ls.c:5016
msgid ""
"  -a, --all                  do not ignore entries starting with .\n"
"  -A, --almost-all           do not list implied . and ..\n"
"      --author               with -l, print the author of each file\n"
"  -b, --escape               print C-style escapes for nongraphic "
"characters\n"
msgstr ""
"  -a, --all                  не ігнорувати записи, що починаються з .\n"
"  -A, --almost-all           не виводити неявні . і ..\n"
"      --author               разом з -l, виводити автора кожного файла\n"
"  -b, --escape               виводити вісімкові керівні послідовності\n"
"                             замість неграфічних знаків\n"

#: src/ls.c:5022
msgid ""
"      --block-size=SIZE      scale sizes by SIZE before printing them; e."
"g.,\n"
"                               '--block-size=M' prints sizes in units of\n"
"                               1,048,576 bytes; see SIZE format below\n"
"  -B, --ignore-backups       do not list implied entries ending with ~\n"
"  -c                         with -lt: sort by, and show, ctime (time of "
"last\n"
"                               modification of file status information);\n"
"                               with -l: show ctime and sort by name;\n"
"                               otherwise: sort by ctime, newest first\n"
msgstr ""
"      --block-size=РОЗМІР    використовувати блоки розміром РОЗМІР.\n"
"\n"
"                               Наприклад, «--block-size=M» виводить розміри "
"у\n"
"                               одиницях 1.048.576 байтів. Формат РОЗМІРу "
"наведено\n"
"                               нижче.\n"
"  -B, --ignore-backups       не виводити файли, що закінчуються на ~\n"
"  -c                         з -lt: сортувати за часом зміни; з -l:\n"
"                              виводити час зміни та впорядкувати за назвою,\n"
"                              у іншому випадку впорядкувати за часом зміни,\n"
"                              найновіші — перші\n"

#: src/ls.c:5032
msgid ""
"  -C                         list entries by columns\n"
"      --color[=WHEN]         colorize the output; WHEN can be "
"'always' (default\n"
"                               if omitted), 'auto', or 'never'; more info "
"below\n"
"  -d, --directory            list directories themselves, not their "
"contents\n"
"  -D, --dired                generate output designed for Emacs' dired mode\n"
msgstr ""
"  -C                         виводити список у декілька колонок\n"
"      --color[=КОЛИ]         вказує, чи позначати типи файлів кольором.\n"
"                               КОЛИ може бути «never», «auto» або\n"
"                               «always» (типовий, якщо не вказано)\n"
"  -d, --directory            виводити назви каталогів, а не їх зміст, а\n"
"                               також не слідувати за символічним посиланням\n"
"  -D, --dired                створити виведені дані у режимі Emacs dired\n"

#: src/ls.c:5041
msgid ""
"  -f                         do not sort, enable -aU, disable -ls --color\n"
"  -F, --classify             append indicator (one of */=>@|) to entries\n"
"      --file-type            likewise, except do not append '*'\n"
"      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
"                               single-column -1, verbose -l, vertical -C\n"
"      --full-time            like -l --time-style=full-iso\n"
msgstr ""
"  -f                         не сортувати, вмикає -aU, вимикає -lst\n"
"  -F, --classify             додавати до назви індикатор (один з */=>@|)\n"
"      --file-type            аналогічно, але не додавати '*'\n"
"      --format=СЛОВО         across -x, commas -m, horizontal -x, long -l,\n"
"                               single-column -1, verbose -l, vertical -C\n"
"      --full-time            виводити повну дату та час\n"

#: src/ls.c:5049
msgid "  -g                         like -l, but do not list owner\n"
msgstr "  -g                         як і -l, але не виводити власника\n"

#: src/ls.c:5052
msgid ""
"      --group-directories-first\n"
"                             group directories before files;\n"
"                               can be augmented with a --sort option, but "
"any\n"
"                               use of --sort=none (-U) disables grouping\n"
msgstr ""
"      --group-directories-first\n"
"                             показувати каталоги перед файлами.\n"
"                               розширюється за допомогою параметра --sort,\n"
"                               але використання --sort=none (-U) вимикає\n"
"                               групування\n"

#: src/ls.c:5058
msgid ""
"  -G, --no-group             in a long listing, don't print group names\n"
"  -h, --human-readable       with -l and/or -s, print human readable sizes\n"
"                               (e.g., 1K 234M 2G)\n"
"      --si                   likewise, but use powers of 1000 not 1024\n"
msgstr ""
"  -G, --no-group             у довгому списку, не виводити назви груп\n"
"  -h, --human-readable       з -l і/або -s виводити розміри у зручному для "
"людини вигляді\n"
"                               (наприклад, 1K 234M 2G)\n"
"  -H, --si                   те саме, але виводити ступені 1000, а не 1024\n"

#: src/ls.c:5064
msgid ""
"  -H, --dereference-command-line\n"
"                             follow symbolic links listed on the command "
"line\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             follow each command line symbolic link\n"
"                               that points to a directory\n"
"      --hide=PATTERN         do not list implied entries matching shell "
"PATTERN\n"
"                               (overridden by -a or -A)\n"
msgstr ""
"  -H, --dereference-command-line\n"
"                             слідувати за символьними посиланнями у "
"командному\n"
"                             рядку\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             слідувати за усіма символьними посиланнями у\n"
"                             командному рядку, які вказують на каталог\n"
"      --hide=ШАБЛОН          не виводити файли, що відповідають ШАБЛОНУ\n"
"                             оболонки (скасовується ключами -a або -A)\n"

#: src/ls.c:5074
msgid ""
"      --indicator-style=WORD  append indicator with style WORD to entry "
"names:\n"
"                               none (default), slash (-p),\n"
"                               file-type (--file-type), classify (-F)\n"
"  -i, --inode                print the index number of each file\n"
"  -I, --ignore=PATTERN       do not list implied entries matching shell "
"PATTERN\n"
"  -k, --kibibytes            default to 1024-byte blocks for disk usage\n"
msgstr ""
"      --indicator-style=СТИЛЬ додавати до назв елементів індикатор з\n"
"                               вказаним СТИЛЕМ: none (типово), slash (-p),\n"
"                               file-type (--file-type), classify (-F)\n"
"  -i, --inode                з -l, виводити номер i-вузла кожного файла\n"
"  -I, --ignore=ШАБЛОН        не виводити файли, що відповідають ШАБЛОНУ\n"
"  -k, --kibibytes            використовувати 1024-байтові блоки\n"

#: src/ls.c:5084
msgid ""
"  -l                         use a long listing format\n"
"  -L, --dereference          when showing file information for a symbolic\n"
"                               link, show information for the file the link\n"
"                               references rather than for the link itself\n"
"  -m                         fill width with a comma separated list of "
"entries\n"
msgstr ""
"  -l                         використовувати широкий формат\n"
"  -L, --dereference          показувати інформацію про символьні посилання,\n"
"                               виводити інформацію про файл, на який\n"
"                               посилається посилання\n"
"  -m                         виводити список на всю ширину через кому\n"

#: src/ls.c:5092
msgid ""
"  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
"  -N, --literal              print entry names without quoting\n"
"  -o                         like -l, but do not list group information\n"
"  -p, --indicator-style=slash\n"
"                             append / indicator to directories\n"
msgstr ""
"  -n, --numeric-uid-gid      як -l, але виводити числові UID та GID\n"
"  -N, --literal              виводити назви записів без лапок\n"
"  -o                         як -l, але не виводити інформацію про групу\n"
"  -p,  --indicator-style=slash  додавати індикатор / до каталогів\n"

#: src/ls.c:5099
msgid ""
"  -q, --hide-control-chars   print ? instead of nongraphic characters\n"
"      --show-control-chars   show nongraphic characters as-is (the default,\n"
"                               unless program is 'ls' and output is a "
"terminal)\n"
"  -Q, --quote-name           enclose entry names in double quotes\n"
"      --quoting-style=WORD   use quoting style WORD for entry names:\n"
"                               literal, locale, shell, shell-always,\n"
"                               shell-escape, shell-escape-always, c, escape\n"
msgstr ""
"  -q, --hide-control-chars   виводити ? замість не графічних символів\n"
"      --show-control-chars   виводити недруковані символи (типово\n"
"                              якщо програма не 'ls' та вивід йде не на\n"
"                              термінал).\n"
"  -Q, --quote-name           взяти назву файла у дужки\n"
"      --quoting-style=СЛОВО  використовувати вид оточення дужками СЛОВО:\n"
"                               literal, locale, shell, shell-always,\n"
"                               shell-escape, shell-escape-always, c, escape\n"

#: src/ls.c:5109
msgid ""
"  -r, --reverse              reverse order while sorting\n"
"  -R, --recursive            list subdirectories recursively\n"
"  -s, --size                 print the allocated size of each file, in "
"blocks\n"
msgstr ""
"  -r, --reverse              зворотний порядок сортування\n"
"  -R, --recursive            рекурсивно виводити каталоги\n"
"  -s, --size                 виводити розмір кожного файла, у блоках\n"

#: src/ls.c:5114
msgid ""
"  -S                         sort by file size, largest first\n"
"      --sort=WORD            sort by WORD instead of name: none (-U), size (-"
"S),\n"
"                               time (-t), version (-v), extension (-X)\n"
"      --time=WORD            with -l, show time as WORD instead of default\n"
"                               modification time: atime or access or use (-"
"u);\n"
"                               ctime or status (-c); also use specified "
"time\n"
"                               as sort key if --sort=time (newest first)\n"
msgstr ""
"  -S                         сортувати за розміром файла, найбільші "
"спочатку\n"
"      --sort=СЛОВО           режим упорядковування (замість «за назвою»):\n"
"                              none (-U), size (-S), time (-t),\n"
"                              version (-v), extension (-X)\n"
"      --time=СЛОВО           з -l, виводити замість часу зміни час,\n"
"                              вказаний СЛОВОМ: atime, access, use (-u), "
"ctime або\n"
"                              status (-c); якщо --sort=time, "
"використовувати\n"
"                              вказаний час як ключ сортування (найновіші "
"спочатку)\n"

#: src/ls.c:5125
msgid ""
"      --time-style=STYLE     with -l, show times using style STYLE:\n"
"                               full-iso, long-iso, iso, locale, or +FORMAT;\n"
"                               FORMAT is interpreted like in 'date'; if "
"FORMAT\n"
"                               is FORMAT1<newline>FORMAT2, then FORMAT1 "
"applies\n"
"                               to non-recent files and FORMAT2 to recent "
"files;\n"
"                               if STYLE is prefixed with 'posix-', STYLE\n"
"                               takes effect only outside the POSIX locale\n"
msgstr ""
"      --time-style=СТИЛЬ     з -l, виводити час використовуючи СТИЛЬ:\n"
"                             full-iso, long-iso, iso, locale, +ФОРМАТ.\n"
"                             ФОРМАТ інтерпретується як у 'date'; якщо\n"
"                             ФОРМАТ - це ФОРМАТ1<переведення-рядка>ФОРМАТ2,\n"
"                             ФОРМАТ1 застосовується до старих файлів, а\n"
"                             ФОРМАТ2 до нових; якщо до СТИЛЮ доданий "
"префікс\n"
"                             'posix-', то він діє лише не у POSIX локалі\n"

#: src/ls.c:5137
msgid ""
"  -t                         sort by modification time, newest first\n"
"  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n"
msgstr ""
"  -t                         впорядковувати за часом зміни, найновіші "
"спочатку\n"
"  -T, --tabsize=ЧИСЛО        крок табуляції дорівнює ЧИСЛУ замість 8\n"

#: src/ls.c:5141
msgid ""
"  -u                         with -lt: sort by, and show, access time;\n"
"                               with -l: show access time and sort by name;\n"
"                               otherwise: sort by access time, newest first\n"
"  -U                         do not sort; list entries in directory order\n"
"  -v                         natural sort of (version) numbers within text\n"
msgstr ""
"  -u                         з -lt: сортувати та виводити час доступу\n"
"                              з -l: виводити час доступу та впорядкувати\n"
"                              за назвою\n"
"                              інакше: впорядкувати за часом доступу, "
"найновіші спочатку\n"
"  -U                         не впорядковувати; виводити відповідно до\n"
"                              фізичного розташування\n"
"  -v                         впорядкувати за номерами (версією) у "
"текстовому\n"
"                              форматі\n"

#: src/ls.c:5148
msgid ""
"  -w, --width=COLS           set output width to COLS.  0 means no limit\n"
"  -x                         list entries by lines instead of by columns\n"
"  -X                         sort alphabetically by entry extension\n"
"  -Z, --context              print any security context of each file\n"
"  -1                         list one file per line.  Avoid '\\n' with -q or "
"-b\n"
msgstr ""
"  -w, --width=ЧИСЛО          задає ширину екрана. 0 — без обмежень\n"
"  -x                         вивід списку рядками, а не стовпчиками\n"
"  -X                         сортувати за розширенням у алфавітному порядку\n"
"  -Z, --context              виводити контекст безпеки для кожного файла\n"
"  -1                         виводити по одному файлу у рядку. Прибрати \\n\n"
"                             можна за допомогою -q або -b\n"

#: src/ls.c:5159
msgid ""
"\n"
"Using color to distinguish file types is disabled both by default and\n"
"with --color=never.  With --color=auto, ls emits color codes only when\n"
"standard output is connected to a terminal.  The LS_COLORS environment\n"
"variable can change the settings.  Use the dircolors command to set it.\n"
msgstr ""
"\n"
"Використання кольорів для позначення типів файлів вимкнено типово і за\n"
"допомогою --color=never. Якщо визначено --color=auto, ls видаватиме\n"
"коди кольорів, лише якщо стандартне виведення пов'язано з терміналом.\n"
"Змінити параметри можна за допомогою змінної середовища LS_COLORS.\n"
"Для встановлення цієї змінної скористайтеся командою dircolors.\n"

#: src/ls.c:5166
msgid ""
"\n"
"Exit status:\n"
" 0  if OK,\n"
" 1  if minor problems (e.g., cannot access subdirectory),\n"
" 2  if serious trouble (e.g., cannot access command-line argument).\n"
msgstr ""
"\n"
"Коди виходу:\n"
" 0  все добре,\n"
" 1  незначні проблеми (наприклад, не вдалося отримати доступ до "
"підкаталогу),\n"
" 2  значні проблеми (наприклад, не вдалося отримати доступ до аргументу "
"командного рядка).\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:108
msgid "Samuel Neves"
msgstr "Samuel Neves"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:111 src/seq.c:43
msgid "Ulrich Drepper"
msgstr "Ulrich Drepper"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:112
msgid "Scott Miller"
msgstr "Scott Miller"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:113
msgid "David Madore"
msgstr "David Madore"

#: src/md5sum.c:229
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"Print or check %s (%d-bit) checksums.\n"
msgstr ""
"Користування: %s [ПАРАМЕТР]... [ФАЙЛ]...\n"
"Вивести або перевірити %s (%d-бітові) контрольні суми.\n"

#: src/md5sum.c:239
msgid ""
"\n"
"  -b, --binary         read in binary mode (default unless reading tty "
"stdin)\n"
msgstr ""
"\n"
"  -b, --binary         читати у двійковому режимі (типово, якщо\n"
"                        читається не термінальне введення)\n"

#: src/md5sum.c:244
msgid ""
"\n"
"  -b, --binary         read in binary mode\n"
msgstr ""
"\n"
"  -b, --binary         читати у двійковому режимі\n"

#: src/md5sum.c:249
#, c-format
msgid "  -c, --check          read %s sums from the FILEs and check them\n"
msgstr "  -c, --check          читати суми %s з ФАЙЛІВ та порівняти їх\n"

#: src/md5sum.c:253
msgid ""
"  -l, --length         digest length in bits; must not exceed the maximum "
"for\n"
"                       the blake2 algorithm and must be a multiple of 8\n"
msgstr ""
"  -l, --length         довжина контрольної суми у бітах; має не перевищувати "
"максимуму\n"
"                       для алгоритму blake2 і бути кратною до 8\n"

#: src/md5sum.c:258
msgid "      --tag            create a BSD-style checksum\n"
msgstr "      --tag            створити контрольну суму у форматі BSD\n"

#: src/md5sum.c:262
msgid ""
"  -t, --text           read in text mode (default if reading tty stdin)\n"
msgstr ""
"  -t, --text           читати у текстовому режимі (типово, якщо\n"
"                          читається термінальний ввід)\n"

#: src/md5sum.c:266
msgid "  -t, --text           read in text mode (default)\n"
msgstr "  -t, --text           читати у текстовому режимі (типово)\n"

#: src/md5sum.c:269
msgid ""
"\n"
"The following five options are useful only when verifying checksums:\n"
"      --ignore-missing  don't fail or report status for missing files\n"
"      --quiet          don't print OK for each successfully verified file\n"
"      --status         don't output anything, status code shows success\n"
"      --strict         exit non-zero for improperly formatted checksum "
"lines\n"
"  -w, --warn           warn about improperly formatted checksum lines\n"
"\n"
msgstr ""
"\n"
"П’ять наведених нижче параметрів використовуються лише під час перевірки "
"контрольних сум:\n"
"      --ignore-missing  не завершувати роботу і не повідомляти про стан для "
"файлів, які\n"
"                         не виявлено\n"
"      --quiet          не виводити підтвердження для кожного успішно "
"перевіреного\n"
"                         файла\n"
"      --status         не виконувати вивід, код завершення показує\n"
"                         успіх перевірки\n"
"      --strict         виводити ненульовий код завершення для рядків "
"контрольних\n"
"                         сум з помилками у форматуванні\n"
"  -w, --warn           попереджувати про неправильно сформовані рядки у\n"
"                         списку контрольних сум\n"
"\n"

#: src/md5sum.c:281
#, c-format
msgid ""
"\n"
"The sums are computed as described in %s.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print a\n"
"line with checksum, a space, a character indicating input mode ('*' for "
"binary,\n"
"' ' for text or where binary is insignificant), and name for each FILE.\n"
msgstr ""
"\n"
"Метод обчислення контрольних сум описано у %s. Вхідними даними при\n"
"перевірці мають бути отримані раніше дані виводу цієї програми.\n"
"Типово виводить рядок з контрольною сумою, пробіл, символ, що вказує на\n"
"тип файла («*» для двійкових, « » для текстових або тих, де двійкові\n"
"дані є несуттєвими) та назву кожного ФАЙЛа.\n"

#: src/md5sum.c:689
#, c-format
msgid "%s: too many checksum lines"
msgstr "%s: надто багато рядків контрольних сум"

#: src/md5sum.c:713
#, c-format
msgid "%s: %<PRIuMAX>: improperly formatted %s checksum line"
msgstr "%s: %<PRIuMAX>: неправильно складений рядок контрольної суми %s"

#: src/md5sum.c:745
msgid "FAILED open or read"
msgstr "не вдалося відкрити або прочитати"

#: src/md5sum.c:783
msgid "FAILED"
msgstr "ПОМИЛКА"

#: src/md5sum.c:785
msgid "OK"
msgstr "Гаразд"

#: src/md5sum.c:809
#, c-format
msgid "%s: no properly formatted %s checksum lines found"
msgstr "%s: не знайдено правильно складених рядків контрольних сум %s"

#: src/md5sum.c:819
#, c-format
msgid "WARNING: %<PRIuMAX> line is improperly formatted"
msgid_plural "WARNING: %<PRIuMAX> lines are improperly formatted"
msgstr[0] "ПОПЕРЕДЖЕННЯ: %<PRIuMAX> рядок має помилкове форматування"
msgstr[1] "ПОПЕРЕДЖЕННЯ: %<PRIuMAX> рядки мають помилкове форматування"
msgstr[2] "ПОПЕРЕДЖЕННЯ: %<PRIuMAX> рядків мають помилкове форматування"

#: src/md5sum.c:827
#, c-format
msgid "WARNING: %<PRIuMAX> listed file could not be read"
msgid_plural "WARNING: %<PRIuMAX> listed files could not be read"
msgstr[0] "ПОПЕРЕДЖЕННЯ: не вдалося прочитати %<PRIuMAX> вказаний файл"
msgstr[1] "ПОПЕРЕДЖЕННЯ: не вдалося прочитати %<PRIuMAX> вказані файли"
msgstr[2] "ПОПЕРЕДЖЕННЯ: не вдалося прочитати %<PRIuMAX> вказаних файлів"

#: src/md5sum.c:835
#, c-format
msgid "WARNING: %<PRIuMAX> computed checksum did NOT match"
msgid_plural "WARNING: %<PRIuMAX> computed checksums did NOT match"
msgstr[0] "ПОПЕРЕДЖЕННЯ: НЕ збіглась %<PRIuMAX> обчислена контрольна сума"
msgstr[1] "ПОПЕРЕДЖЕННЯ: НЕ збіглись %<PRIuMAX> обчислені контрольні суми"
msgstr[2] "ПОПЕРЕДЖЕННЯ: НЕ збіглись %<PRIuMAX> обчислених контрольних сум"

#: src/md5sum.c:841
#, c-format
msgid "%s: no file was verified"
msgstr "%s: не перевірено жодного файла"

#: src/md5sum.c:891
msgid "invalid length"
msgstr "некоректна довжина"

#: src/md5sum.c:895 src/md5sum.c:944
#, c-format
msgid "invalid length: %s"
msgstr "некоректна довжина: %s"

#: src/md5sum.c:896
msgid "length is not a multiple of 8"
msgstr "довжина не є кратною до 8"

#: src/md5sum.c:946
#, c-format
msgid "maximum digest length for %s is %<PRIuMAX> bits"
msgstr "максимальною довжиною контрольної суми для %s є %<PRIuMAX> бітів"

#: src/md5sum.c:964
#, c-format
msgid "--tag does not support --text mode"
msgstr "підтримки --tag у режимі --text не передбачено"

#: src/md5sum.c:970
#, c-format
msgid "the --tag option is meaningless when verifying checksums"
msgstr "ключ --tag не має сенсу під час перевірки контрольних сум"

#: src/md5sum.c:977
#, c-format
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr "ключі --binary та --text не мають сенсу при перевірці контрольних сум"

#: src/md5sum.c:985
#, c-format
msgid "the --ignore-missing option is meaningful only when verifying checksums"
msgstr "параметр --ignore-missing має сенс лише при перевірці контрольних сум"

#: src/md5sum.c:993
#, c-format
msgid "the --status option is meaningful only when verifying checksums"
msgstr "ключ --status має сенс лише при перевірці контрольних сум"

#: src/md5sum.c:1000
#, c-format
msgid "the --warn option is meaningful only when verifying checksums"
msgstr "ключ --warn має сенс лише при перевірці контрольних сум"

#: src/md5sum.c:1007
#, c-format
msgid "the --quiet option is meaningful only when verifying checksums"
msgstr "ключ --quiet має сенс лише при перевірці контрольних сум"

#: src/md5sum.c:1014
#, c-format
msgid "the --strict option is meaningful only when verifying checksums"
msgstr "ключ --strict має сенс лише при перевірці контрольних сум"

#: src/mkdir.c:59 src/rmdir.c:163
#, c-format
msgid "Usage: %s [OPTION]... DIRECTORY...\n"
msgstr "Використання: %s [КЛЮЧ]... КАТАЛОГ...\n"

#: src/mkdir.c:60
msgid "Create the DIRECTORY(ies), if they do not already exist.\n"
msgstr "Створює DIRECTORY, якщо він ще не існує.\n"

#: src/mkdir.c:66
msgid ""
"  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask\n"
"  -p, --parents     no error if existing, make parent directories as needed\n"
"  -v, --verbose     print a message for each created directory\n"
msgstr ""
"  -m, --mode=MODE   встановити код доступу (як у chmod)\n"
"  -p, --parents     не виводити помилок якщо каталог існує,\n"
"                     при потребі створювати батьківські каталоги\n"
"  -v, --verbose     виводити повідомлення про кожен створений каталог\n"

#: src/mkdir.c:71
msgid ""
"  -Z                   set SELinux security context of each created "
"directory\n"
"                         to the default type\n"
"      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n"
"                         or SMACK security context to CTX\n"
msgstr ""
"  -Z                   встановити типовий тип контексту безпеки SELinux для "
"усіх\n"
"                         створених каталогів\n"
"      --context[=CTX]  подібний до -Z, якщо вказано CTX, встановити контекст "
"безпеки\n"
"                         SELinux або SMACK відповідно до вказаного значення\n"
"                         контексту CTX\n"

#: src/mkdir.c:221
#, c-format
msgid "created directory %s"
msgstr "створений каталог %s"

#: src/mkdir.c:239 src/mkfifo.c:117 src/mknod.c:134
#, c-format
msgid ""
"warning: ignoring --context; it requires an SELinux/SMACK-enabled kernel"
msgstr ""
"попередження: ігноруємо --context; для його використання потрібне ядро з "
"підтримкою SELinux або SMACK"

#: src/mkfifo.c:54 src/pathchk.c:88
#, c-format
msgid "Usage: %s [OPTION]... NAME...\n"
msgstr "Використання: %s [КЛЮЧ]... НАЗВА...\n"

#: src/mkfifo.c:55
msgid "Create named pipes (FIFOs) with the given NAMEs.\n"
msgstr "Створює іменовані канали (FIFO) для вказаного NAME.\n"

#: src/mkfifo.c:61 src/mknod.c:63
msgid ""
"  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\n"
msgstr ""
"  -m, --mode=РЕЖИМ   встановити права доступу у РЕЖИМ, а не  a=rw - umask\n"

#: src/mkfifo.c:64 src/mknod.c:66
msgid ""
"  -Z                   set the SELinux security context to default type\n"
"      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n"
"                         or SMACK security context to CTX\n"
msgstr ""
"  -Z                   встановити типовий тип контексту безпеки SELinux\n"
"      --context[=CTX]  подібний до -Z, якщо вказано CTX, встановити контекст "
"безпеки\n"
"                         SELinux або SMACK відповідно до вказаного значення\n"
"                         контексту CTX\n"

#: src/mkfifo.c:154 src/mknod.c:151
msgid "invalid mode"
msgstr "неправильний режим"

#: src/mkfifo.c:161 src/mknod.c:158
msgid "mode must specify only file permission bits"
msgstr "режим повинен визначати лише біти прав доступу до файла"

#: src/mkfifo.c:175 src/mknod.c:271
#, c-format
msgid "cannot set permissions of %s"
msgstr "не вдалося встановити права доступу до %s"

#: src/mknod.c:55
#, c-format
msgid "Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\n"
msgstr "Використання: %s [КЛЮЧ]... НАЗВА ТИП [ОСНОВНИЙ ДРУГОРЯДНИЙ]\n"

#: src/mknod.c:57
msgid "Create the special file NAME of the given TYPE.\n"
msgstr "Створює спеціальній файл з назвою NAME та типом TYPE.\n"

#: src/mknod.c:73
msgid ""
"\n"
"Both MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\n"
"must be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\n"
"it is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\n"
"otherwise, as decimal.  TYPE may be:\n"
msgstr ""
"\n"
"Якщо ТИП -- це b, c або u, необхідно вказувати як ОСНОВНИЙ, так і\n"
"ДРУГОРЯДНИЙ, а якщо ТИП дорівнює p, їх не можна вказувати.  Якщо ОСНОВНИЙ\n"
"або ДРУГОРЯДНИЙ починаються з 0x або 0X, вони інтерпретуються як\n"
"шістнадцяткові числа; якщо починаються з 0 - як вісімкові;\n"
"інакше як десяткові.  ТИП може приймати наступні значення:\n"

#: src/mknod.c:80
msgid ""
"\n"
"  b      create a block (buffered) special file\n"
"  c, u   create a character (unbuffered) special file\n"
"  p      create a FIFO\n"
msgstr ""
"\n"
"  b      створити файл блокового пристрою (буферизований)\n"
"  c, u   створити файл символьного пристрою (не буферизований)\n"
"  p      створити іменований канал\n"

#: src/mknod.c:176
msgid "Special files require major and minor device numbers."
msgstr ""
"Для спеціального файла повинні бути вказані основний та другорядний номери "
"пристрою."

#: src/mknod.c:186
msgid "Fifos do not have major and minor device numbers."
msgstr "У файлів-черг немає основного та другорядного числа пристрою."

#: src/mknod.c:211
msgid "block special files not supported"
msgstr "блокові спеціальні файли не підтримуються"

#: src/mknod.c:220
msgid "character special files not supported"
msgstr "знакові спеціальні файли не підтримуються"

#: src/mknod.c:236
#, c-format
msgid "invalid major device number %s"
msgstr "неправильне основне число пристрою %s"

#: src/mknod.c:241
#, c-format
msgid "invalid minor device number %s"
msgstr "неправильне другорядне число пристрою %s"

#: src/mknod.c:246
#, c-format
msgid "invalid device %s %s"
msgstr "неправильний пристрій %s %s"

#: src/mknod.c:266
#, c-format
msgid "invalid device type %s"
msgstr "неправильний тип пристрою %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/mktemp.c:37
msgid "Eric Blake"
msgstr "Eric Blake"

#: src/mktemp.c:67
#, c-format
msgid "Usage: %s [OPTION]... [TEMPLATE]\n"
msgstr "Використання: %s [КЛЮЧ]... [ШАБЛОН]\n"

#: src/mktemp.c:68
msgid ""
"Create a temporary file or directory, safely, and print its name.\n"
"TEMPLATE must contain at least 3 consecutive 'X's in last component.\n"
"If TEMPLATE is not specified, use tmp.XXXXXXXXXX, and --tmpdir is implied.\n"
msgstr ""
"Створити у безпечний спосіб файл або каталог і вивести їхню назву.\n"
"ШАБЛОН має складатися принаймні з трьох «X» поспіль у останньому\n"
"компоненті. Якщо ШАБЛОН не вказано, використовується tmp.XXXXXXXXXX і\n"
"додається параметр --tmpdir.\n"

#: src/mktemp.c:73
msgid ""
"Files are created u+rw, and directories u+rwx, minus umask restrictions.\n"
msgstr ""
"Файли буде створено з правами u+rw, каталоги — u+rwx, мінус обмеження "
"umask.\n"

#: src/mktemp.c:77
msgid ""
"  -d, --directory     create a directory, not a file\n"
"  -u, --dry-run       do not create anything; merely print a name (unsafe)\n"
"  -q, --quiet         suppress diagnostics about file/dir-creation failure\n"
msgstr ""
"  -d, --directory     створити каталог, а не файл\n"
"  -u, --dry-run       не створювати нічого; лише вивести назву (не є "
"безпечним)\n"
"  -q, --quiet         вимкнути діагностику щодо помилок створення файлів і "
"каталогів\n"

#: src/mktemp.c:82
msgid ""
"      --suffix=SUFF   append SUFF to TEMPLATE; SUFF must not contain a "
"slash.\n"
"                        This option is implied if TEMPLATE does not end in "
"X\n"
msgstr ""
"      --suffix=СУФФ   додавати СУФФ до ШАБЛОНу. СУФФ не повинен містити "
"символів\n"
"                      похилої риски.\n"
"                        Цей параметр буде використано, якщо ШАБЛОН не "
"завершується на X.\n"

#: src/mktemp.c:86
msgid ""
"  -p DIR, --tmpdir[=DIR]  interpret TEMPLATE relative to DIR; if DIR is not\n"
"                        specified, use $TMPDIR if set, else /tmp.  With\n"
"                        this option, TEMPLATE must not be an absolute name;\n"
"                        unlike with -t, TEMPLATE may contain slashes, but\n"
"                        mktemp creates only the final component\n"
msgstr ""
"  -p КАТ, --tmpdir[=КАТ] інтерпретувати ШАБЛОН відносно каталогу КАТ. Якщо "
"КАТ не\n"
"                     вказано, використовується $TMPDIR, якщо значення не\n"
"                     задане, використовується /tmp., ШАБЛОН не повинен бути\n"
"                     абсолютною назвою. На відміну від -t, ШАБЛОН може\n"
"                     містити похилі риски, але mktemp створюватиме лише\n"
"                     останній компонент таких записів.\n"

#: src/mktemp.c:93
msgid ""
"  -t                  interpret TEMPLATE as a single file name component,\n"
"                        relative to a directory: $TMPDIR, if set; else the\n"
"                        directory specified via -p; else /tmp [deprecated]\n"
msgstr ""
"  -t                  вважати ШАБЛОН одиночним компонентом назви файла,\n"
"                        відносно каталогу: $TMPDIR, якщо встановлено; у "
"іншому\n"
"                        разі каталог вказується у -p; інакше /tmp "
"[застаріло]\n"

#: src/mktemp.c:211
#, c-format
msgid "too many templates"
msgstr "надто багато шаблонів"

#: src/mktemp.c:231
#, c-format
msgid "with --suffix, template %s must end in X"
msgstr "у разі визначення --suffix, шаблон %s має завершувати на X"

#: src/mktemp.c:256 src/split.c:1333
#, c-format
msgid "invalid suffix %s, contains directory separator"
msgstr "некоректний шаблон, %s, містить символ розділення каталогів"

#: src/mktemp.c:261
#, c-format
msgid "too few X's in template %s"
msgstr "надто мало символів X у шаблоні %s"

#: src/mktemp.c:277
#, c-format
msgid "invalid template, %s, contains directory separator"
msgstr "неправильний шаблон, %s, містить символ розділення каталогів"

#: src/mktemp.c:291
#, c-format
msgid "invalid template, %s; with --tmpdir, it may not be absolute"
msgstr "неправильний шаблон, %s; з --tmpdir, він не може бути абсолютним"

#: src/mktemp.c:312
#, c-format
msgid "failed to create directory via template %s"
msgstr "не вдалося створити каталог через шаблон %s"

#: src/mktemp.c:323
#, c-format
msgid "failed to create file via template %s"
msgstr "не вдалося створити файл через шаблон %s"

#: src/mv.c:295
msgid "Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n"
msgstr ""
"Перейменовує ДЖЕРЕЛО у ПРИЗНАЧЕННЯ, або переміщує ДЖЕРЕЛА до КАТАЛОГУ.\n"

#: src/mv.c:301
msgid ""
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"  -f, --force                  do not prompt before overwriting\n"
"  -i, --interactive            prompt before overwrite\n"
"  -n, --no-clobber             do not overwrite an existing file\n"
"If you specify more than one of -i, -f, -n, only the final one takes "
"effect.\n"
msgstr ""
"      --backup[=КОНТРОЛЬ]      створювати резервні копії цільових файлів\n"
"  -b                           те саме, що та --backup, але без аргументу\n"
"  -f, --force                  переписувати існуючі файли без підтвердження\n"
"  -i, --interactive            запитувати підтвердження, перш ніж\n"
"                                 переписувати\n"
"  -n, --no-clobber             не переписувати вже створені файли\n"
"Якщо буде вказано декілька -i, -f, -n, братиметься до уваги лише останній\n"
"параметр.\n"

#: src/mv.c:310
msgid ""
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
msgstr ""
"      --strip-trailing-slashes вилучає всі кінцеві косі риски з кожного\n"
"                               аргументу ДЖЕРЕЛО\n"
"  -S, --suffix=СУФІКС          перевизначає суфікс для резервних копій\n"

#: src/mv.c:315
msgid ""
"  -t, --target-directory=DIRECTORY  move all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
"  -u, --update                 move only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -Z, --context                set SELinux security context of destination\n"
"                                 file to default type\n"
msgstr ""
"  -t, --target-directory=КАТАЛОГ перемістити всі ДЖЕРЕЛА у КАТАЛОГ\n"
"  -T, --no-target-directory    вважати ЦІЛЬ звичайним файлом\n"
"  -u, --update                 переміщувати лише тоді коли файл ДЖЕРЕЛО\n"
"                                 новіший ніж цільовий файл, або коли\n"
"                                 цільовий файл відсутній\n"
"  -v, --verbose                пояснювати виконувані дії\n"
"  -Z, --context                встановити типовий тип контексту захисту "
"SELinux\n"
"                                 для призначення\n"

#: src/nice.c:73
#, c-format
msgid "Usage: %s [OPTION] [COMMAND [ARG]...]\n"
msgstr "Використання: %s [КЛЮЧ] [КОМАНДА [АРГ]...]\n"

#: src/nice.c:74
#, c-format
msgid ""
"Run COMMAND with an adjusted niceness, which affects process scheduling.\n"
"With no COMMAND, print the current niceness.  Niceness values range from\n"
"%d (most favorable to the process) to %d (least favorable to the process).\n"
msgstr ""
"Запускає КОМАНДУ зі зміненим значенням поступливості, що впливає на "
"пріоритет\n"
"для планувальника.  Якщо КОМАНДУ не вказано, виводиться поточне значення\n"
"поступливості. Допустимі межі: від %d (найбільший пріоритет) до %d\n"
"(найменший).\n"

#: src/nice.c:83
msgid "  -n, --adjustment=N   add integer N to the niceness (default 10)\n"
msgstr ""
"  -n, --adjustment=N   збільшити поступливість на ціле число N (типово 10)\n"

#: src/nice.c:173
#, c-format
msgid "invalid adjustment %s"
msgstr "неправильна поправка %s"

#: src/nice.c:182
#, c-format
msgid "a command must be given with an adjustment"
msgstr "якщо вказана поправка, треба вказати команду"

#: src/nice.c:189 src/nice.c:200
msgid "cannot get niceness"
msgstr "не вдалося дізнатись поступливість"

#: src/nice.c:206
#, c-format
msgid "cannot set niceness"
msgstr "не вдалося встановити значення поступливості"

#. This is a proper name. See the gettext manual, section Names.
#: src/nl.c:41
msgid "Scott Bartram"
msgstr "Scott Bartram"

#: src/nl.c:180
msgid "Write each FILE to standard output, with line numbers added.\n"
msgstr ""
"Вивести кожне ФАЙЛ до стандартного виведення із додаванням номерів рядків.\n"

#: src/nl.c:187
msgid ""
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for logical page delimiters\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
msgstr ""
"  -b, --body-numbering=СТИЛЬ      використовувати СТИЛЬ нумерації рядків "
"тіла\n"
"  -d, --section-delimiter=СС      використовувати СС для розділення\n"
"                                  логічних сторінок\n"
"  -f, --footer-numbering=СТИЛЬ    використовувати СТИЛЬ нумерації рядків\n"
"                                  нижнього колонтитулу\n"

#: src/nl.c:192
msgid ""
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --line-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers for each "
"section\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
msgstr ""
"  -h, --header-numbering=СТИЛЬ    використовувати СТИЛЬ нумерації рядків\n"
"                                  верхнього колонтитула\n"
"  -i, --page-increment=ЧИСЛО      крок збільшення номерів рядків\n"
"  -l, --join-blank-lines=ЧИСЛО    вказане ЧИСЛО порожніх рядків вважати\n"
"                                  одним\n"
"  -n, --number-format=ФОРМАТ      використовувати ФОРМАТ для номерів рядків\n"
"  -p, --no-renumber               не починати нумерацію з початку після\n"
"                                  кожного розділу\n"
"  -s, --number-separator=РЯДОК    додавати РЯДОК після номера\n"

#: src/nl.c:200
msgid ""
"  -v, --starting-line-number=NUMBER  first line number for each section\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
msgstr ""
"  -v, --starting-line-number=ЧИСЛО перший номер рядка для кожного розділу\n"
"  -w, --number-width=ЧИСЛО        використовувати вказане ЧИСЛО стовпчиків\n"
"                                  для номерів рядків\n"

#: src/nl.c:206
msgid ""
"\n"
"By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.\n"
"CC are two delimiter characters used to construct logical page delimiters,\n"
"a missing second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
msgstr ""
"\n"
"Типово використовуються -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.\n"
"СС - це два знаки, які використовуються для відокремлення логічних "
"сторінок,\n"
"якщо вказаний лише один, використовується :.  Вводьте \\\\, щоб отримати "
"\\.\n"
"СТИЛЬ одне з таких значень:\n"

#: src/nl.c:212
msgid ""
"\n"
"  a         number all lines\n"
"  t         number only nonempty lines\n"
"  n         number no lines\n"
"  pBRE      number only lines that contain a match for the basic regular\n"
"            expression, BRE\n"
"\n"
"FORMAT is one of:\n"
"\n"
"  ln   left justified, no leading zeros\n"
"  rn   right justified, no leading zeros\n"
"  rz   right justified, leading zeros\n"
"\n"
msgstr ""
"\n"
"  a         нумерувати всі рядки\n"
"  t         нумерувати лише не порожні рядки\n"
"  n         не нумерувати рядки\n"
"  pБРВ      нумерувати лише рядки, частина яких збігається з базовим\n"
"            регулярним виразом БРВ\n"
"\n"
"ФОРМАТ вказується як один з наступних:\n"
"\n"
"  ln   вирівнювати по лівому краю, не виводити початкові нулі\n"
"  rn   вирівнювати по правому краю, не виводити початкові нулі\n"
"  rz   вирівнювати по правому краю, виводити початкові нулі\n"
"\n"

#: src/nl.c:279
msgid "line number overflow"
msgstr "переповнення номера рядка"

#: src/nl.c:483
#, c-format
msgid "invalid header numbering style: %s"
msgstr "неправильний стиль нумерації заголовка: %s"

#: src/nl.c:491
#, c-format
msgid "invalid body numbering style: %s"
msgstr "неправильний стиль нумерації тіла: %s"

#: src/nl.c:499
#, c-format
msgid "invalid footer numbering style: %s"
msgstr "неправильний стиль нумерації нижнього колонтитула: %s"

#: src/nl.c:506
msgid "invalid starting line number"
msgstr "неправильний номер початкового рядка"

#: src/nl.c:511
msgid "invalid line number increment"
msgstr "неправильний приріст номера рядка"

#: src/nl.c:518
msgid "invalid line number of blank lines"
msgstr "неправильна кількість порожніх рядків"

#: src/nl.c:525
msgid "invalid line number field width"
msgstr "неправильна ширина поля для номера рядка"

#: src/nl.c:536
#, c-format
msgid "invalid line numbering format: %s"
msgstr "неправильний формат нумерації рядків: %s"

#: src/nohup.c:52
#, c-format
msgid ""
"Usage: %s COMMAND [ARG]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s КОМАНДА [АРГУМЕНТ]...\n"
"       або:    %s КЛЮЧ\n"

#: src/nohup.c:58
msgid ""
"Run COMMAND, ignoring hangup signals.\n"
"\n"
msgstr ""
"Виконує КОМАНДУ ігноруючи сигнали обриву термінальної лінії.\n"
"\n"

#: src/nohup.c:64
#, c-format
msgid ""
"\n"
"If standard input is a terminal, redirect it from an unreadable file.\n"
"If standard output is a terminal, append output to 'nohup.out' if possible,\n"
"'$HOME/nohup.out' otherwise.\n"
"If standard error is a terminal, redirect it to standard output.\n"
"To save output to FILE, use '%s COMMAND > FILE'.\n"
msgstr ""
"\n"
"Якщо стандартне введення відбувається з термінала, перенаправте його з "
"непридатного до читання файла.\n"
"Якщо стандартний вивід відбувається до термінала, якщо можливо, допишіть\n"
"виведене до 'ohup.out' або '$HOME/nohup.out', якщо першим варіантом не можна "
"скористатися.\n"
"Якщо стандартний потік помилок виводиться на екран, перенаправте його до\n"
"стандартного потоку виведення. Щоб зберегти виведене до ФАЙЛа, скористайтеся "
"командою «%s КОМАНДА > ФАЙЛ».\n"

#: src/nohup.c:126
#, c-format
msgid "failed to render standard input unusable"
msgstr ""
"не вдалося обробити, не вдалося використати стандартне джерело введення"

#: src/nohup.c:128
#, c-format
msgid "ignoring input"
msgstr "всі аргументи проігноровані"

#: src/nohup.c:172
#, c-format
msgid "ignoring input and appending output to %s"
msgstr "вивід додається у %s"

#: src/nohup.c:173
#, c-format
msgid "appending output to %s"
msgstr "виведення додається до %s"

#: src/nohup.c:190
#, c-format
msgid "failed to set the copy of stderr to close on exec"
msgstr ""
"не вдалося зробити так, щоб копія стандартного потоку помилок закрилась на "
"початку виконання"

#: src/nohup.c:195
#, c-format
msgid "ignoring input and redirecting stderr to stdout"
msgstr "ігнорується ввід та перенаправлення stderr на stdout"

#: src/nohup.c:196
#, c-format
msgid "redirecting stderr to stdout"
msgstr "переспрямування stderr до stdout"

#: src/nohup.c:200
#, c-format
msgid "failed to redirect standard error"
msgstr "не вдалося перенаправити стандартний потік помилок"

#. This is a proper name. See the gettext manual, section Names.
#: src/nproc.c:33 src/sync.c:34
msgid "Giuseppe Scrivano"
msgstr "Giuseppe Scrivano"

#: src/nproc.c:57 src/pwd.c:57 src/tty.c:64 src/uname.c:121 src/whoami.c:45
#, c-format
msgid "Usage: %s [OPTION]...\n"
msgstr "Використання: %s [КЛЮЧ]...\n"

#: src/nproc.c:58
msgid ""
"Print the number of processing units available to the current process,\n"
"which may be less than the number of online processors\n"
"\n"
msgstr ""
"Виводить кількість модулів обробки, доступних поточному процесу,\n"
"може бути меншим за кількість процесорів, які працюватимуть.\n"
"\n"

#: src/nproc.c:63
msgid ""
"     --all       print the number of installed processors\n"
"     --ignore=N  if possible, exclude N processing units\n"
msgstr ""
"     --all       вивести кількість встановлених процесорів\n"
"     --ignore=N  якщо можна, виключити N модулів обробки\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/numfmt.c:43
msgid "Assaf Gordon"
msgstr "Assaf Gordon"

#: src/numfmt.c:694
#, c-format
msgid "value too large to be converted: %s"
msgstr "значення є надто великим для перетворення: %s"

#: src/numfmt.c:698
#, c-format
msgid "invalid number: %s"
msgstr "некоректне число: %s"

#: src/numfmt.c:702
#, c-format
msgid "rejecting suffix in input: %s (consider using --from)"
msgstr ""
"відкидаємо суфікс %s у вхідних даних (варто використовувати --from для його "
"збереження)"

#: src/numfmt.c:706
#, c-format
msgid "invalid suffix in input: %s"
msgstr "некоректний суфікс у вхідних даних: %s"

#: src/numfmt.c:710
#, c-format
msgid "missing 'i' suffix in input: %s (e.g Ki/Mi/Gi)"
msgstr "у вхідних даних не вистачає суфікса «i»: %s (наприклад Ki/Mi/Gi)"

#: src/numfmt.c:757 src/numfmt.c:809
#, c-format
msgid "failed to prepare value '%Lf' for printing"
msgstr "не вдалося приготувати значення «%Lf» для виводу"

#: src/numfmt.c:858
#, c-format
msgid "invalid unit size: %s"
msgstr "некоректна одиниця розміру: %s"

#: src/numfmt.c:884
#, c-format
msgid "Usage: %s [OPTION]... [NUMBER]...\n"
msgstr "Користування: %s [ПАРАМЕТР]... [ЧИСЛО]...\n"

#: src/numfmt.c:887
msgid ""
"Reformat NUMBER(s), or the numbers from standard input if none are "
"specified.\n"
msgstr ""
"Виконати переформатування числа ЧИСЛО або чисел зі стандартного джерела "
"даних, якщо ЧИСЛО не вказано.\n"

#: src/numfmt.c:891
msgid "      --debug          print warnings about invalid input\n"
msgstr ""
"      --debug          виводити попередження щодо некоректних вхідних даних\n"

#: src/numfmt.c:894
msgid ""
"  -d, --delimiter=X    use X instead of whitespace for field delimiter\n"
msgstr ""
"  -d, --delimiter=X    використовувати X замість пробілу для відокремлення "
"полів\n"

#: src/numfmt.c:897
msgid ""
"      --field=FIELDS   replace the numbers in these input fields "
"(default=1)\n"
"                         see FIELDS below\n"
msgstr ""
"      --field=ПОЛЯ     замінити номери у вказаних полях вхідних даних "
"(типово=1)\n"
"                         див. ПОЛЯ нижче\n"

#: src/numfmt.c:901
msgid ""
"      --format=FORMAT  use printf style floating-point FORMAT;\n"
"                         see FORMAT below for details\n"
msgstr ""
"      --format=ФОРМАТ  використовувати форматування у стилі printf;\n"
"                         див. докладний опис форматів нижче\n"

#: src/numfmt.c:905
msgid ""
"      --from=UNIT      auto-scale input numbers to UNITs; default is "
"'none';\n"
"                         see UNIT below\n"
msgstr ""
"      --from=ОДИНИЦЯ   автоматично масштабувати вхідні числа за ОДИНИЦЕЮ; "
"типове значення -- 'none';\n"
"                         див. опис одиниць нижче\n"

#: src/numfmt.c:909
msgid ""
"      --from-unit=N    specify the input unit size (instead of the default "
"1)\n"
msgstr ""
"      --from-unit=N    вказати розмірність одиниці у вхідних даних (замість "
"типової 1)\n"

#: src/numfmt.c:912
msgid ""
"      --grouping       use locale-defined grouping of digits, e.g. "
"1,000,000\n"
"                         (which means it has no effect in the C/POSIX "
"locale)\n"
msgstr ""
"      --grouping       групувати цифри відповідно до правил локалі, "
"наприклад 1.000.000\n"
"                         (не працюватиме у локалі C/POSIX)\n"

#: src/numfmt.c:916
msgid ""
"      --header[=N]     print (without converting) the first N header lines;\n"
"                         N defaults to 1 if not specified\n"
msgstr ""
"      --header[=N]     вивести (без перетворення) перші N рядків заголовка;\n"
"                         якщо не вказано, типовим значенням є 1\n"

#: src/numfmt.c:920
msgid ""
"      --invalid=MODE   failure mode for invalid numbers: MODE can be:\n"
"                         abort (default), fail, warn, ignore\n"
msgstr ""
"      --invalid=РЕЖИМ режим обробки некоректних символів. Можливі режими:\n"
"                  abort (перервати обробку, типовий), fail (обробити з "
"помилками),\n"
"                  warn (попередити), ignore (ігнорувати).\n"

#: src/numfmt.c:924
msgid ""
"      --padding=N      pad the output to N characters; positive N will\n"
"                         right-align; negative N will left-align;\n"
"                         padding is ignored if the output is wider than N;\n"
"                         the default is to automatically pad if a "
"whitespace\n"
"                         is found\n"
msgstr ""
"      --padding=N     доповнити виведені дані до N символів.\n"
"                      Використання додатного N призведе до вирівнювання "
"праворуч\n"
"                      Від'ємні N вирівнюватимуть дані ліворуч.\n"
"                      Зауваження: якщо виведені дані будуть довшими за N,\n"
"                      доповнення не відбуватиметься. Типовим є автоматичне "
"доповнення,\n"
"                      якщо буде виявлено пробіли.\n"

#: src/numfmt.c:931
msgid ""
"      --round=METHOD   use METHOD for rounding when scaling; METHOD can be:\n"
"                         up, down, from-zero (default), towards-zero, "
"nearest\n"
msgstr ""
"      --round=СПОСІБ  спосіб округлення під час масштабування. Варіанти:\n"
"                         up (до більшого), down (до меншого), from-zero (до "
"дальшого\n"
"                         до нуля, типовий), towards-zero (до ближчого до "
"нуля),\n"
"                         nearest (до найближчого цілого\n"

#: src/numfmt.c:935
msgid ""
"      --suffix=SUFFIX  add SUFFIX to output numbers, and accept optional\n"
"                         SUFFIX in input numbers\n"
msgstr ""
"      --suffix=СУФІКС додати СУФІКС до виведених чисел і використовувати "
"СУФІКС\n"
"                         у вхідних даних.\n"

#: src/numfmt.c:939
msgid ""
"      --to=UNIT        auto-scale output numbers to UNITs; see UNIT below\n"
msgstr ""
"      --to=ОДИНИЦЯ     автоматично масштабувати виведені числа за ОДИНИЦЕЮ; "
"див. опис одиниць нижче\n"

#: src/numfmt.c:942
msgid ""
"      --to-unit=N      the output unit size (instead of the default 1)\n"
msgstr ""
"      --to-unit=N      розмірність одиниці у виведених даних (замість "
"типової 1)\n"

#: src/numfmt.c:951
msgid ""
"\n"
"UNIT options:\n"
msgstr ""
"\n"
"Параметри одиниць:\n"

#: src/numfmt.c:954
msgid "  none       no auto-scaling is done; suffixes will trigger an error\n"
msgstr ""
"  none       без автоматичного масштабування; використання суфіксів призведе "
"до повідомлення про помилку\n"

#: src/numfmt.c:957
msgid ""
"  auto       accept optional single/two letter suffix:\n"
"               1K = 1000,\n"
"               1Ki = 1024,\n"
"               1M = 1000000,\n"
"               1Mi = 1048576,\n"
msgstr ""
"  auto       приймати додаткові одно-/дволітерні суфікси:\n"
"               1K = 1000,\n"
"               1Ki = 1024,\n"
"               1M = 1000000,\n"
"               1Mi = 1048576,\n"

#: src/numfmt.c:963
msgid ""
"  si         accept optional single letter suffix:\n"
"               1K = 1000,\n"
"               1M = 1000000,\n"
"               ...\n"
msgstr ""
"  si         приймати додаткові однолітерні суфікси:\n"
"               1K = 1000,\n"
"               1M = 1000000,\n"
"               ...\n"

#: src/numfmt.c:968
msgid ""
"  iec        accept optional single letter suffix:\n"
"               1K = 1024,\n"
"               1M = 1048576,\n"
"               ...\n"
msgstr ""
"  iec        приймати додаткові однолітерні суфікси:\n"
"               1K = 1024,\n"
"               1M = 1048576,\n"
"               ...\n"

#: src/numfmt.c:973
msgid ""
"  iec-i      accept optional two-letter suffix:\n"
"               1Ki = 1024,\n"
"               1Mi = 1048576,\n"
"               ...\n"
msgstr ""
"  iec-i      приймати додаткові дволітерні суфікси:\n"
"               1Ki = 1024,\n"
"               1Mi = 1048576,\n"
"               ...\n"

#: src/numfmt.c:979
msgid ""
"\n"
"FIELDS supports cut(1) style field ranges:\n"
"  N    N'th field, counted from 1\n"
"  N-   from N'th field, to end of line\n"
"  N-M  from N'th to M'th field (inclusive)\n"
"  -M   from first to M'th field (inclusive)\n"
"  -    all fields\n"
"Multiple fields/ranges can be separated with commas\n"
msgstr ""
"\n"
"У значенні ПОЛЯ передбачено підтримку стилю cut(1) діапазонів полів:\n"
"  N    N-те поле, відлік від 1\n"
"  N-   з поля N до кінця рядка\n"
"  N-M  з поля N до поля M (включно)\n"
"  -M   від першого поля до поля M (включно)\n"
"  -    усі поля\n"
"Можна вказати декілька полів/діапазонів, відокремивши їх комами\n"

#: src/numfmt.c:989
#, c-format
msgid ""
"\n"
"FORMAT must be suitable for printing one floating-point argument '%f'.\n"
"Optional quote (%'f) will enable --grouping (if supported by current "
"locale).\n"
"Optional width value (%10f) will pad output. Optional zero (%010f) width\n"
"will zero pad the number. Optional negative values (%-10f) will left align.\n"
"Optional precision (%.1f) will override the input determined precision.\n"
msgstr ""
"\n"
"ФОРМАТ має відповідати виведенню одного аргументу з рухомою крапкою -- "
"«%f».\n"
"Використання лапки (%'f) увімкне параметр --grouping (якщо він підтримується "
"поточною локаллю).\n"
"Додаткове визначення довжини (%10f) призведе до доповнення виведених даних.\n"
"Додаткова нульова довжина (%010f) призведе до нульового доповнення числа. "
"Додаткові від'ємні\n"
"значення довжини (%-10f) вирівнюватимуть виведення ліворуч.\n"
"Додатковий параметр точності (%.1f) перевизначає точність, визначену "
"вхідними даними.\n"

#: src/numfmt.c:997
#, c-format
msgid ""
"\n"
"Exit status is 0 if all input numbers were successfully converted.\n"
"By default, %s will stop at the first conversion error with exit status 2.\n"
"With --invalid='fail' a warning is printed for each conversion error\n"
"and the exit status is 2.  With --invalid='warn' each conversion error is\n"
"diagnosed, but the exit status is 0.  With --invalid='ignore' conversion\n"
"errors are not diagnosed and the exit status is 0.\n"
msgstr ""
"\n"
"Станом виходу буде 0, якщо всі числа у вхідних даних було успішно "
"перетворено.\n"
"Типово, %s припинить обробку після першої ж помилки зі станом виходу 2.\n"
"Якщо буде вказано --invalid='fail', для кожної помилки перетворення буде\n"
"виведено попередження, а станом виходу буде 2. Якщо буде вказано\n"
"--invalid='warn', буде виявлено всіх помилки перетворення, але станом "
"виходу\n"
"буде 0. Якщо буде вказано --invalid='ignore', про помилки перетворення не\n"
"повідомлятиметься, а станом виходу буде 0.\n"

#: src/numfmt.c:1006
#, c-format
msgid ""
"\n"
"Examples:\n"
"  $ %s --to=si 1000\n"
"            -> \"1.0K\"\n"
"  $ %s --to=iec 2048\n"
"           -> \"2.0K\"\n"
"  $ %s --to=iec-i 4096\n"
"           -> \"4.0Ki\"\n"
"  $ echo 1K | %s --from=si\n"
"           -> \"1000\"\n"
"  $ echo 1K | %s --from=iec\n"
"           -> \"1024\"\n"
"  $ df -B1 | %s --header --field 2-4 --to=si\n"
"  $ ls -l  | %s --header --field 5 --to=iec\n"
"  $ ls -lh | %s --header --field 5 --from=iec --padding=10\n"
"  $ ls -lh | %s --header --field 5 --from=iec --format %%10f\n"
msgstr ""
"\n"
"Прикладиs:\n"
"  $ %s --to=si 1000\n"
"            -> \"1.0K\"\n"
"  $ %s --to=iec 2048\n"
"           -> \"2.0K\"\n"
"  $ %s --to=iec-i 4096\n"
"           -> \"4.0Ki\"\n"
"  $ echo 1K | %s --from=si\n"
"           -> \"1000\"\n"
"  $ echo 1K | %s --from=iec\n"
"           -> \"1024\"\n"
"  $ df -B1 | %s --header --field 2-4 --to=si\n"
"  $ ls -l  | %s --header --field 5 --to=iec\n"
"  $ ls -lh | %s --header --field 5 --from=iec --padding=10\n"
"  $ ls -lh | %s --header --field 5 --from=iec --format %%10f\n"

#: src/numfmt.c:1059 src/seq.c:240
#, c-format
msgid "format %s has no %% directive"
msgstr "формат %s не містить директиву %%"

#: src/numfmt.c:1086
#, c-format
msgid "invalid format %s (width overflow)"
msgstr "некоректний формат %s (переповнення ширини)"

#: src/numfmt.c:1091
#, c-format
msgid "--format padding overriding --padding"
msgstr "--format доповнення перевизначає --padding"

#: src/numfmt.c:1110 src/seq.c:257
#, c-format
msgid "format %s ends in %%"
msgstr "формат %s закінчується у %%"

#: src/numfmt.c:1126
#, c-format
msgid "invalid precision in format %s"
msgstr "некоректна точність у форматуванні %s"

#: src/numfmt.c:1132
#, c-format
msgid "invalid format %s, directive must be %%[0]['][-][N][.][N]f"
msgstr "некоректний формат %s, інструкцією має бути %%[0]['][-][N][.][N]f"

#: src/numfmt.c:1140 src/seq.c:264
#, c-format
msgid "format %s has too many %% directives"
msgstr "формат %s має надто багато директив %%"

#: src/numfmt.c:1183
#, c-format
msgid "invalid suffix in input %s: %s"
msgstr "некоректний суфікс у вхідних даних %s: %s"

#: src/numfmt.c:1212
#, c-format
msgid ""
"value/precision too large to be printed: '%Lg/%<PRIuMAX>' (consider using --"
"to)"
msgstr ""
"значення або точність є надто великим для виведення: «%Lg/%<PRIuMAX>» (варто "
"скористатися --to)"

#: src/numfmt.c:1216
#, c-format
msgid "value too large to be printed: '%Lg' (consider using --to)"
msgstr ""
"значення є надто великим для виведення: «%Lg» (варто скористатися --to)"

#: src/numfmt.c:1225
#, c-format
msgid "value too large to be printed: '%Lg' (cannot handle values > 999Y)"
msgstr ""
"значення є надто великим для виведення: «%Lg» (обробка значень більше 999Y "
"неможлива)"

#: src/numfmt.c:1311
#, c-format
msgid "large input value %s: possible precision loss"
msgstr "занадто велике вхідне значення, %s, можлива втрата точності"

#: src/numfmt.c:1500
#, c-format
msgid "invalid padding value %s"
msgstr "некоректне значення доповнення %s"

#: src/numfmt.c:1513
msgid "multiple field specifications"
msgstr "специфікація використання декількох полів"

#: src/numfmt.c:1547
#, c-format
msgid "invalid header value %s"
msgstr "некоректне значення заголовка, %s"

#: src/numfmt.c:1574
msgid "--grouping cannot be combined with --format"
msgstr "--grouping не можна використовувати разом з --format"

#: src/numfmt.c:1577
#, c-format
msgid "failed to set locale"
msgstr "не вдалося встановити локаль"

#: src/numfmt.c:1582
#, c-format
msgid "no conversion option specified"
msgstr "не вказано параметра перетворення"

#: src/numfmt.c:1590
msgid "grouping cannot be combined with --to"
msgstr "grouping не можна використовувати разом з --to"

#: src/numfmt.c:1592
#, c-format
msgid "grouping has no effect in this locale"
msgstr "групування не діє у цій локалі"

#: src/numfmt.c:1605
#, c-format
msgid "--header ignored with command-line input"
msgstr ""
"--header проігноровано, оскільки вхідні дані надходять з командного рядка"

#: src/numfmt.c:1632
#, c-format
msgid "error reading input"
msgstr "помилка під час спроби читання вхідних даних"

#: src/numfmt.c:1643
#, c-format
msgid "failed to convert some of the input numbers"
msgstr "не вдалося перетворити деякі з вхідних чисел"

#: src/od.c:322
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]\n"
"  or:  %s --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] [+][LABEL][.]"
"[b]]\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ФАЙЛ]...\n"
"       або:    %s [-abcdfilosx]... [ФАЙЛ] [[+]ЗСУВ[.][b]]\n"
"       або:    %s --traditional [КЛЮЧ]... [ФАЙЛ] [[+]ЗСУВ[.][b] [+][МІТКА][.]"
"[b]]\n"

#: src/od.c:328
msgid ""
"\n"
"Write an unambiguous representation, octal bytes by default,\n"
"of FILE to standard output.  With more than one FILE argument,\n"
"concatenate them in the listed order to form the input.\n"
msgstr ""
"\n"
"Виводить однозначне (типово байтове вісімкове) представлення ФАЙЛА\n"
"на стандартне виведення. Якщо вказано декілька аргументів ФАЙЛ,\n"
"сполучає їх до одного фрагмента даних у вказаному порядку для\n"
"формування результатів.\n"
"\n"

#: src/od.c:336
msgid ""
"\n"
"If first and second call formats both apply, the second format is assumed\n"
"if the last operand begins with + or (if there are 2 operands) a digit.\n"
"An OFFSET operand means -j OFFSET.  LABEL is the pseudo-address\n"
"at first byte printed, incremented when dump is progressing.\n"
"For OFFSET and LABEL, a 0x or 0X prefix indicates hexadecimal;\n"
"suffixes may be . for octal and b for multiply by 512.\n"
msgstr ""
"\n"
"Якщо застосовуються й перша, й друга форми виклику, вважається друга\n"
"форма, якщо останній операнд починається на + або (якщо вказані два\n"
"операнда) на цифру.  Операнд ЗСУВ означає -j ЗСУВ.  МІТКА --\n"
"це псевдоадреса першого виведеного байту, збільшується у процесі\n"
"виводу.  Префікс 0x або 0X задає ЗСУВ або МІТКУ як\n"
"шістнадцяткові числа, суфікс . -- як вісімкові, а суфікс b\n"
"помножує на 512.\n"

#: src/od.c:348
msgid ""
"  -A, --address-radix=RADIX   output format for file offsets; RADIX is one\n"
"                                of [doxn], for Decimal, Octal, Hex or None\n"
"      --endian={big|little}   swap input bytes according the specified "
"order\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
msgstr ""
"  -A, --address-radix=ОСНОВА  виводити зсув у файлах використовуючи\n"
"                              вказану систему числення\n"
"\n"
"                              ОСНОВОЮ може бути одна з літер [doxn],\n"
"                              десяткова, вісімкова, шістнадцяткова або\n"
"                              ніяка\n"
"      --endian={big|little}   встановити вказаний порядок байтів\n"
"  -j, --skip-bytes=Н          пропустить перші Н байт\n"

#: src/od.c:354
msgid ""
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
"  -S BYTES, --strings[=BYTES]  output strings of at least BYTES graphic "
"chars;\n"
"                                3 is implied when BYTES is not specified\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w[BYTES], --width[=BYTES]  output BYTES bytes per output line;\n"
"                                32 is implied when BYTES is not specified\n"
"      --traditional           accept arguments in third form above\n"
msgstr ""
"  -N, --read-bytes=N          читати лише N байтів у кожному файлі\n"
"  -S, --strings[=N]           виводити рядки довжиною принаймні N байтів\n"
"                              графічних знаків\n"
"                                Якщо N не вказано, буде використано 3\n"
"  -t, --format=ТИП            вибір формату або форматів виводу\n"
"  -v, --output-duplicates     не позначати знаком * рядки, що не виводяться\n"
"  -w[N], --width[=N]          виводити N байтів у кожному рядку виводу\n"
"                                Якщо N не вказано, буде використано 32\n"
"      --traditional           приймати аргументи у традиційній формі\n"

#: src/od.c:367
msgid ""
"\n"
"\n"
"Traditional format specifications may be intermixed; they accumulate:\n"
"  -a   same as -t a,  select named characters, ignoring high-order bit\n"
"  -b   same as -t o1, select octal bytes\n"
"  -c   same as -t c,  select printable characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal 2-byte units\n"
msgstr ""
"\n"
"\n"
"Традиційні специфікації формату можна змішувати, вони акумулюються:\n"
"  -a   синонім -t a,  іменовані знаки\n"
"  -b   синонім -t o1, вісімкові байти\n"
"  -c   синонім -t c,  придатні до показу симовли або керівні послідовності з "
"'\\'\n"
"  -d   синонім -t u2, беззнакові десяткові двобайтові одиниці\n"

#: src/od.c:376
msgid ""
"  -f   same as -t fF, select floats\n"
"  -i   same as -t dI, select decimal ints\n"
"  -l   same as -t dL, select decimal longs\n"
"  -o   same as -t o2, select octal 2-byte units\n"
"  -s   same as -t d2, select decimal 2-byte units\n"
"  -x   same as -t x2, select hexadecimal 2-byte units\n"
msgstr ""
"  -f   синонім -t fF, числа з плаваючою комою\n"
"  -i   синонім -t dI, десяткові цілі\n"
"  -l   синонім -t dL, десяткові довгі цілі\n"
"  -o   синонім -t o2, вісімкові двобайтові одиниці\n"
"  -s   синонім -t d2, десяткові двобайтові одиниці\n"
"  -x   синонім -t x2, шістнадцяткові двобайтові одиниці\n"

#: src/od.c:384
msgid ""
"\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"  a          named character, ignoring high-order bit\n"
"  c          printable character or backslash escape\n"
msgstr ""
"\n"
"\n"
"ТИП може складатись з одного або більше наступних описів:\n"
"  a          іменований знак\n"
"  c          придатний до показу символ або керівна послідовність з '\\'\n"

#: src/od.c:391
msgid ""
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per float\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
msgstr ""
"  d[ЧИСЛО]   знакове десяткове ціле розміром вказане ЧИСЛО байт\n"
"  f[ЧИСЛО]   число з рухомою крапкою розміром вказане ЧИСЛО байт\n"
"  o[ЧИСЛО]   вісімкове ціле розміром вказане ЧИСЛО байт\n"
"  u[ЧИСЛО]   беззнакове десяткове ціле розміром вказане ЧИСЛО байт\n"
"  x[ЧИСЛО]   шістнадцяткове ціле розміром вказане ЧИСЛО байт\n"

#: src/od.c:398
msgid ""
"\n"
"SIZE is a number.  For TYPE in [doux], SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
msgstr ""
"\n"
"Якщо ТИП -- одна з літер [doux], ЧИСЛО можна вказувати як C (char), S "
"(short),\n"
"I (int) або L (long), якщо ТИП дорівнює f, ЧИСЛО може бути F (float),\n"
"D (double) або L (long double).\n"

#: src/od.c:405
msgid ""
"\n"
"Adding a z suffix to any type displays printable characters at the end of\n"
"each output line.\n"
msgstr ""
"\n"
"Додавання суфікса z до будь-якого типу призведе до виведення видимих "
"символів\n"
"наприкінці кожного рядка виведених даних.\n"

#: src/od.c:410
msgid ""
"\n"
"\n"
"BYTES is hex with 0x or 0X prefix, and may have a multiplier suffix:\n"
"  b    512\n"
"  KB   1000\n"
"  K    1024\n"
"  MB   1000*1000\n"
"  M    1024*1024\n"
"and so on for G, T, P, E, Z, Y.\n"
msgstr ""
"\n"
"\n"
"Після ЧИСЛА блоків та байт може стояти один з суфіксів-множників:\n"
"  b    512\n"
"  KB   1000\n"
"  K    1024\n"
"  MB   1000*1000\n"
"  M    1024*1024\n"
"тощо для G, T, P, E, Z, Y.\n"

#: src/od.c:684 src/od.c:804
#, c-format
msgid "invalid type string %s"
msgstr "неправильний рядок типу %s"

#: src/od.c:694
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"неправильно вказаний рядок типу %s;\n"
"ця система не підтримує %lu-байтове цілого типу"

#: src/od.c:815
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"неправильно вказаний тип %s;\n"
"ця система не підтримує %lu-байтове типу з плаваючою комою"

#: src/od.c:873
#, c-format
msgid "invalid character '%c' in type string %s"
msgstr "неправильний знак '%c' у рядку типу %s"

#: src/od.c:1105
msgid "cannot skip past end of combined input"
msgstr "неможливо перейти за межу останнього вхідного файла"

#: src/od.c:1658
#, c-format
msgid "invalid output address radix '%c'; it must be one character from [doxn]"
msgstr ""
"неправильно вказана основа системи числення '%c', повинна бути одним з "
"символів [doxn]"

#: src/od.c:1796
msgid "no type may be specified when dumping strings"
msgstr "при дампі рядків не можна вказувати тип"

#: src/od.c:1871
msgid "compatibility mode supports at most one file"
msgstr "у режимі сумісності підтримується не більше одного файла."

#: src/od.c:1892
msgid "skip-bytes + read-bytes is too large"
msgstr "значення skip-bytes + read-bytes надто велике"

#: src/od.c:1935
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "попередження: неправильна ширина %lu; буде використана %d"

#: src/operand2sig.c:81
#, c-format
msgid "%s: invalid signal"
msgstr "%s: неправильний сигнал"

#: src/paste.c:222
msgid "standard input is closed"
msgstr "стандартний ввід закритий"

#: src/paste.c:441
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
msgstr ""
"Вивести рядки, що складаються з послідовності відповідних рядків із\n"
"кожного ФАЙЛа, відокремлені табуляціями, до стандартного виведення.\n"

#: src/paste.c:449
msgid ""
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
msgstr ""
"  -d, --delimiters=СПИСОК  використовувати замість табуляції знаки зі "
"СПИСКУ\n"
"  -s, --serial             обробляти файли послідовно\n"

#: src/paste.c:519
#, c-format
msgid "delimiter list ends with an unescaped backslash: %s"
msgstr "список роздільників завершується неекранованою зворотною рискою: %s"

#: src/pathchk.c:89
msgid ""
"Diagnose invalid or unportable file names.\n"
"\n"
"  -p                  check for most POSIX systems\n"
"  -P                  check for empty names and leading \"-\"\n"
"      --portability   check for all POSIX systems (equivalent to -p -P)\n"
msgstr ""
"Виявляє некоректні та непереносні конструкції у назвах файлів.\n"
"\n"
"  -p                  перевірка для більшості POSIX-систем\n"
"  -P                  перевірка на порожні назви та початковий «-»\n"
"      --portability   перевірка для усіх POSIX-систем (еквівалентно до -p -"
"P)\n"

#: src/pathchk.c:169
#, c-format
msgid "leading '-' in a component of file name %s"
msgstr "початковий '-' у компоненті назві файла %s"

#: src/pathchk.c:195
#, c-format
msgid "nonportable character %s in file name %s"
msgstr "непереносний знак %s у назві файла %s"

#: src/pathchk.c:271
#, c-format
msgid "empty file name"
msgstr "порожня назва файла"

#: src/pathchk.c:313
#, c-format
msgid "%s: unable to determine maximum file name length"
msgstr "%s: не вдалося визначити максимальну довжину назви файла"

#: src/pathchk.c:324
#, c-format
msgid "limit %lu exceeded by length %lu of file name %s"
msgstr "межу %lu перевищено довжиною %lu у назві файла %s"

#: src/pathchk.c:410
#, c-format
msgid "limit %lu exceeded by length %lu of file name component %s"
msgstr "перевищено обмеження %lu довжиною %lu у компоненті імені файла %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:37 src/uptime.c:46 src/users.c:36 src/who.c:50
msgid "Joseph Arceneaux"
msgstr "Joseph Arceneaux"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:39 src/uptime.c:48
msgid "Kaveh Ghazi"
msgstr "Kaveh Ghazi"

#. TRANSLATORS: Real name is unknown; at most 19 characters.
#: src/pinky.c:241
msgid "        ???"
msgstr "        ???"

#. TRANSLATORS: Idle time is unknown; at most 5 characters.
#: src/pinky.c:265
msgid "?????"
msgstr "?????"

#: src/pinky.c:313
#, c-format
msgid "Login name: "
msgstr "Реєстраційна назва: "

#: src/pinky.c:316
#, c-format
msgid "In real life: "
msgstr "У реальному житті: "

#. TRANSLATORS: Real name is unknown; no hard limit.
#: src/pinky.c:320
msgid "???\n"
msgstr "???\n"

#: src/pinky.c:340
#, c-format
msgid "Directory: "
msgstr "Каталог: "

#: src/pinky.c:342
#, c-format
msgid "Shell: "
msgstr "Оболонка: "

#: src/pinky.c:361
#, c-format
msgid "Project: "
msgstr "Проект: "

#: src/pinky.c:385
#, c-format
msgid "Plan:\n"
msgstr "План:\n"

#: src/pinky.c:404
msgid "Login"
msgstr "Реєстраційне ім'я'"

#: src/pinky.c:406
msgid "Name"
msgstr "Назва"

#: src/pinky.c:407
msgid " TTY"
msgstr " Термінал"

#: src/pinky.c:409
msgid "Idle"
msgstr "Неактивний"

#: src/pinky.c:410
msgid "When"
msgstr "Коли"

#: src/pinky.c:413
msgid "Where"
msgstr "Де"

#: src/pinky.c:493
#, c-format
msgid "Usage: %s [OPTION]... [USER]...\n"
msgstr "Використання: %s [КЛЮЧ]... [КОРИСТУВАЧ]...\n"

#: src/pinky.c:494
msgid ""
"\n"
"  -l              produce long format output for the specified USERs\n"
"  -b              omit the user's home directory and shell in long format\n"
"  -h              omit the user's project file in long format\n"
"  -p              omit the user's plan file in long format\n"
"  -s              do short format output, this is the default\n"
msgstr ""
"\n"
"  -l              використовувати докладний формат виводу\n"
"  -b              опустити у докладному форматі початковий каталог та\n"
"                  оболонку цього користувача\n"
"  -h              опустити у докладному форматі файл проекту цього\n"
"                  користувача\n"
"  -p              опустити у докладному форматі файл плану цього\n"
"                  користувача\n"
"  -s              короткий формат виводу, типово використовується\n"

#: src/pinky.c:502
msgid ""
"  -f              omit the line of column headings in short format\n"
"  -w              omit the user's full name in short format\n"
"  -i              omit the user's full name and remote host in short format\n"
"  -q              omit the user's full name, remote host and idle time\n"
"                  in short format\n"
msgstr ""
"  -f              опустити у короткому форматі рядок з заголовками колонок\n"
"  -w              опустити у короткому форматі повне ім'я користувача\n"
"  -i              опустити у короткому форматі повне ім'я користувача та\n"
"                  назву віддаленої машини\n"
"  -q              опустити у короткому форматі повне ім'я користувача,\n"
"                  назву віддаленої машини та час неактивності\n"

#: src/pinky.c:511
#, c-format
msgid ""
"\n"
"A lightweight 'finger' program;  print user information.\n"
"The utmp file will be %s.\n"
msgstr ""
"\n"
"Спрощена програма 'finger';  виводить відомості про користувача.\n"
"У складі файла utmp буде використовуватися %s.\n"

#: src/pinky.c:595
#, c-format
msgid "no username specified; at least one must be specified when using -l"
msgstr ""
"не вказано ім'я користувача; при використанні ключа -l треба вказати хоча б "
"одне"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:331
msgid "Pete TerMaat"
msgstr "Pete TerMaat"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:332
msgid "Roland Huebner"
msgstr "Roland Huebner"

#: src/pr.c:777
msgid "integer overflow"
msgstr "переповнення цілочислової змінної"

#: src/pr.c:916
msgid "'--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr "'--pages=ПЕРША_СТОР[:ОСТАННЯ_СТОР]' пропущений аргумент"

#: src/pr.c:918
#, c-format
msgid "invalid page range %s"
msgstr "некоректний діапазон сторінок %s"

#: src/pr.c:978
msgid "'-l PAGE_LENGTH' invalid number of lines"
msgstr "«-l ДОВЖИНА_СТОРІНКИ» — неправильна кількість рядків"

#: src/pr.c:993
msgid "'-N NUMBER' invalid starting line number"
msgstr "«-N НОМЕР» — неправильний номер початкового рядка"

#: src/pr.c:997
msgid "'-o MARGIN' invalid line offset"
msgstr "«-o ПОЛЕ» — неправильний зсув"

#: src/pr.c:1034
msgid "'-w PAGE_WIDTH' invalid number of characters"
msgstr "«-w ШИРИНА_СТОРІНКИ» неправильна кількість знаків"

#: src/pr.c:1043
msgid "'-W PAGE_WIDTH' invalid number of characters"
msgstr "«-W ШИРИНА_СТОРІНКИ» неправильна кількість знаків"

#: src/pr.c:1072
msgid "cannot specify number of columns when printing in parallel"
msgstr "неможливо вказати кількість позицій під час паралельного друку"

#: src/pr.c:1076
msgid "cannot specify both printing across and printing in parallel"
msgstr "не можна одночасно вказувати друк вздовж і паралельно."

#: src/pr.c:1180
#, c-format
msgid "'-%c' extra characters or invalid number in the argument: %s"
msgstr "'-%c' зайві знаки або неправильне число у аргументі: %s"

#: src/pr.c:1282
msgid "page width too narrow"
msgstr "сторінка надто вузька"

#: src/pr.c:2344
#, c-format
msgid "starting page number %<PRIuMAX> exceeds page count %<PRIuMAX>"
msgstr ""
"номер початкової сторінки %<PRIuMAX> перевищує загальну кількість сторінок "
"%<PRIuMAX>"

#: src/pr.c:2371
msgid "page number overflow"
msgstr "переповнення номеру сторінок"

#: src/pr.c:2376
#, c-format
msgid "Page %<PRIuMAX>"
msgstr "Сторінка %<PRIuMAX>"

#: src/pr.c:2748
msgid "Paginate or columnate FILE(s) for printing.\n"
msgstr "Розбиває ФАЙЛ(и) на сторінки або колонки під час виведення.\n"

#: src/pr.c:2755
msgid ""
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    output COLUMN columns and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page\n"
msgstr ""
"  +ПЕРША_СТОРІНКА[:ОСТАННЯ_СТОРІНКА], --pages=ПЕРША_СТОРІНКА[:"
"ОСТАННЯ_СТОРІНКА]\n"
"                    почати [завершити] друк на ПЕРШІЙ_[ОСТАННІЙ_]СТОРІНЦІ\n"
"  -КІЛЬКІСТЬ, --columns=КІЛЬКІСТЬ\n"
"                    виводити вказану КІЛЬКІСТЬ колонок та виводити їх вниз,\n"
"                    лише коли не вказаний ключ -a.  Балансувати кількість\n"
"                    рядків у колонці на кожній сторінці.\n"

#: src/pr.c:2763
msgid ""
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
msgstr ""
"  -a, --across      виводити колонки поперек, а не вниз; використовується\n"
"                    разом з ключем -ЧИСЛО\n"
"  -c, --show-control-chars\n"
"                    використовувати запис з шапочкою (^G) або зворотною\n"
"                    косою рискою (та вісімковим кодом)\n"
"  -d,  --double-space\n"
"                    вставляти порожній рядок після кожного виведеного рядка\n"

#: src/pr.c:2771
msgid ""
"  -D, --date-format=FORMAT\n"
"                    use FORMAT for the header date\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"  -D, --date-format=ФОРМАТ\n"
"                    використовувати для дати у заголовку вказаний ФОРМАТ\n"
"  -e[ЗНАК[ЧИСЛО]], --expand-tabs[=ЗНАК[ЧИСЛО]]\n"
"                    перетворювати вхідні ЗНАКИ (табуляцію) у вказане ЧИСЛО\n"
"                    пробілів (8)\n"
"  -F, -f, --form-feed\n"
"                    для розділення сторінок вживати знак переносу сторінки,\n"
"                    а не нового рядка (з трьохрядковим заголовком, якщо є\n"
"                    ключ -F, та п'ятирядковим заголовком та кінцівкою, якщо\n"
"                    ключ -F не вказаний)\n"

#: src/pr.c:2781
msgid ""
"  -h, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, --sep-string[=STRING] sets separators\n"
msgstr ""
"  -h ЗАГОЛОВОК, --header=ЗАГОЛОВОК\n"
"                   використовувати для сторінок центрований ЗАГОЛОВОК, а не\n"
"                   назву файла;  -h \"\" виводить порожній рядок; не\n"
"                   використовуйте -h \"\"\n"
"  -i[ЗНАК[ШИРИНА]], --output-tabs[=ЗНАК[ШИРИНА]]\n"
"                   замінити пробіли ЗНАКАМИ (табуляцію) вказаної ШИРИНИ (8)\n"
"  -J, --join-lines об'єднувати повні рядки, вимкнути урізання рядків (-W),\n"
"                   не вирівнювати колонки, --sep-string[=РЯДОК]\n"
"                   задає розділювачі\n"

#: src/pr.c:2790
msgid ""
"  -l, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63).\n"
"                    implies -t if PAGE_LENGTH <= 10\n"
msgstr ""
"  -l, --length=ДОВЖИНА_СТОРІНКИ\n"
"                    встановити ДОВЖИНУ_СТОРІНКИ (66)\n"
"                    (типово кількість рядків тексту рівно 56, а з -F 63).\n"
"                    Використовує -t, якщо ДОВЖИНА_СТОРІНКИ <= 10\n"

#: src/pr.c:2796
msgid ""
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
msgstr ""
"  -m, --merge       виводити всі файли паралельно, по одному у стовпчику,\n"
"                    урізати рядка, але з'єднувати повні рядки при -J\n"

#: src/pr.c:2800
msgid ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
msgstr ""
"  -n[РОЗД[ЧИСЛО]], --number-lines[=РОЗД[ЧИСЛО]]\n"
"                    нумерувати рядки, використовуючи вказане ЧИСЛО (5) цифр\n"
"                    та РОЗДілювач (табуляцію); типово нумерація починається\n"
"                    з першого вхідного рядка\n"
"  -N, --first-line-number=НОМЕР\n"
"                    почати нумерацію з НОМЕРА з першого рядка першої\n"
"                    сторінки, що виводиться (дивіться +ПЕРША_СТОРІНКА)\n"

#: src/pr.c:2808
msgid ""
"  -o, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""
"  -o, --indent=ПОЛЕ\n"
"                    зсувати кожен рядок на ПОЛЕ (нуль) пробілів (не впливає\n"
"                    на -w або -W); ПОЛЕ додається до ШИРИНА_СТОРІНКИ\n"
"  -r, --no-file-warnings\n"
"                    не попереджати про неможливість відкриття файла\n"

#: src/pr.c:2815
msgid ""
"  -s[CHAR], --separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -"
"w.\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
msgstr ""
"  -s[ЗНАК],--separator[=ЗНАК]\n"
"                    розділяти колонки одним знаком, типово ЗНАК дорівнює\n"
"                    табуляції, без ключа -w, та порожній, якщо є ключ -w.\n"
"                    -s[ЗНАК] вимикає урізання рядків для усіх трьох ключів\n"
"                    для колонок (-ЧИСЛО |-a -ЧИСЛО|-m), якщо немає ключа -"
"w.\n"

#: src/pr.c:2823
msgid ""
"  -S[STRING], --sep-string[=STRING]\n"
"                    separate columns by STRING,\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
msgstr ""
"  -S[РЯДОК], --sep-string[=РЯДОК]\n"
"                    розділяти колонки РЯДКОМ;\n"
"                    без -S: розділювач — табуляція, якщо вказано\n"
"                    ключ -J, інакше пробіл (те саме, що -S\" \"); не "
"впливає\n"
"                    на параметри для колонок\n"

#: src/pr.c:2829
msgid ""
"  -t, --omit-header  omit page headers and trailers;\n"
"                     implied if PAGE_LENGTH <= 10\n"
msgstr ""
"  -t, --omit-header  пропускати заголовки і кінцівки сторінок;\n"
"                     використовується, якщо ДОВЖИНА_СТОРІНКИ <= 10\n"

#: src/pr.c:2833
msgid ""
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
msgstr ""
"  -T, --omit-pagination\n"
"                    не виводити заголовки, ігнорувати символи розриву\n"
"                    сторінки у вхідних файлах\n"
"  -v, --show-nonprinting\n"
"                    використовувати запис з «\\» та вісімковим кодом\n"
"  -w, --width=ШИРИНА_СТОРІНКИ\n"
"                    встановити ШИРИНУ_СТОРІНКИ (72) у стовпчиках для\n"
"                    виводу у декілька колонок, -s[знак] вимикає (72)\n"

#: src/pr.c:2843
msgid ""
"  -W, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
msgstr ""
"  -W, --page-width=ШИРИНА_СТОРІНКИ\n"
"                    встановити ШИРИНУ_СТОРІНКИ (72) символи, усікати рядки,\n"
"                    якщо не вказаний ключ -J; не змінюється ключами -S чи -"
"s\n"

#: src/printenv.c:62
#, c-format
msgid ""
"Usage: %s [OPTION]... [VARIABLE]...\n"
"Print the values of the specified environment VARIABLE(s).\n"
"If no VARIABLE is specified, print name and value pairs for them all.\n"
"\n"
msgstr ""
"Використання: %s [ПАРАМЕТР]... [ЗМІННА]...\n"
"Виводить значення вказаних змінних середовища.\n"
"Якщо параметр ЗМІННА не вказано, виводить пари назва-значення для всіх.\n"
"\n"

#: src/printenv.c:69
msgid "  -0, --null     end each output line with NUL, not newline\n"
msgstr ""
"  -0, --null     завершувати кожен рядок нуль-байтом замість розриву рядка\n"

#: src/printf.c:84
#, c-format
msgid ""
"warning: %s: character(s) following character constant have been ignored"
msgstr ""
"попередження: %s: знаки, наступні за знаковою константою, проігноровані"

#: src/printf.c:93
#, c-format
msgid ""
"Usage: %s FORMAT [ARGUMENT]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s ФОРМАТ [АРГУМЕНТ]...\n"
"       або:    %s КЛЮЧ\n"

#: src/printf.c:98
msgid ""
"Print ARGUMENT(s) according to FORMAT, or execute according to OPTION:\n"
"\n"
msgstr ""
"Виводить АРГУМЕНТ(и) відповідно до ФОРМАТ, або або виконати відповідно до "
"OPTION:\n"
"\n"

#: src/printf.c:104
msgid ""
"\n"
"FORMAT controls the output as in C printf.  Interpreted sequences are:\n"
"\n"
"  \\\"      double quote\n"
msgstr ""
"\n"
"ФОРМАТ керує виводом так само, як у функції C printf.\n"
"Приймаються наступні послідовності:\n"
"\n"
"  \\\"     подвійні лапки\n"

#: src/printf.c:122
msgid ""
"  \\NNN    byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
"  \\uHHHH  Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)\n"
"  \\UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits)\n"
msgstr ""
"  \\NNN    байт з вісімковим значенням NNN (від 1 до 3 цифр)\n"
"  \\xНН    байт з шістнадцятковим кодом НН (від 1 до 2 цифр)\n"
"  \\uНННН  знак Unicode (ISO/IEC 10646) з шістнадцятковим кодом НННН (4 "
"цифри)\n"
"  \\UНННННННН  знак Unicode з шістнадцятковим кодом НННННННН (8 цифр)\n"

#: src/printf.c:128
msgid ""
"  %%      a single %\n"
"  %b      ARGUMENT as a string with '\\' escapes interpreted,\n"
"          except that octal escapes are of the form \\0 or \\0NNN\n"
"  %q      ARGUMENT is printed in a format that can be reused as shell "
"input,\n"
"          escaping non-printable characters with the proposed POSIX $'' "
"syntax.\n"
"\n"
"and all C format specifications ending with one of diouxXfeEgGcs, with\n"
"ARGUMENTs converted to proper type first.  Variable widths are handled.\n"
msgstr ""
"  %%      один символ %\n"
"  %b      АРГУМЕНТом є рядок із обробкою послідовностей «\\»,\n"
"          окрім вісімкових послідовностей у форматі \\0 або \\0NNN\n"
"  %q      АРГУМЕНТ виводиться у форматі, який можна використати для\n"
"          вхідних даних оболонки, із екрануванням непридатних до\n"
"          друку символів на основі запропоновано синтаксису POSIX $''.\n"
"\n"
"усі специфікації формату C, що завершуються на один із символів "
"diouxXfeEgGcs, разом із АРГУМЕНТОМ спочатку приводяться до належного типу.\n"
"Обробляються також знаки змінної ширини.\n"

#: src/printf.c:155
#, c-format
msgid "%s: expected a numeric value"
msgstr "%s: очікується числове значення"

#: src/printf.c:157
#, c-format
msgid "%s: value not completely converted"
msgstr "%s: значення перетворене не повністю"

#: src/printf.c:254 src/printf.c:281
msgid "missing hexadecimal number in escape"
msgstr "неправильна шістнадцяткове число у escape-послідовності"

#: src/printf.c:293
#, c-format
msgid "invalid universal character name \\%c%0*x"
msgstr "неправильна універсальна назва знаку \\%c%0*x"

#: src/printf.c:566
#, c-format
msgid "invalid field width: %s"
msgstr "неправильна ширина поля: %s"

#: src/printf.c:601
#, c-format
msgid "invalid precision: %s"
msgstr "неправильна точність: %s"

#: src/printf.c:628
#, c-format
msgid "%.*s: invalid conversion specification"
msgstr "%.*s: неправильна специфікація перетворення"

#: src/printf.c:711
#, c-format
msgid "warning: ignoring excess arguments, starting with %s"
msgstr "попередження: зайві аргументи проігноровані, починаючи з %s"

#. TRANSLATORS: Please translate "F. Pinard" to "François Pinard"
#. if "ç" (c-with-cedilla) is available in the translation's character
#. set and encoding.
#. This is a proper name. See the gettext manual, section Names.
#: src/ptx.c:42
msgid "F. Pinard"
msgstr "Ф. Пінард"

#: src/ptx.c:419
#, c-format
msgid "%s (for regexp %s)"
msgstr "%s (для регулярного виразу %s)"

#: src/ptx.c:1821
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ВХІД]... (без -G)\n"
"       або:    %s -G [КЛЮЧ]... [ВХІД [ВИХІД]]\n"

#: src/ptx.c:1825
msgid ""
"Output a permuted index, including context, of the words in the input "
"files.\n"
msgstr ""
"Виводить переставлений алфавітний вказівник слів вхідних файлів, включаючи "
"контекст.\n"

#: src/ptx.c:1832
msgid ""
"  -A, --auto-reference           output automatically generated references\n"
"  -G, --traditional              behave more like System V 'ptx'\n"
msgstr ""
"  -A, --auto-reference           виводити автоматично згенеровані посилання\n"
"  -G, --traditional              увімкнути режим сумісності з System V "
"(ptx)\n"

#: src/ptx.c:1836
msgid ""
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations.\n"
"                                 The default is '/'\n"
msgstr ""
"  -F, --flag-truncation=РЯДОК    використовувати РЯДОК для позначення\n"
"                                 обрізаних рядків. Типовим є «/».\n"

#: src/ptx.c:1840
msgid ""
"  -M, --macro-name=STRING        macro name to use instead of 'xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
msgstr ""
"  -M, --macro-name=РЯДОК         назва макросу, яку слід використовувати\n"
"                                 замість 'xx'\n"
"  -O, --format=roff              генерувати вивід у вигляді директив roff\n"
"  -R, --right-side-refs          поміщати посилання справа, не діє при -w\n"
"  -S, --sentence-regexp=REGEXP   для кінця рядків або кінця речень\n"
"  -T, --format=tex               генерувати вивід у вигляді директив TeX\n"

#: src/ptx.c:1847
msgid ""
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
msgstr ""
"  -W, --word-regexp=REGEXP       регулярний вираз для ключових слів\n"
"  -b, --break-file=ФАЙЛ          ФАЙЛ з символами-розділювачами слів\n"
"  -f, --ignore-case              перетворювати до верхнього регістру при\n"
"                                 сортуванні\n"
"  -g, --gap-size=ЧИСЛО           розмір проміжку між полями виводу,\n"
"                                 виражений у стовпчиках\n"
"  -i, --ignore-file=ФАЙЛ         прочитати перелік ігнорованих слів з ФАЙЛА\n"
"  -o, --only-file=ФАЙЛ           лише прочитати список слів з заданого "
"ФАЙЛА\n"

#: src/ptx.c:1855
msgid ""
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
msgstr ""
"  -r, --references               перше поле у кожній рядку є посиланням\n"
"  -t, --typeset-mode               - не реалізовано -\n"
"  -w, --width=ЧИСЛО              ширина виводу у стовпчиках, без урахування "
"посилань\n"

#: src/ptx.c:1952
#, c-format
msgid "invalid gap width: %s"
msgstr "неправильна ширина інтервалу: %s"

#: src/ptx.c:1979
#, c-format
msgid "invalid line width: %s"
msgstr "неправильна довжина рядка: %s"

#: src/pwd.c:58
msgid ""
"Print the full filename of the current working directory.\n"
"\n"
msgstr ""
"Виводить повну назву поточного робочого каталогу.\n"
"\n"

#: src/pwd.c:62
msgid ""
"  -L, --logical   use PWD from environment, even if it contains symlinks\n"
"  -P, --physical  avoid all symlinks\n"
msgstr ""
"  -L, --logical   використовувати PWD з середовища, навіть якщо там "
"містяться символічні посилання\n"
"  -P, --physical  пропустити всі символічні посилання\n"

#: src/pwd.c:68
msgid ""
"\n"
"If no option is specified, -P is assumed.\n"
msgstr ""
"\n"
"Якщо не вказано параметрів, буде використано параметр -P.\n"

#: src/pwd.c:170
#, c-format
msgid "failed to chdir to %s"
msgstr "помилка зміни каталогу на %s"

#: src/pwd.c:174 src/pwd.c:281 src/split.c:466
#, c-format
msgid "failed to stat %s"
msgstr "помилка отримання атрибутів %s"

#: src/pwd.c:239
#, c-format
msgid "couldn't find directory entry in %s with matching i-node"
msgstr "у %s не знайдено запис каталогу з відповідним i-node"

#: src/pwd.c:368
#, c-format
msgid "ignoring non-option arguments"
msgstr "аргументи, що не є ключами проігноровані"

#. This is a proper name. See the gettext manual, section Names.
#: src/readlink.c:32
msgid "Dmitry V. Levin"
msgstr "Dmitry V. Levin"

#: src/readlink.c:62 src/realpath.c:71 src/shred.c:169 src/stat.c:1488
#: src/touch.c:213
#, c-format
msgid "Usage: %s [OPTION]... FILE...\n"
msgstr "Використання: %s [КЛЮЧ]... ФАЙЛ...\n"

#: src/readlink.c:63
msgid ""
"Print value of a symbolic link or canonical file name\n"
"\n"
msgstr ""
"Виводить значення символічного посилання або канонічну назву файла\n"
"\n"

#: src/readlink.c:65
msgid ""
"  -f, --canonicalize            canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively;\n"
"                                all but the last component must exist\n"
"  -e, --canonicalize-existing   canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                all components must exist\n"
msgstr ""
"  -f, --canonicalize            отримати канонічну назву файла шляхом\n"
"                                рекурсивного слідування по усім символьним\n"
"                                посиланням в усіх компонентах шляху;\n"
"                                всі компоненти пути, крім останнього,\n"
"                                повинні існувати\n"
"  -e, --canonicalize-existing   отримати канонічну назву файла шляхом\n"
"                                рекурсивного слідування по усім символьним\n"
"                                посиланням у кожній компоненті вказаного "
"пути;\n"
"                                всі компоненти шляху повинні існувати\n"

#: src/readlink.c:75
msgid ""
"  -m, --canonicalize-missing    canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                without requirements on components "
"existence\n"
"  -n, --no-newline              do not output the trailing delimiter\n"
"  -q, --quiet,\n"
"  -s, --silent                  suppress most error messages (on by "
"default)\n"
"  -v, --verbose                 report error messages\n"
"  -z, --zero                    end each output line with NUL, not newline\n"
msgstr ""
"  -m, --canonicalize-missing    отримати канонічну назва файла шляхом\n"
"                                рекурсивного слідування по усім символьним\n"
"                                посиланням в усіх компонентах шляху;\n"
"                                компоненти не обов'язково мають існувати\n"
"  -n, --no-newline              не виводити кінцевий роздільник\n"
"  -q, --quiet,\n"
"  -s, --silent                  не виводити повідомлення про помилки "
"(типово\n"
"                                 увімкнено)\n"
"  -v, --verbose                 повідомляти про помилки\n"
"  -z, --zero                    відокремлювати виведені рядки нуль-байтом,\n"
"                                 а не символом нового рядка\n"

#: src/readlink.c:152
#, c-format
msgid "ignoring --no-newline with multiple arguments"
msgstr "ігноруємо --no-newline з декількома аргументами"

#: src/realpath.c:72
msgid ""
"Print the resolved absolute file name;\n"
"all but the last component must exist\n"
"\n"
msgstr ""
"Вивести визначену абсолютну назву файла;\n"
"всі компоненти, окрім останньої, має бути вже створено\n"
"\n"

#: src/realpath.c:77
msgid ""
"  -e, --canonicalize-existing  all components of the path must exist\n"
"  -m, --canonicalize-missing   no path components need exist or be a "
"directory\n"
"  -L, --logical                resolve '..' components before symlinks\n"
"  -P, --physical               resolve symlinks as encountered (default)\n"
"  -q, --quiet                  suppress most error messages\n"
"      --relative-to=FILE       print the resolved path relative to FILE\n"
"      --relative-base=FILE     print absolute paths unless paths below FILE\n"
"  -s, --strip, --no-symlinks   don't expand symlinks\n"
"  -z, --zero                   end each output line with NUL, not newline\n"
"\n"
msgstr ""
"  -e, --canonicalize-existing  всі компоненти шляху мають існувати\n"
"  -m, --canonicalize-missing   не повинно існувати жодного компонента або "
"каталогу\n"
"  -L, --logical                обробляти компоненти '..' до символічних "
"посилань\n"
"  -P, --physical               обробляти символічні посилання (типово)\n"
"  -q, --quiet                  придушити більшість повідомлень про помилки\n"
"      --relative-to=ФАЙЛ       вивести визначений шлях відносно ФАЙЛа\n"
"      --relative-base=ФАЙЛ     вивести абсолютні шляхи, якщо вони не є "
"підлеглими ФАЙЛ\n"
"  -s, --strip, --no-symlinks   не розгортати символічні посилання\n"
"  -z, --zero                   відокремлювати частини результату NUL, а не "
"символом нового рядка\n"
"\n"

#: src/relpath.c:130
msgid "generating relative path"
msgstr "створення відносного шляху"

#: src/remove.c:272
#, c-format
msgid "%s: descend into write-protected directory %s? "
msgstr "%s: спуститься у захищений від запису каталог %s? "

#: src/remove.c:273
#, c-format
msgid "%s: descend into directory %s? "
msgstr "%s: спуститься у каталог %s? "

#. TRANSLATORS: In the next two strings the second %s is
#. replaced by the type of the file.  To avoid grammatical
#. problems, it may be more convenient to translate these
#. strings instead as: "%1$s: %3$s is write-protected and
#. is of type '%2$s' -- remove it? ".
#: src/remove.c:290
#, c-format
msgid "%s: remove write-protected %s %s? "
msgstr "%s: вилучити захищений від запису %s %s? "

#: src/remove.c:291
#, c-format
msgid "%s: remove %s %s? "
msgstr "%s: вилучити %s %s? "

#: src/remove.c:374
#, c-format
msgid "removed directory %s\n"
msgstr "вилучено каталог %s\n"

#: src/remove.c:446
#, c-format
msgid "refusing to remove %s or %s directory: skipping %s"
msgstr "відмовлено у вилученні каталогу %s або %s: пропускаємо %s"

#: src/remove.c:504
#, c-format
msgid "skipping %s, since it's on a different device"
msgstr "припущено %s, оскільки він розташований на іншому пристрої"

#: src/remove.c:524
#, c-format
msgid "traversal failed: %s"
msgstr "помилка під час обходу: %s"

#: src/remove.c:530
#, c-format
msgid ""
"unexpected failure: fts_info=%d: %s\n"
"please report to %s"
msgstr ""
"неочікувана помилка: fts_info=%d: %s\n"
"повідомте %s"

#: src/rm.c:118
#, c-format
msgid "Try '%s ./%s' to remove the file %s.\n"
msgstr "Спробуйте «%s ./%s», щоб вилучити файл %s.\n"

#: src/rm.c:135
msgid ""
"Remove (unlink) the FILE(s).\n"
"\n"
"  -f, --force           ignore nonexistent files and arguments, never "
"prompt\n"
"  -i                    prompt before every removal\n"
msgstr ""
"Вилучення ФАЙЛІВ (символічних посилань).\n"
"\n"
"  -f, --force           ігнорувати файли і аргументи, яких не існує, ніколи "
"не питати\n"
"  -i                    питати перед кожним вилученням\n"

#: src/rm.c:141
msgid ""
"  -I                    prompt once before removing more than three files, "
"or\n"
"                          when removing recursively; less intrusive than -"
"i,\n"
"                          while still giving protection against most "
"mistakes\n"
"      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or\n"
"                          always (-i); without WHEN, prompt always\n"
msgstr ""
"  -I                    питати перед вилученням більш ніж трьох файлів або\n"
"                          при рекурсивному вилученні.  Менш набридливий ніж\n"
"                          -i, хоча забезпечує захист від більшості помилок\n"
"      --interactive[=КОЛИ]  питати КОЛИ: never, once (-I), \n"
"                          always (-i).  Без значення КОЛИ — питати завжди\n"

#: src/rm.c:148
msgid ""
"      --one-file-system  when removing a hierarchy recursively, skip any\n"
"                          directory that is on a file system different from\n"
"                          that of the corresponding command line argument\n"
msgstr ""
"      --one-file-system  при вилученні ієрархії рекурсивно, пропускати\n"
"                          каталоги, що лежать на інших файлових системах,\n"
"                          ніж вказані аргументами командного рядку\n"

#: src/rm.c:153
msgid ""
"      --no-preserve-root  do not treat '/' specially\n"
"      --preserve-root   do not remove '/' (default)\n"
"  -r, -R, --recursive   remove directories and their contents recursively\n"
"  -d, --dir             remove empty directories\n"
"  -v, --verbose         explain what is being done\n"
msgstr ""
"      --no-preserve-root не обробляти / особливим чином\n"
"      --preserve-root   не вилучати / (типова поведінка)\n"
"  -r, -R, --recursive   рекурсивно вилучати каталоги та їх вміст\n"
"  -d, --dir             вилучати порожні каталоги\n"
"  -v, --verbose         пояснювати дії, що виконуються\n"

#: src/rm.c:162
msgid ""
"\n"
"By default, rm does not remove directories.  Use the --recursive (-r or -R)\n"
"option to remove each listed directory, too, along with all of its "
"contents.\n"
msgstr ""
"\n"
"Зазвичай rm не вилучає каталоги.  Використовуйте ключ --recursive (-r\n"
"або -R), щоб вилучити всі перелічені каталоги разом з їхнім\n"
"змістом.\n"

#: src/rm.c:167
#, c-format
msgid ""
"\n"
"To remove a file whose name starts with a '-', for example '-foo',\n"
"use one of these commands:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"
msgstr ""
"\n"
"Для вилучення файла, що починається з «-» (приклад: «-foo»),\n"
"використовуйте одну з наступних команд:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"

#: src/rm.c:176
msgid ""
"\n"
"Note that if you use rm to remove a file, it might be possible to recover\n"
"some of its contents, given sufficient expertise and/or time.  For greater\n"
"assurance that the contents are truly unrecoverable, consider using shred.\n"
msgstr ""
"\n"
"Зауважте, що при використанні rm для вилучення файла його вміст\n"
"зазвичай можна відновити. Використовуйте shred, якщо потрібна більша\n"
"впевненість у неможливості відновлення вмісту.\n"

#: src/rm.c:293
msgid "you may not abbreviate the --no-preserve-root option"
msgstr "не можна скорочувати параметр --no-preserve-root"

#: src/rm.c:344
#, c-format
msgid "%s: remove %<PRIuMAX> argument recursively? "
msgid_plural "%s: remove %<PRIuMAX> arguments recursively? "
msgstr[0] "%s: вилучити %<PRIuMAX> аргумент рекурсивно? "
msgstr[1] "%s: вилучити %<PRIuMAX> аргументи рекурсивно? "
msgstr[2] "%s: вилучити %<PRIuMAX> аргументів рекурсивно? "

#: src/rm.c:347
#, c-format
msgid "%s: remove %<PRIuMAX> argument? "
msgid_plural "%s: remove %<PRIuMAX> arguments? "
msgstr[0] "%s: вилучити %<PRIuMAX> аргумент? "
msgstr[1] "%s: вилучити %<PRIuMAX> аргументи? "
msgstr[2] "%s: вилучити %<PRIuMAX> аргументів? "

#: src/rmdir.c:133 src/rmdir.c:232
#, c-format
msgid "removing directory, %s"
msgstr "вилучення каталогу, %s"

#: src/rmdir.c:147
#, c-format
msgid "failed to remove directory %s"
msgstr "помилка при вилученні каталогу %s"

#: src/rmdir.c:164
msgid ""
"Remove the DIRECTORY(ies), if they are empty.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  ignore each failure that is solely because a directory\n"
"                    is non-empty\n"
msgstr ""
"Вилучає КАТАЛОГИ, якщо вони порожні.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  ігнорувати всі помилки, коли каталог не порожній\n"

#: src/rmdir.c:171
msgid ""
"  -p, --parents   remove DIRECTORY and its ancestors; e.g., 'rmdir -p a/b/c' "
"is\n"
"                    similar to 'rmdir a/b/c a/b a'\n"
"  -v, --verbose   output a diagnostic for every directory processed\n"
msgstr ""
"  -p, --parents   вилучити КАТАЛОГ і підлеглі каталоги. Наприклад, «rmdir -p "
"a/b/c»\n"
"                  робить те ж саме, що й «rmdir a/b/c a/b a».\n"
"  -v, --verbose   виводити повідомлення для кожного обробленого каталогу\n"

#: src/rmdir.c:241
#, c-format
msgid "failed to remove %s"
msgstr "не вдалося вилучити %s"

#: src/runcon.c:78
#, c-format
msgid ""
"Usage: %s CONTEXT COMMAND [args]\n"
"  or:  %s [ -c ] [-u USER] [-r ROLE] [-t TYPE] [-l RANGE] COMMAND [args]\n"
msgstr ""
"Використання: %s КОНТЕКСТ КОМАНДА [аргументи]\n"
"  або:  %s [ -c ] [-u КОРИСТУВАЧ] [-r РОЛЬ] [-t ТИП] [-l ДІАПАЗОН] КОМАНДА "
"[аргументи]\n"

#: src/runcon.c:82
msgid ""
"Run a program in a different SELinux security context.\n"
"With neither CONTEXT nor COMMAND, print the current security context.\n"
msgstr ""
"Запустити програму з іншим контекстом захисту SELinux.\n"
"якщо не вказано ні КОНТЕКСТ, ані КОМАНДА, виводиться поточний контекст "
"безпеки.\n"

#: src/runcon.c:89
msgid ""
"  CONTEXT            Complete security context\n"
"  -c, --compute      compute process transition context before modifying\n"
"  -t, --type=TYPE    type (for same role as parent)\n"
"  -u, --user=USER    user identity\n"
"  -r, --role=ROLE    role\n"
"  -l, --range=RANGE  levelrange\n"
"\n"
msgstr ""
"  КОНТЕКСТ              Повний контекст безпеки\n"
"  -c, --compute         обчислити процес переходу контексту перед зміною\n"
"  -t, --type=ТИП        тип (для тієї ж ролі, що й у батьківському)\n"
"  -u, --user=КОРИСТУВАЧ користувач\n"
"  -r, --role=РОЛЬ       роль\n"
"  -l, --range=ДІАПАЗОН  діапазон рівня\n"
"\n"

#: src/runcon.c:139
msgid "multiple roles"
msgstr "множинні ролей"

#: src/runcon.c:144
msgid "multiple types"
msgstr "множинні типи"

#: src/runcon.c:149
msgid "multiple users"
msgstr "множинні користувачі"

#: src/runcon.c:154
msgid "multiple levelranges"
msgstr "множинні діапазони"

#: src/runcon.c:172 src/runcon.c:208
msgid "failed to get current context"
msgstr "помилка при отриманні поточного контексту"

#: src/runcon.c:182
#, c-format
msgid "you must specify -c, -t, -u, -l, -r, or context"
msgstr "слід вказати -c, -t, -u, -l, -r, або контекст"

#: src/runcon.c:190
#, c-format
msgid "no command specified"
msgstr "не вказано команду"

#: src/runcon.c:195
#, c-format
msgid "%s may be used only on a SELinux kernel"
msgstr "%s можна використовувати лише у середовищі з підтримкою SELinux у ядрі"

#: src/runcon.c:222
msgid "failed to compute a new context"
msgstr "помилка при обчисленні нового контексту"

#: src/runcon.c:236
#, c-format
msgid "failed to set new user: %s"
msgstr "помилка при встановленні нового користувача: %s"

#: src/runcon.c:239
#, c-format
msgid "failed to set new type: %s"
msgstr "помилка при встановленні нового типу: %s"

#: src/runcon.c:242
#, c-format
msgid "failed to set new range: %s"
msgstr "помилка при встановленні нового діапазону: %s"

#: src/runcon.c:245
#, c-format
msgid "failed to set new role: %s"
msgstr "помилка при встановленні нової ролі: %s"

#: src/runcon.c:254
#, c-format
msgid "unable to set security context %s"
msgstr "не вдалося встановити контекст безпеки %s"

#: src/selinux.c:127 src/selinux.c:300
#, c-format
msgid "error canonicalizing %s"
msgstr "помилка під час спроби перетворити у канонічну форму %s"

#: src/seq.c:72
#, c-format
msgid ""
"Usage: %s [OPTION]... LAST\n"
"  or:  %s [OPTION]... FIRST LAST\n"
"  or:  %s [OPTION]... FIRST INCREMENT LAST\n"
msgstr ""
"Використання: %s [КЛЮЧ]... ОСТАННЄ\n"
"       або:    %s [КЛЮЧ]... ПЕРШЕ ОСТАННЄ\n"
"       або:    %s [КЛЮЧ]... ПЕРШЕ ПРИРІСТ ОСТАННЄ\n"

#: src/seq.c:77
msgid "Print numbers from FIRST to LAST, in steps of INCREMENT.\n"
msgstr "Виводить числа від ПЕРШОГО до ОСТАННЬОГО з кроком ПРИРІСТ.\n"

#: src/seq.c:83
msgid ""
"  -f, --format=FORMAT      use printf style floating-point FORMAT\n"
"  -s, --separator=STRING   use STRING to separate numbers (default: \\n)\n"
"  -w, --equal-width        equalize width by padding with leading zeroes\n"
msgstr ""
"  -f, --format ФОРМАТ      використовувати ФОРМАТ у стилі printf\n"
"  -s, --separator РЯДОК    використовувати РЯДОК як розділювач (типово \\n)\n"
"  -w, --equal-width        вирівнювати за шириною з додаванням початкових "
"нулів\n"

#: src/seq.c:90
msgid ""
"\n"
"If FIRST or INCREMENT is omitted, it defaults to 1.  That is, an\n"
"omitted INCREMENT defaults to 1 even when LAST is smaller than FIRST.\n"
"The sequence of numbers ends when the sum of the current number and\n"
"INCREMENT would become greater than LAST.\n"
"FIRST, INCREMENT, and LAST are interpreted as floating point values.\n"
"INCREMENT is usually positive if FIRST is smaller than LAST, and\n"
"INCREMENT is usually negative if FIRST is greater than LAST.\n"
"INCREMENT must not be 0; none of FIRST, INCREMENT and LAST may be NaN.\n"
msgstr ""
"\n"
"Якщо не вказані ПЕРШЕ або ПРИРІСТ, типово використовується 1. Тобто\n"
"ПРИРІСТ типово приймається за 1, навіть якщо ОСТАННІЙ менше\n"
"ПЕРШОГО. Послідовність обривається, коли сума поточного числа і\n"
"ПРИРОСТУ перевищує число ОСТАННІЙ.\n"
"ПЕРШИЙ, ОСТАННІЙ та ПРИРІСТ вважаються числами з рухомою\n"
"комою. ПРИРІСТ має бути додатним, якщо ПЕРШИЙ менше\n"
"ОСТАННЬОГО, та від'ємним у іншому випадку.\n"
"ПРИРІСТ має бути ненульовим; усі значення ПЕРШИЙ, ПРИРІСТ, ОСТАННІЙ\n"
"мають бути обчислюваними (не NaN).\n"

#: src/seq.c:101
msgid ""
"FORMAT must be suitable for printing one argument of type 'double';\n"
"it defaults to %.PRECf if FIRST, INCREMENT, and LAST are all fixed point\n"
"decimal numbers with maximum precision PREC, and to %g otherwise.\n"
msgstr ""
"ФОРМАТ повинен бути придатний для друку одного аргументу типу 'double';\n"
"типове значення %.PRECf якщо ПЕРШЕ, ПРИРІСТ, та ОСТАННЄ є числами \n"
"з плаваючою комою з максимальною точністю ТОЧН, та %g у іншому випадку.\n"

#: src/seq.c:147
#, c-format
msgid "invalid floating point argument: %s"
msgstr "неправильний аргумент з плаваючою комою: %s"

#: src/seq.c:153
#, c-format
msgid "invalid %s argument: %s"
msgstr "некоректний аргумент %s: %s"

#: src/seq.c:260
#, c-format
msgid "format %s has unknown %%%c directive"
msgstr "формат містить %s невідому директиву %%%c"

#: src/seq.c:628
#, c-format
msgid "format string may not be specified when printing equal width strings"
msgstr "при виводі рядків однакової ширини формат можна не вказувати"

#: src/seq.c:665
#, c-format
msgid "invalid Zero increment value: %s"
msgstr "некоректне нульове значення кроку збільшення: %s"

#: src/set-fields.c:169
msgid "invalid byte or character range"
msgstr "некоректний діапазон байтів або символів"

#: src/set-fields.c:170
msgid "invalid field range"
msgstr "некоректний діапазон полів"

#: src/set-fields.c:177 src/set-fields.c:223
msgid "byte/character positions are numbered from 1"
msgstr "позиції байтів та символів нумеруються з 1"

#: src/set-fields.c:178 src/set-fields.c:224
msgid "fields are numbered from 1"
msgstr "поля нумеруються з 1"

#: src/set-fields.c:198
msgid "invalid range with no endpoint: -"
msgstr "неправильний діапазон без кінцевого значення: -"

#: src/set-fields.c:212
msgid "invalid decreasing range"
msgstr "неприпустимий спадаючий діапазон"

#: src/set-fields.c:261
#, c-format
msgid "byte/character offset %s is too large"
msgstr "байтовий зсув або зсув символів %s надто великий"

#: src/set-fields.c:262
#, c-format
msgid "field number %s is too large"
msgstr "номер поля %s надто великий"

#: src/set-fields.c:273
#, c-format
msgid "invalid byte/character position %s"
msgstr "некоректна позиція байта або символу %s"

#: src/set-fields.c:274
#, c-format
msgid "invalid field value %s"
msgstr "некоректне значення поля, %s"

#: src/set-fields.c:282
msgid "missing list of byte/character positions"
msgstr "пропущено список позицій байтів або символів"

#: src/set-fields.c:283
msgid "missing list of fields"
msgstr "відсутній список полів"

#. This is a proper name. See the gettext manual, section Names.
#: src/shred.c:74
msgid "Colin Plumb"
msgstr "Colin Plumb"

#: src/shred.c:170
msgid ""
"Overwrite the specified FILE(s) repeatedly, in order to make it harder\n"
"for even very expensive hardware probing to recover the data.\n"
msgstr ""
"Перезаписує декілька раз вказані файли, щоб ускладнити відновлення\n"
"навіть з використанням дуже коштовного обладнання.\n"

#: src/shred.c:174
msgid ""
"\n"
"If FILE is -, shred standard output.\n"
msgstr ""
"\n"
"Якщо ФАЙЛ вказано як -, розрізати стандартне виведення.\n"

#: src/shred.c:181
#, c-format
msgid ""
"  -f, --force    change permissions to allow writing if necessary\n"
"  -n, --iterations=N  overwrite N times instead of the default (%d)\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -s, --size=N   shred this many bytes (suffixes like K, M, G accepted)\n"
msgstr ""
"  -f, --force    змінювати права, дозволяючи запис, якщо потрібно\n"
"  -n, --iterations=N  переписати N разів замість (%d) типово\n"
"      --random-source=ФАЙЛ  брати випадкові дані з ФАЙЛа\n"
"  -s, --size=N   очистити N байт (можливі суфікси, подібні до K, M, G)\n"

#: src/shred.c:187
msgid ""
"  -u             truncate and remove file after overwriting\n"
"      --remove[=HOW]  like -u but give control on HOW to delete;  See below\n"
"  -v, --verbose  show progress\n"
"  -x, --exact    do not round file sizes up to the next full block;\n"
"                   this is the default for non-regular files\n"
"  -z, --zero     add a final overwrite with zeros to hide shredding\n"
msgstr ""
"  -u             обрізати та вилучати файл після перезаписи\n"
"      --remove[=СПОСІБ]  подібне до -u, але надає змогу вказати спосіб "
"вилучення. Див. нижче.\n"
"  -v, --verbose  виводити поступ\n"
"  -x, --exact    не округляти розміри файлів до наступного цілого блоку;\n"
"                   типово для незвичних файлів\n"
"  -z, --zero     перезаписати у конці нулями, щоб сховати змішування\n"

#: src/shred.c:197
msgid ""
"\n"
"Delete FILE(s) if --remove (-u) is specified.  The default is not to remove\n"
"the files because it is common to operate on device files like /dev/hda,\n"
"and those files usually should not be removed.\n"
"The optional HOW parameter indicates how to remove a directory entry:\n"
"'unlink' => use a standard unlink call.\n"
"'wipe' => also first obfuscate bytes in the name.\n"
"'wipesync' => also sync each obfuscated byte to disk.\n"
"The default mode is 'wipesync', but note it can be expensive.\n"
"\n"
msgstr ""
"\n"
"Вилучає ФАЙЛИ, якщо вказано --remove (-u).  Типово файли не\n"
"вилучаються, оскільки часто обробляються файли-пристрої, подібні до\n"
"/dev/hda, а такі файли не треба вилучати.\n"
"За допомогою необов'язкового параметра СПОСІБ можна визначити спосіб "
"вилучення\n"
"запису каталогу:\n"
"'unlink' => використати стандартний виклик unlink.\n"
"'wipe' => також виконати змішування байтів у назві.\n"
"'wipesync' => також синхронізувати усі змішані байти з диском.\n"
"Типовим є режим 'wipesync', але варто пам'ятати, що цей режим може бути "
"доволі\n"
"вимогливим до ресурсів комп'ютера.\n"
"\n"

#: src/shred.c:209
msgid ""
"CAUTION: Note that shred relies on a very important assumption:\n"
"that the file system overwrites data in place.  This is the traditional\n"
"way to do things, but many modern file system designs do not satisfy this\n"
"assumption.  The following are examples of file systems on which shred is\n"
"not effective, or is not guaranteed to be effective in all file system "
"modes:\n"
"\n"
msgstr ""
"УВАГА: Пам'ятайте, що shred покладається на дуже важливе припущення:\n"
"що ваша файлова система перезаписує файли \"на місці\".\n"
"Зазвичай це так, але багато сучасних файлових системи\n"
"не задовольняють цьому припущенню.  Ось приклади файлових систем, на\n"
"яких shred не ефективний або не дає гарантії ефективності в усіх\n"
"режимах файлової системи:\n"
"\n"

#: src/shred.c:217
msgid ""
"* log-structured or journaled file systems, such as those supplied with\n"
"AIX and Solaris (and JFS, ReiserFS, XFS, Ext3, etc.)\n"
"\n"
"* file systems that write redundant data and carry on even if some writes\n"
"fail, such as RAID-based file systems\n"
"\n"
"* file systems that make snapshots, such as Network Appliance's NFS server\n"
"\n"
msgstr ""
"* файлові системи з журналом, наприклад які йдуть у комплекті\n"
"  AIX та Solaris (та JFS, ReiserFS, XFS, Ext3 та ін.)\n"
"\n"
"* файлові системи, які записують надлишкові дані та зберігають\n"
"  працездатність навіть якщо виникають невдалі записи, наприклад\n"
"  файлові системи, що побудовані на технології RAID\n"
"\n"
"* файлові системи, які створюють копії стану, наприклад\n"
"  NFS-сервер від Network Appliance\n"
"\n"

#: src/shred.c:227
msgid ""
"* file systems that cache in temporary locations, such as NFS\n"
"version 3 clients\n"
"\n"
"* compressed file systems\n"
"\n"
msgstr ""
"* файлові системи, які кешують файли у тимчасових сховищах, наприклад \n"
"  клієнти NFS версії 3\n"
"\n"
"* стиснені файлові системи\n"
"\n"

#: src/shred.c:234
msgid ""
"In the case of ext3 file systems, the above disclaimer applies\n"
"(and shred is thus of limited effectiveness) only in data=journal mode,\n"
"which journals file data in addition to just metadata.  In both the\n"
"data=ordered (default) and data=writeback modes, shred works as usual.\n"
"Ext3 journaling modes can be changed by adding the data=something option\n"
"to the mount options for a particular file system in the /etc/fstab file,\n"
"as documented in the mount man page (man mount).\n"
"\n"
msgstr ""
"В випадку файлових систем ext3 наведене вище обмеження вірне (тож,\n"
"shred не такий ефективний), лише у режимі\n"
"data=journal, коли окрім метаданих у журнал заносяться також самі дані\n"
"файлів.  В режимах data=ordered (типово) та data=writeback\n"
"програма shred працює у звичайному режимі.  Режими журналу ext3 можна\n"
"змінити, додавши ключ data=щось до параметрів підключення\n"
"конкретної файлової системи у файлі /etc/fstab, згідно документації на\n"
"сторінці man для mount (man mount).\n"

#: src/shred.c:244
msgid ""
"In addition, file system backups and remote mirrors may contain copies\n"
"of the file that cannot be removed, and that will allow a shredded file\n"
"to be recovered later.\n"
msgstr ""
"Окрім того, резервні копії та вилучені дзеркала файлової системи можуть\n"
"містити копії файла, які не можна вилучити, і які пізніше надають змогу\n"
"відновити знищений файл.\n"

#: src/shred.c:343
#, c-format
msgid "%s: fdatasync failed"
msgstr "%s: операція fdatasync завершилась невдало"

#: src/shred.c:354
#, c-format
msgid "%s: fsync failed"
msgstr "%s: операція fsync завершилась невдало"

#: src/shred.c:471
#, c-format
msgid "%s: cannot rewind"
msgstr "%s: не вдалося відкотитись"

#: src/shred.c:491
#, c-format
msgid "%s: pass %lu/%lu (%s)..."
msgstr "%s: прохід %lu/%lu (%s)..."

#: src/shred.c:542
#, c-format
msgid "%s: error writing at offset %s"
msgstr "%s: помилка записи за зсувом %s"

#: src/shred.c:563
#, c-format
msgid "%s: lseek failed"
msgstr "%s: операція lseek завершилась помилкою"

#: src/shred.c:575
#, c-format
msgid "%s: file too large"
msgstr "%s: файл надто великий"

#: src/shred.c:599
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s"
msgstr "%s: прохід %lu/%lu (%s)...%s"

#: src/shred.c:615
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s/%s %d%%"
msgstr "%s: прохід %lu/%lu (%s)...%s/%s %d%%"

#: src/shred.c:874
#, c-format
msgid "%s: fstat failed"
msgstr "%s: операція fstat завершилась помилкою"

#: src/shred.c:885
#, c-format
msgid "%s: invalid file type"
msgstr "%s: неправильний тип файла"

#: src/shred.c:890
#, c-format
msgid "%s: file has negative size"
msgstr "%s: файл має від'ємний розмір"

#: src/shred.c:984 src/sort.c:960 src/split.c:471
#, c-format
msgid "%s: error truncating"
msgstr "%s: помилка при скороченні"

#: src/shred.c:1004
#, c-format
msgid "%s: fcntl failed"
msgstr "%s: операція fcntl завершилась помилкою"

#: src/shred.c:1009
#, c-format
msgid "%s: cannot shred append-only file descriptor"
msgstr "%s: не вдалося нарізати файловий дескриптор з лише з правом додавання"

#: src/shred.c:1093
#, c-format
msgid "%s: removing"
msgstr "%s:  вилучення"

#: src/shred.c:1117
#, c-format
msgid "%s: renamed to %s"
msgstr "%s: перейменований на %s"

#: src/shred.c:1140
#, c-format
msgid "%s: failed to remove"
msgstr "%s: не вдалося вилучити"

#: src/shred.c:1144
#, c-format
msgid "%s: removed"
msgstr "%s: вилучено"

#: src/shred.c:1151 src/shred.c:1194
#, c-format
msgid "%s: failed to close"
msgstr "%s: не вдалося закрити"

#: src/shred.c:1187
#, c-format
msgid "%s: failed to open for writing"
msgstr "%s: не вдалося відкрити для читання"

#: src/shred.c:1250
msgid "invalid number of passes"
msgstr "некоректна кількість проходів"

#: src/shred.c:1255 src/shuf.c:472 src/sort.c:4502
msgid "multiple random sources specified"
msgstr "вказано декілька форматів виводу"

#: src/shred.c:1269
msgid "invalid file size"
msgstr "некоректний розмір файла"

#: src/shuf.c:62
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]\n"
"  or:  %s -e [OPTION]... [ARG]...\n"
"  or:  %s -i LO-HI [OPTION]...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ФАЙЛ]\n"
"  або:  %s -e [КЛЮЧ]... [АРГУМЕНТ]...\n"
"  або:  %s -i НИЖ-ВИЩ [КЛЮЧ]...\n"

#: src/shuf.c:68
msgid "Write a random permutation of the input lines to standard output.\n"
msgstr "Виводить випадково переставлені вхідні рядки на стандартний вивід.\n"

#: src/shuf.c:75
msgid ""
"  -e, --echo                treat each ARG as an input line\n"
"  -i, --input-range=LO-HI   treat each number LO through HI as an input "
"line\n"
"  -n, --head-count=COUNT    output at most COUNT lines\n"
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -r, --repeat              output lines can be repeated\n"
msgstr ""
"  -e, --echo                вважати кожен АРГУМЕНТ вхідним рядком\n"
"  -i, --input-range=НИЖ-ВИЩ вважати числа від НИЖ до ВИЩ вхідним рядком\n"
"  -n, --head-lines=РЯДКІВ   виводити принаймні кількість РЯДКІВ\n"
"  -o, --output=ФАЙЛ         вивести результат у ФАЙЛ, а не стандартний "
"вивід\n"
"      --random-source=ФАЙЛ  випадкові дані з ФАЙЛа\n"
"  -r, --repeat              рядки у виведених даних можуть повторюватися\n"

#: src/shuf.c:226
msgid "too many input lines"
msgstr "занадто багато рядків вхідних даних"

#: src/shuf.c:428
msgid "multiple -i options specified"
msgstr "задано декілька ключів -i"

#: src/shuf.c:435 src/shuf.c:441 src/shuf.c:446
msgid "invalid input range"
msgstr "некоректний діапазон вхідних даних"

#: src/shuf.c:459
#, c-format
msgid "invalid line count: %s"
msgstr "некоректна кількість рядків: %s"

#: src/shuf.c:466 src/sort.c:4496
msgid "multiple output files specified"
msgstr "задано декілька файлів для виводу"

#: src/shuf.c:496
#, c-format
msgid "cannot combine -e and -i options"
msgstr "не можна одночасно використовувати ключі -e та -i"

#: src/shuf.c:580
msgid "no lines to repeat"
msgstr "немає рядків для повторення"

#: src/sleep.c:45
#, c-format
msgid ""
"Usage: %s NUMBER[SUFFIX]...\n"
"  or:  %s OPTION\n"
"Pause for NUMBER seconds.  SUFFIX may be 's' for seconds (the default),\n"
"'m' for minutes, 'h' for hours or 'd' for days.  Unlike most "
"implementations\n"
"that require NUMBER be an integer, here NUMBER may be an arbitrary floating\n"
"point number.  Given two or more arguments, pause for the amount of time\n"
"specified by the sum of their values.\n"
"\n"
msgstr ""
"Використання: %s ЧИСЛО[СУФІКС]\n"
"       або:    %s КЛЮЧ\n"
"Призупиняє виконання на вказане ЧИСЛО секунд.  СУФІКС може\n"
"приймати значення 's', що означає секунди (типове значення),\n"
"'m' -- хвилини, 'h' -- години та 'd' -- дні. На відміну від\n"
"інших реалізацій, які вимагають, щоб ЧИСЛО було цілим, тут воно\n"
"може бути довільним числом з плаваючою комою.\n"
"\n"

#: src/sleep.c:136 src/timeout.c:319
#, c-format
msgid "invalid time interval %s"
msgstr "неправильний інтервал часу %s"

#: src/sleep.c:147 src/tail.c:1263
msgid "cannot read realtime clock"
msgstr "не вдалося прочитати значення таймеру реального часу"

#: src/sort.c:428
msgid "Write sorted concatenation of all FILE(s) to standard output.\n"
msgstr "Вивести сортоване сполучення усіх ФАЙЛ(ів) на стандартний вивід.\n"

#: src/sort.c:435
msgid ""
"Ordering options:\n"
"\n"
msgstr ""
"Ключі, що вказують порядок:\n"
"\n"

#: src/sort.c:439
msgid ""
"  -b, --ignore-leading-blanks  ignore leading blanks\n"
"  -d, --dictionary-order      consider only blanks and alphanumeric "
"characters\n"
"  -f, --ignore-case           fold lower case to upper case characters\n"
msgstr ""
"  -b, --ignore-leading-blanks ігнорувати початкові пробіли\n"
"  -d, --dictionary-order      розглядати лише пропуски, літери та цифри\n"
"  -f, --ignore-case           ігнорувати регістр літер\n"

#: src/sort.c:445
msgid ""
"  -g, --general-numeric-sort  compare according to general numerical value\n"
"  -i, --ignore-nonprinting    consider only printable characters\n"
"  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n"
msgstr ""
"  -g, --general-numeric-sort  порівнювати числа у загальному форматі\n"
"  -i, --ignore-nonprinting    розглядати лише друковані знаки\n"
"  -M, --month-sort            порівнювати (невідомо) < 'JAN' < ... < 'DEC'\n"

#: src/sort.c:450
msgid ""
"  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n"
msgstr ""
"  -h, --human-numeric-sort    порівнювати значення у зручному для читання "
"форматі (приклад: 2к 1Г)\n"

#: src/sort.c:453
msgid ""
"  -n, --numeric-sort          compare according to string numerical value\n"
"  -R, --random-sort           shuffle, but group identical keys.  See "
"shuf(1)\n"
"      --random-source=FILE    get random bytes from FILE\n"
"  -r, --reverse               reverse the result of comparisons\n"
msgstr ""
"  -n, --numeric-sort          порівнювати числові значення рядків\n"
"  -R, --random-sort           перемішати, але згрупувати ідентичні ключі. "
"Див.shuf(1)\n"
"      --random-source=ФАЙЛ    випадкові дані з ФАЙЛА\n"
"  -r, --reverse               зворотний порядок порівняння\n"

#: src/sort.c:459
msgid ""
"      --sort=WORD             sort according to WORD:\n"
"                                general-numeric -g, human-numeric -h, month -"
"M,\n"
"                                numeric -n, random -R, version -V\n"
"  -V, --version-sort          natural sort of (version) numbers within text\n"
"\n"
msgstr ""
"      --sort=СЛОВО            сортувати відповідно до СЛОВО:\n"
"                                general-numeric -g, human-numeric -h, month -"
"M,\n"
"                                numeric -n, random -R, version -V\n"
"  -V, --version-sort          сортувати за номером версії\n"
"\n"

#: src/sort.c:467
msgid ""
"Other options:\n"
"\n"
msgstr ""
"Інші параметри:\n"
"\n"

#: src/sort.c:471
msgid ""
"      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
"                            for more use temp files\n"
msgstr ""
"      --batch-size=NMERGE   об'єднувати не більше NMERGE джерел введення "
"одразу;\n"
"                            для решти використовувати тимчасові файли\n"

#: src/sort.c:475
msgid ""
"  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
"  -C, --check=quiet, --check=silent  like -c, but do not report first bad "
"line\n"
"      --compress-program=PROG  compress temporaries with PROG;\n"
"                              decompress them with PROG -d\n"
msgstr ""
"  -c, --check, --check=diagnose-first перевіряти, чи сортовані вхідні\n"
"                   файли; не сортувати\n"
"  -C, --check=quiet, --check=silent як -c, але не повідомляти про перший\n"
"                   помилковий рядок\n"
"      --compress-program=ПРОГ  стискати тимчасові файли командою ПРОГ;\n"
"                   розпаковувати командою ПРОГ -d\n"

#: src/sort.c:482
msgid ""
"      --debug               annotate the part of the line used to sort,\n"
"                              and warn about questionable usage to stderr\n"
"      --files0-from=F       read input from the files specified by\n"
"                            NUL-terminated names in file F;\n"
"                            If F is - then read names from standard input\n"
msgstr ""
"      --debug               коментувати частину рядка, використану для\n"
"                              впорядковування, попереджати щодо сумнівного\n"
"                              використання до stderr\n"
"      --files0-from=Ф       читати вхідні дані з файлів, вказаних за "
"допомогою\n"
"                            назв, відокремлених нуль-символом, у файлі Ф;\n"
"                            Якщо Ф — -, читати назви зі стандартного "
"джерела\n"
"                            вхідних даних\n"

#: src/sort.c:489
msgid ""
"  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
"  -m, --merge               merge already sorted files; do not sort\n"
msgstr ""
"  -k, --key=ВИЗНКЛ          впорядкувати за ключем, ВИЗНКЛ визначає місце і "
"тип\n"
"  -m, --merge               об'єднати вже впорядковані файли; не "
"впорядковувати\n"

#: src/sort.c:493
msgid ""
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"  -s, --stable              stabilize sort by disabling last-resort "
"comparison\n"
"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
msgstr ""
"  -o, --output=ФАЙЛ  виводити у ФАЙЛ, а не на стандартний вивід\n"
"  -s, --stable     стабілізувати сортування, виключивши перевірку на "
"рівність\n"
"  -S, --buffer-size=РОЗМІР\n"
"                   використовувати в пам'яті буфер вказаного РОЗМІРУ\n"

#: src/sort.c:499
#, c-format
msgid ""
"  -t, --field-separator=SEP  use SEP instead of non-blank to blank "
"transition\n"
"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or "
"%s;\n"
"                              multiple options specify multiple directories\n"
"      --parallel=N          change the number of sorts run concurrently to "
"N\n"
"  -u, --unique              with -c, check for strict ordering;\n"
"                              without -c, output only the first of an equal "
"run\n"
msgstr ""
"  -t, --field-separator=РОЗДІЛЮВАЧ\n"
"                   використовувати при пошуку ключових полів РОЗДІЛЮВАЧ, а "
"не\n"
"                   перехід від непробільних знаків до пробільних\n"
"  -T, --temporary-directory=КАТАЛОГ\n"
"                   використовувати для тимчасових файлів КАТАЛОГ, а не "
"$TMPDIR\n"
"                   або %s; декілька таких ключів задають декілька каталогів\n"
"  -u, --unique     з -c, суворо перевіряти порядок;\n"
"                     без -c, виводити лише перше з кількох рівних\n"

#: src/sort.c:513
msgid ""
"\n"
"KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is "
"a\n"
"field number and C a character position in the field; both are origin 1, "
"and\n"
"the stop position defaults to the line's end.  If neither -t nor -b is in\n"
"effect, characters in a field are counted from the beginning of the "
"preceding\n"
"whitespace.  OPTS is one or more single-letter ordering options "
"[bdfgiMhnRrV],\n"
"which override global ordering options for that key.  If no key is given, "
"use\n"
"the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
"\n"
"SIZE may be followed by the following multiplicative suffixes:\n"
msgstr ""
"\n"
"ВИЗНКЛ вказується як П[.З][ПАРАМ][П[.З][ПАРАМ]] для початкової і\n"
"кінцевої позицій, де П -- номер поля, а З -- позиція\n"
"символу у цьому поле, відлік обох ведеться з 1, типовою кінцевою\n"
"позицією є позиція кінця рядка. Якщо не використано ні -t, ні -b,\n"
"відлік символів у полі вестиметься з початку попереднього полю пробілу.\n"
"ПАРАМ визначається одним або декількома параметрами впорядковування з\n"
"набору [bdfgiMhnRrV]. ПАРАМ перевизначає загальні параметри впорядковування\n"
"для відповідного ключа. Якщо поле ключа не вказано, як ключ буде\n"
"використано увесь рядок. Для діагностування помилкового використання ключів\n"
"скористайтеся параметром --debug.\n"
"\n"
"Після РОЗМІРУ можна вказувати такі суфікси-мультиплікатори:\n"

#: src/sort.c:526
msgid ""
"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
"\n"
"*** WARNING ***\n"
"The locale specified by the environment affects sort order.\n"
"Set LC_ALL=C to get the traditional sort order that uses\n"
"native byte values.\n"
msgstr ""
"% 1% пам'яті, b 1, k 1024 (типово), та так далі для M, G, T, P, E, Z, Y.\n"
"\n"
"*** ПОПЕРЕДЖЕННЯ ***\n"
"Встановлена в середовищі локаль впливає на порядок сортування.\n"
"Щоб отримати традиційний порядок, що використовує системні значення байт,\n"
"встановіть LC_ALL=C.\n"

#: src/sort.c:725
#, c-format
msgid "waiting for %s [-d]"
msgstr "очікування %s [-d]"

#: src/sort.c:730
#, c-format
msgid "%s [-d] terminated abnormally"
msgstr "%s [-d] аварійно завершений"

#: src/sort.c:884
#, c-format
msgid "cannot create temporary file in %s"
msgstr "не вдалося створити тимчасовий файл у %s"

#: src/sort.c:978 src/sort.c:2087 src/sort.c:3124 src/sort.c:3773
#: src/sort.c:3864 src/sort.c:3867
msgid "open failed"
msgstr "операція відкриття завершилась помилкою"

#: src/sort.c:998
msgid "fflush failed"
msgstr "операція fflush завершилась помилкою"

#: src/sort.c:1003 src/sort.c:2090 src/sort.c:4781
msgid "close failed"
msgstr "помилка закриття"

#: src/sort.c:1140
msgid "couldn't create temporary file"
msgstr "не вдалося створити тимчасовий файл"

#: src/sort.c:1179
#, c-format
msgid "couldn't create process for %s -d"
msgstr "неможливо створити процес для %s -d"

#: src/sort.c:1252
#, c-format
msgid "warning: cannot remove: %s"
msgstr "попередження, не вдалося вилучити: %s"

#: src/sort.c:1338
#, c-format
msgid "invalid --%s argument %s"
msgstr "некоректний аргумент --%s %s"

#: src/sort.c:1341
#, c-format
msgid "minimum --%s argument is %s"
msgstr "мінімальним аргументом --%s є %s"

#: src/sort.c:1356
#, c-format
msgid "--%s argument %s too large"
msgstr "аргумент --%s %s є занадто великим"

#: src/sort.c:1359
#, c-format
msgid "maximum --%s argument with current rlimit is %s"
msgstr "максимум --%s аргумент з поточним rlimit що дорівнює %s"

#: src/sort.c:1441
msgid "number in parallel must be nonzero"
msgstr "кількість паралельних впорядкувань має бути ненульовою"

#: src/sort.c:1526
msgid "stat failed"
msgstr "операція stat завершилась помилкою"

#: src/sort.c:1788
msgid "read failed"
msgstr "помилка читання"

#: src/sort.c:2105
#, c-format
msgid "string transformation failed"
msgstr "помилка перетворення рядків"

#: src/sort.c:2108
#, c-format
msgid "the untransformed string was %s"
msgstr "Рядок до перетворення %s"

#: src/sort.c:2271
#, c-format
msgid "^ no match for key\n"
msgstr "^ не знайдено збігів з ключем\n"

#: src/sort.c:2443
#, c-format
msgid "obsolescent key %s used; consider %s instead"
msgstr "використано застарілий ключ «%s»; вам варто скористатися ключем «%s»"

#: src/sort.c:2450
#, c-format
msgid "key %lu has zero width and will be ignored"
msgstr "ключ %lu має нульову ширину, його буде проігноровано"

#: src/sort.c:2459
#, c-format
msgid "leading blanks are significant in key %lu; consider also specifying 'b'"
msgstr "початкові пробіли у ключі %lu буде враховано; варто також вказати «b»"

#: src/sort.c:2472
#, c-format
msgid "key %lu is numeric and spans multiple fields"
msgstr "ключ %lu є числовим, він охоплює декілька полів"

#: src/sort.c:2504
#, c-format
msgid "option '-%s' is ignored"
msgid_plural "options '-%s' are ignored"
msgstr[0] "параметр «-%s» проігноровано"
msgstr[1] "параметри «-%s» проігноровано"
msgstr[2] "параметри «-%s» проігноровано"

#: src/sort.c:2510
#, c-format
msgid "option '-r' only applies to last-resort comparison"
msgstr "параметр «-r» застосовується лише у разі, якщо збігів не виявлено"

#: src/sort.c:2784 src/sort.c:2793
msgid "write failed"
msgstr "запис завершився помилкою"

#: src/sort.c:2836
#, c-format
msgid "%s: %s:%s: disorder: "
msgstr "%s: %s:%s: неправильний порядок: "

#: src/sort.c:2839
msgid "standard error"
msgstr "стандартна помилка"

#: src/sort.c:3758
msgid "cannot read"
msgstr "не вдалося прочитати"

#: src/sort.c:4037
#, c-format
msgid "%s: invalid field specification %s"
msgstr "%s: неправильна специфікація поля %s"

#: src/sort.c:4047
#, c-format
msgid "options '-%s' are incompatible"
msgstr "несумісні параметри '-%s'"

#: src/sort.c:4097
#, c-format
msgid "%s: invalid count at start of %s"
msgstr "%s: неправильний лічильник на початку %s"

#: src/sort.c:4356
msgid "invalid number after '-'"
msgstr "неправильне число після '-'"

#: src/sort.c:4363 src/sort.c:4449 src/sort.c:4477
msgid "invalid number after '.'"
msgstr "неправильне число після '.'"

#: src/sort.c:4376 src/sort.c:4482
msgid "stray character in field spec"
msgstr "зайвий знак у специфікації поля"

#: src/sort.c:4423
msgid "multiple compress programs specified"
msgstr "вказано декілька програм стискання"

#: src/sort.c:4440
msgid "invalid number at field start"
msgstr "неправильне число на початку поля"

#: src/sort.c:4444 src/sort.c:4472
msgid "field number is zero"
msgstr "нульовий номер поля"

#: src/sort.c:4453
msgid "character offset is zero"
msgstr "нульовий знаковий зсув"

#: src/sort.c:4468
msgid "invalid number after ','"
msgstr "неправильне число після ','"

#: src/sort.c:4518
msgid "empty tab"
msgstr "порожня табуляція"

#: src/sort.c:4611 src/wc.c:750
#, c-format
msgid "cannot read file names from %s"
msgstr "не вдалося прочитати назви файлів з %s"

#: src/sort.c:4633
#, c-format
msgid "%s:%lu: invalid zero-length file name"
msgstr "%s:%lu: некоректна нульова довжина назви файла"

#: src/sort.c:4639
#, c-format
msgid "no input from %s"
msgstr "немає вхідних даних з %s"

#: src/sort.c:4685
#, c-format
msgid "using %s sorting rules"
msgstr "використовуються правила впорядковування %s"

#: src/sort.c:4693
msgid "failed to set locale; "
msgstr "не вдалося встановити локаль; "

#: src/sort.c:4694
msgid "using simple byte comparison"
msgstr "використовується просте порівняння байтів"

#: src/sort.c:4726
#, c-format
msgid "extra operand %s not allowed with -%c"
msgstr "додатковий операнд %s не припустимий з -%c"

#: src/split.c:208
#, c-format
msgid "the suffix length needs to be at least %<PRIuMAX>"
msgstr "довжина суфікса не повинна бути меншою за %<PRIuMAX>"

#: src/split.c:225
#, c-format
msgid "Usage: %s [OPTION]... [FILE [PREFIX]]\n"
msgstr "Користування: %s [ПАРАМЕТР]... [ФАЙЛ [ПРЕФІКС]]\n"

#: src/split.c:229
msgid ""
"Output pieces of FILE to PREFIXaa, PREFIXab, ...;\n"
"default size is 1000 lines, and default PREFIX is 'x'.\n"
msgstr ""
"Вивести шматки ФАЙЛа до ПРЕФІКСaa, ПРЕФІКСab, ...;\n"
"Типовий розмір шматка — 1000 рядків, а типовий ПРЕФІКС — «x».\n"

#: src/split.c:237
#, c-format
msgid ""
"  -a, --suffix-length=N   generate suffixes of length N (default %d)\n"
"      --additional-suffix=SUFFIX  append an additional SUFFIX to file names\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of records per output file\n"
"  -d                      use numeric suffixes starting at 0, not "
"alphabetic\n"
"      --numeric-suffixes[=FROM]  same as -d, but allow setting the start "
"value\n"
"  -e, --elide-empty-files  do not generate empty output files with '-n'\n"
"      --filter=COMMAND    write to shell COMMAND; file name is $FILE\n"
"  -l, --lines=NUMBER      put NUMBER lines/records per output file\n"
"  -n, --number=CHUNKS     generate CHUNKS output files; see explanation "
"below\n"
"  -t, --separator=SEP     use SEP instead of newline as the record "
"separator;\n"
"                            '\\0' (zero) specifies the NUL character\n"
"  -u, --unbuffered        immediately copy input to output with '-n r/...'\n"
msgstr ""
"  -a, --suffix-length=N   використовувати суфікси довжини N (типово %d)\n"
"      --additional-suffix=СУФІКС  дописувати СУФІКС до назв файлів\n"
"  -b, --bytes=ЧИСЛО       записувати у кожен файл виводу вказане ЧИСЛО "
"байтів\n"
"  -C, --line-bytes=ЧИСЛО  записувати не більше вказаного ЧИСЛА байт з рядка\n"
"  -d                      використовувати числові суфікси, починаючи з 0 "
"замість літерних\n"
"      --numeric-suffixes[=ПОЧАТОК] те саме, що і -d, але із можливістю "
"вказати\n"
"                           початкове значення\n"
"  -e, --elide-empty-files  не створювати порожніх файлів результатів, якщо "
"вказано -n\n"
"      --filter=КОМАНДА    записувати КОМАНДУ до оболонки; назвою файла є "
"$FILE\n"
"  -l, --lines=ЧИСЛО       записувати у кожен файл виводу вказане ЧИСЛО "
"рядків\n"
"  -n, --number=КІЛЬКІСТЬ  створити КІЛЬКІСТЬ фрагментів виведення. Див. "
"нижче.\n"
"  -t, --separator=РОЗД    використовувати роздільник РОЗД замість розриву\n"
"                            рядка для відокремлення записів;\n"
"                            '\\0' (нуль) визначає символ NUL\n"
"  -u, --unbuffered        копіювати вхідні дані безпосередньо до виведення з "
"«-n r/...»\n"

#: src/split.c:253
msgid ""
"      --verbose           print a diagnostic just before each\n"
"                            output file is opened\n"
msgstr ""
"      --verbose           виводити діагностичні повідомлення\n"
"                          перед відкриттям кожного файла виводу\n"

#: src/split.c:260
msgid ""
"\n"
"CHUNKS may be:\n"
"  N       split into N files based on size of input\n"
"  K/N     output Kth of N to stdout\n"
"  l/N     split into N files without splitting lines/records\n"
"  l/K/N   output Kth of N to stdout without splitting lines/records\n"
"  r/N     like 'l' but use round robin distribution\n"
"  r/K/N   likewise but only output Kth of N to stdout\n"
msgstr ""
"\n"
"ФРАГМЕНТИ можна задавати у форматі:\n"
"N       розділити на N файлів на основі розміру вхідних даних\n"
"K/N     вивести K-ий з N до stdout\n"
"l/N     розділити на N файлів без поділу на рядки або записи\n"
"l/K/N   вивести K-ий з N до stdout без поділу на рядки або записи\n"
"r/N     подібно до «l», але з використанням циклічного перебирання\n"
"r/K/N   те саме, але вивести лише K-ий з N до stdout\n"

#: src/split.c:447
msgid "output file suffixes exhausted"
msgstr "вичерпано суфікси для вихідних файлів"

#: src/split.c:459
#, c-format
msgid "creating file %s\n"
msgstr "створюється файл %s\n"

#: src/split.c:468
#, c-format
msgid "%s would overwrite input; aborting"
msgstr "%s перепише вхідні дані; перериваємо роботу"

#: src/split.c:484
msgid "failed to set FILE environment variable"
msgstr "не вдалося встановити змінну середовища FILE"

#: src/split.c:486
#, c-format
msgid "executing with FILE=%s\n"
msgstr "виконання з FILE=%s\n"

#: src/split.c:488
msgid "failed to create pipe"
msgstr "не вдалося створити канал"

#: src/split.c:502
msgid "closing prior pipe"
msgstr "закриття попереднього каналу"

#: src/split.c:504
msgid "closing output pipe"
msgstr "закриття каналу виведення"

#: src/split.c:508
msgid "moving input pipe"
msgstr "пересування каналу введення"

#: src/split.c:510
msgid "closing input pipe"
msgstr "закриття каналу введення"

#: src/split.c:515
#, c-format
msgid "failed to run command: \"%s -c %s\""
msgstr "не вдалося виконати команду: «%s -c %s»"

#: src/split.c:521
msgid "failed to close input pipe"
msgstr "не вдалося закрити канал вхідних даних"

#: src/split.c:557
msgid "waiting for child process"
msgstr "очікування на дочірній процес"

#: src/split.c:567
#, c-format
msgid "with FILE=%s, signal %s from command: %s"
msgstr "при FILE=%s, сигнал %s від команди: %s"

#: src/split.c:575
#, c-format
msgid "with FILE=%s, exit %d from command: %s"
msgstr "при FILE=%s, код виходу %d від команди: %s"

#: src/split.c:582
#, c-format
msgid "unknown status from command (0x%X)"
msgstr "невідомий стан від команди (0x%X)"

#: src/split.c:1262
#, c-format
msgid "cannot split in more than one way"
msgstr "не можна розбивати одразу кількома методами"

#: src/split.c:1274 src/split.c:1389 src/split.c:1584
msgid "invalid number of chunks"
msgstr "некоректна кількість фрагментів"

#: src/split.c:1279
msgid "invalid chunk number"
msgstr "некоректний номер фрагмента"

#: src/split.c:1326
msgid "invalid suffix length"
msgstr "некоректна довжина суфікса"

#: src/split.c:1400
msgid "empty record separator"
msgstr "порожній роздільник записів"

#: src/split.c:1411
#, c-format
msgid "multi-character separator %s"
msgstr "багатосимвольний роздільник %s"

#: src/split.c:1419
msgid "multiple separator characters specified"
msgstr "вказано декілька символів-роздільників"

#: src/split.c:1450
#, c-format
msgid "line count option -%s%c... is too large"
msgstr "ключ кількості рядків -%s%c... надто великий"

#: src/split.c:1462
#, c-format
msgid "%s: invalid start value for numerical suffix"
msgstr "%s: некоректне початкове значення у числовому суфіксі"

#: src/split.c:1486
msgid "invalid IO block size"
msgstr "некоректний розмір блоку введення-виведення"

#: src/split.c:1504
#, c-format
msgid "--filter does not process a chunk extracted to stdout"
msgstr "--filter не обробляє фрагменти, видобуті до stdout"

#: src/split.c:1544
#, c-format
msgid "numerical suffix start value is too large for the suffix length"
msgstr ""
"початкове значення числового суфікса є занадто великим для довжини суфікса"

#: src/split.c:1576
#, c-format
msgid "%s: cannot determine file size"
msgstr "%s: не вдалося визначити розмір файла"

#. This is a proper name. See the gettext manual, section Names.
#: src/stat.c:180
msgid "Michael Meskes"
msgstr "Michael Meskes"

#: src/stat.c:938
#, c-format
msgid "failed to canonicalize %s"
msgstr "не вдалося перетворити у канонічну форму %s"

#: src/stat.c:1206
#, c-format
msgid "warning: unrecognized escape '\\%c'"
msgstr "попередження: керівна послідовність '\\%c' не розпізнана"

#: src/stat.c:1261
#, c-format
msgid "%s: invalid directive"
msgstr "%s: неправильна директива"

#: src/stat.c:1308
#, c-format
msgid "warning: backslash at end of format"
msgstr "попередження: зворотна похила риска наприкінці формату"

#: src/stat.c:1339
#, c-format
msgid "using %s to denote standard input does not work in file system mode"
msgstr ""
"використання %s для позначення стандартного введення не працює у режимі "
"файлової системи"

#: src/stat.c:1346
#, c-format
msgid "cannot read file system information for %s"
msgstr "не вдалося прочитати інформацію файлової системи для %s"

#: src/stat.c:1367
#, c-format
msgid "cannot stat standard input"
msgstr "не вдалося виконати stat для стандартного джерела вхідних даних"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' with --file-system, and NOT from printf.
#: src/stat.c:1403
msgid ""
"  File: \"%n\"\n"
"    ID: %-8i Namelen: %-7l Type: %T\n"
"Block size: %-10s Fundamental block size: %S\n"
"Blocks: Total: %-10b Free: %-10f Available: %a\n"
"Inodes: Total: %-10c Free: %d\n"
msgstr ""
"  Файл: «%n»\n"
"   Ід.: %-8i Довжина назви: %-7l Тип: %T\n"
"Розмір блоку: %-10s Базовий розмір блоку: %S\n"
"Блоки: загалом: %-10b вільних: %-10f доступних: %a\n"
"Inode: загалом: %-10c вільних: %d\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1426
msgid ""
"  File: %N\n"
"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
msgstr ""
"  Файл: %N\n"
"  Розмір: %-10s\tБлоків: %-10b Блок в/в: %-6o %F\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1436
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %-5h Device type: %t,%T\n"
msgstr "Пристрій: %Dh/%dd\tInode: %-10i  Посилання: %-5h Тип пристрою: %t,%T\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1444
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
msgstr "Пристрій: %Dh/%dd\tInode: %-10i  Посилання: %h\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1453
msgid "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
msgstr "Доступ: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1463
#, c-format
msgid "Context: %C\n"
msgstr "Контекст: %C\n"

#: src/stat.c:1471
msgid ""
"Access: %x\n"
"Modify: %y\n"
"Change: %z\n"
" Birth: %w\n"
msgstr ""
"Доступ: %x\n"
"Модиф.: %y\n"
" Зміна: %z\n"
"Створ.: %w\n"

#: src/stat.c:1489
msgid "Display file or file system status.\n"
msgstr "Показати файл або стан файлової системи.\n"

#: src/stat.c:1495
msgid ""
"  -L, --dereference     follow links\n"
"  -f, --file-system     display file system status instead of file status\n"
msgstr ""
"  -L, --dereference     слідувати за посиланням\n"
"  -f, --file-system     показати стан файлової системи, а не файла\n"

#: src/stat.c:1499
msgid ""
"  -c  --format=FORMAT   use the specified FORMAT instead of the default;\n"
"                          output a newline after each use of FORMAT\n"
"      --printf=FORMAT   like --format, but interpret backslash escapes,\n"
"                          and do not output a mandatory trailing newline;\n"
"                          if you want a newline, include \\n in FORMAT\n"
"  -t, --terse           print the information in terse form\n"
msgstr ""
"  -c  --format=ФОРМАТ   використовувати вказаний ФОРМАТ, а не типовий;\n"
"                          переводити рядок після кожного використання "
"ФОРМАТУ\n"
"      --printf=ФОРМАТ   як --format, але інтерпретувати керівні\n"
"                          послідовності і не переводити рядок наприкінці.\n"
"                          Якщо потрібно переведення рядка, вставте у ФОРМАТ "
"\\n.\n"
"  -t, --terse           виводити дані у компактній формі\n"

#: src/stat.c:1510
msgid ""
"\n"
"The valid format sequences for files (without --file-system):\n"
"\n"
"  %a   access rights in octal (note '#' and '0' printf flags)\n"
"  %A   access rights in human readable form\n"
"  %b   number of blocks allocated (see %B)\n"
"  %B   the size in bytes of each block reported by %b\n"
"  %C   SELinux security context string\n"
msgstr ""
"\n"
"Можливі форматні послідовності для файлів (без --file-system):\n"
"\n"
"  %a   права доступу у вісімковій формі (з врахуванням прапорців printf # і "
"0)\n"
"  %A   права доступу у текстовій формі\n"
"  %b   кількість виділених блоків (дивіться %B)\n"
"  %B   розмір блоку, що повідомляється %b, у байтах\n"
"  %C   рядок з контекстом безпеки SELinux\n"

#: src/stat.c:1519
msgid ""
"  %d   device number in decimal\n"
"  %D   device number in hex\n"
"  %f   raw mode in hex\n"
"  %F   file type\n"
"  %g   group ID of owner\n"
"  %G   group name of owner\n"
msgstr ""
"  %d   номер пристрою, десятковий\n"
"  %D   номер пристрою, шістнадцятковий\n"
"  %f   низькорівневий режим, шістнадцятковий\n"
"  %F   тип файла\n"
"  %g   ідентифікатор групи-власника\n"
"  %G   назва групи-власника\n"

#: src/stat.c:1527
msgid ""
"  %h   number of hard links\n"
"  %i   inode number\n"
"  %m   mount point\n"
"  %n   file name\n"
"  %N   quoted file name with dereference if symbolic link\n"
"  %o   optimal I/O transfer size hint\n"
"  %s   total size, in bytes\n"
"  %t   major device type in hex, for character/block device special files\n"
"  %T   minor device type in hex, for character/block device special files\n"
msgstr ""
"  %h   кількість жорстких посилань\n"
"  %i   кількість inode\n"
"  %m   точка монтування\n"
"  %n   назва файла\n"
"  %N   екранована назва файла, символьні посилання розіменовуються\n"
"  %o   оптимальний розмір блоку введення-виведення\n"
"  %s   повний розмір, у байтах\n"
"  %t   основний тип пристрою, шістнадцятковий, для спеціальних файлів "
"символьних або блокових пристроїв\n"
"  %T   другорядний тип пристрою, шістнадцятковий, для спеціальних файлів "
"символьних або блокових пристроїв\n"

#: src/stat.c:1538
msgid ""
"  %u   user ID of owner\n"
"  %U   user name of owner\n"
"  %w   time of file birth, human-readable; - if unknown\n"
"  %W   time of file birth, seconds since Epoch; 0 if unknown\n"
"  %x   time of last access, human-readable\n"
"  %X   time of last access, seconds since Epoch\n"
"  %y   time of last data modification, human-readable\n"
"  %Y   time of last data modification, seconds since Epoch\n"
"  %z   time of last status change, human-readable\n"
"  %Z   time of last status change, seconds since Epoch\n"
"\n"
msgstr ""
"  %u   ідентифікатор користувача-власника\n"
"  %U   ім'я користувача-власника\n"
"  %w   час створення файла у зручному для читання форматі; -, якщо "
"невідомий\n"
"  %W   час створення файла у секундах від початку Епохи; 0 якщо невідомий\n"
"  %x   час останньої доступу у зручному для читання форматі\n"
"  %X   час останньої доступу у секундах з початку Епохи\n"
"  %y   час останньої зміни у зручному для читання форматі\n"
"  %Y   час останньої зміни у секундах з початку Епохи\n"
"  %z   час останньої зміни у зручному для читання форматі\n"
"  %Z   час останньої зміни у секундах з початку Епохи\n"
"\n"

#: src/stat.c:1552
msgid ""
"Valid format sequences for file systems:\n"
"\n"
"  %a   free blocks available to non-superuser\n"
"  %b   total data blocks in file system\n"
"  %c   total file nodes in file system\n"
"  %d   free file nodes in file system\n"
"  %f   free blocks in file system\n"
msgstr ""
"Можливі послідовності форматування для файлових систем:\n"
"\n"
"  %a   кількість вільних блоків, доступних для звичайного користувача\n"
"  %b   повна кількість блоків даних у файловій системі\n"
"  %c   повна кількість вузлів у файловій системі\n"
"  %d   кількість вільних файлових вузлів у файловій системі\n"
"  %f   кількість вільних блоків у файловій системі\n"

#: src/stat.c:1561
msgid ""
"  %i   file system ID in hex\n"
"  %l   maximum length of filenames\n"
"  %n   file name\n"
"  %s   block size (for faster transfers)\n"
"  %S   fundamental block size (for block counts)\n"
"  %t   file system type in hex\n"
"  %T   file system type in human readable form\n"
msgstr ""
"  %i   Ідентифікатор файлової системи, шістнадцятковий\n"
"  %l   Максимальна довжина назви файла\n"
"  %n   Назва файла\n"
"  %s   Розмір блоку (для швидшої передачі)\n"
"  %S   Фундаментальний розмір блоку (для обліку блоків)\n"
"  %t   Тип, шістнадцятковий\n"
"  %T   Тип у текстовій формі\n"

#: src/stdbuf.c:91
#, c-format
msgid "Usage: %s OPTION... COMMAND\n"
msgstr "Використання: %s ПАРАМЕТР... КОМАНДА\n"

#: src/stdbuf.c:92
msgid ""
"Run COMMAND, with modified buffering operations for its standard streams.\n"
msgstr ""
"Запускає КОМАНДУ зі зміненими діями з буферизації для стандартних потоків.\n"

#: src/stdbuf.c:98
msgid ""
"  -i, --input=MODE   adjust standard input stream buffering\n"
"  -o, --output=MODE  adjust standard output stream buffering\n"
"  -e, --error=MODE   adjust standard error stream buffering\n"
msgstr ""
"  -i, --input=РЕЖИМ  скоригувати буферизацію для потоку стандартного "
"введення\n"
"  -o, --output=РЕЖИМ скоригувати буферизацію для потоку стандартного "
"виведення\n"
"  -e, --error=РЕЖИМ  скоригувати буферизацію для потоку стандартних помилок\n"

#: src/stdbuf.c:105
msgid ""
"\n"
"If MODE is 'L' the corresponding stream will be line buffered.\n"
"This option is invalid with standard input.\n"
msgstr ""
"\n"
"Якщо РЕЖИМ дорівнює L, для відповідного потоку буде використано рядкову "
"буферизацію.\n"
"Цей параметр є некоректним для стандартного джерела даних.\n"

#: src/stdbuf.c:108
msgid ""
"\n"
"If MODE is '0' the corresponding stream will be unbuffered.\n"
msgstr ""
"\n"
"Якщо РЕЖИМ дорівнює 0, відповідний потік не буферизується.\n"

#: src/stdbuf.c:111
msgid ""
"\n"
"Otherwise MODE is a number which may be followed by one of the following:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n"
"In this case the corresponding stream will be fully buffered with the "
"buffer\n"
"size set to MODE bytes.\n"
msgstr ""
"\n"
"РЕЖИМ може бути числом, за яким вказано один з таких суфіксів:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024 тощо для G, T, P, E, Z, Y.\n"
"У такому разі відповідний потік буде повністю буферизовано зі встановленням\n"
"розміру буфера у РЕЖИМ байтів.\n"

#: src/stdbuf.c:117
msgid ""
"\n"
"NOTE: If COMMAND adjusts the buffering of its standard streams ('tee' does\n"
"for example) then that will override corresponding changes by 'stdbuf'.\n"
"Also some filters (like 'dd' and 'cat' etc.) don't use streams for I/O,\n"
"and are thus unaffected by 'stdbuf' settings.\n"
msgstr ""
"\n"
"ЗАУВАЖЕННЯ: якщо КОМАНДА сама коригує буферизацію стандартних потоків даних\n"
"(наприклад tee), перевизначає відповідні параметри, змінені stdbuf.\n"
"Крім того, деякі фільтри (зокрема dd і cat) не використовують потоки для\n"
"введення/виведення, отже параметри stdbuf на них не впливають.\n"

#: src/stdbuf.c:242
#, c-format
msgid "failed to find %s"
msgstr "не вдалося знайти %s"

#: src/stdbuf.c:266 src/stdbuf.c:300
#, c-format
msgid "failed to update the environment with %s"
msgstr "не вдалося оновити середовища за допомогою %s"

#: src/stdbuf.c:346
#, c-format
msgid "line buffering stdin is meaningless"
msgstr "рядкова буферизація stdin не має сенсу"

#: src/stdbuf.c:377
#, c-format
msgid "you must specify a buffering mode option"
msgstr "вам слід вказати параметр режиму буферизації"

#: src/stty.c:531
#, c-format
msgid ""
"Usage: %s [-F DEVICE | --file=DEVICE] [SETTING]...\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-a|--all]\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-g|--save]\n"
msgstr ""
"Використання: %s [-F ПРИСТРІЙ] [--file=ПРИСТРІЙ] [ПАРАМЕТР]...\n"
"       або    %s [-F ПРИСТРІЙ] [--file=ПРИСТРІЙ] [-a|--all]\n"
"       або    %s [-F ПРИСТРІЙ] [--file=ПРИСТРІЙ] [-g|--save]\n"

#: src/stty.c:537
msgid "Print or change terminal characteristics.\n"
msgstr "Виводить або змінює характеристики термінала.\n"

#: src/stty.c:543
msgid ""
"  -a, --all          print all current settings in human-readable form\n"
"  -g, --save         print all current settings in a stty-readable form\n"
"  -F, --file=DEVICE  open and use the specified DEVICE instead of stdin\n"
msgstr ""
"  -a, --all       вивести поточні параметри у текстовій формі\n"
"  -g, --save      вивести поточні параметри у формі, що зрозуміла програмі\n"
"                  stty\n"
"  -F, --file=ПРИСТРІЙ\n"
"                  відкрити та використовувати вказаний пристрій замість\n"
"                  стандартного вводу\n"

#: src/stty.c:550
msgid ""
"\n"
"Optional - before SETTING indicates negation.  An * marks non-POSIX\n"
"settings.  The underlying system defines which settings are available.\n"
msgstr ""
"\n"
"Необов'язковий знак мінус перед ПАРАМЕТРом означає зміну знаку.  Зірочкою\n"
"позначені параметри, не описані у стандарті POSIX.  Доступність того чи\n"
"іншого параметру визначається системою, що використовується.\n"

#: src/stty.c:555
msgid ""
"\n"
"Special characters:\n"
msgstr ""
"\n"
"Спеціальні символи:\n"

#: src/stty.c:559
msgid " * discard CHAR  CHAR will toggle discarding of output\n"
msgstr " * discard СИМВОЛ СИМВОЛ перемикатиме відкидання виведення\n"

#: src/stty.c:564
msgid ""
" * dsusp CHAR    CHAR will send a terminal stop signal once input flushed\n"
msgstr ""
" * dsusp СИМВОЛ  СИМВОЛ надсилатиме сигнал зупинки термінала, щойно "
"введення\n"
"                 буде завершено\n"

#: src/stty.c:568
msgid ""
"   eof CHAR      CHAR will send an end of file (terminate the input)\n"
"   eol CHAR      CHAR will end the line\n"
msgstr ""
"  eof СИМВОЛ      СИМВОЛ буде означати кінець файла (припинення введення)\n"
"  eol СИМВОЛ      СИМВОЛ буде означати кінець рядка\n"

#: src/stty.c:573
msgid " * eol2 CHAR     alternate CHAR for ending the line\n"
msgstr " * eol2 СИМВОЛ   заміняти СИМВОЛ на кінець рядка\n"

#: src/stty.c:577
msgid ""
"   erase CHAR    CHAR will erase the last character typed\n"
"   intr CHAR     CHAR will send an interrupt signal\n"
"   kill CHAR     CHAR will erase the current line\n"
msgstr ""
"  erase СИМВОЛ    СИМВОЛ буде стирати останній введений до нього\n"
"  intr СИМВОЛ     СИМВОЛ буде надсилати сигнал переривання\n"
"  kill СИМВОЛ     СИМВОЛ буде стирати поточний рядок\n"

#: src/stty.c:583
msgid " * lnext CHAR    CHAR will enter the next character quoted\n"
msgstr " * lnext СИМВОЛ  СИМВОЛ вводитиме наступний символ у лапках\n"

#: src/stty.c:588
msgid " * status CHAR   CHAR will send an info signal\n"
msgstr " * status СИМВОЛ СИМВОЛ надсилатиме сигнал info\n"

#: src/stty.c:592
msgid "   quit CHAR     CHAR will send a quit signal\n"
msgstr "   quit СИМВОЛ   СИМВОЛ надсилатиме сигнал виходу\n"

#: src/stty.c:596
msgid " * rprnt CHAR    CHAR will redraw the current line\n"
msgstr " * rprnt СИМВОЛ  СИМВОЛ перемальовуватиме поточний рядок\n"

#: src/stty.c:600
msgid ""
"   start CHAR    CHAR will restart the output after stopping it\n"
"   stop CHAR     CHAR will stop the output\n"
"   susp CHAR     CHAR will send a terminal stop signal\n"
msgstr ""
"   start СИМВОЛ  СИМВОЛ перезапускатиме виведення після його зупинення\n"
"   stop СИМВОЛ   СИМВОЛ буде призупиняти ввід\n"
"   susp СИМВОЛ   СИМВОЛ буде надсилати терміналу сигнал зупинки\n"

#: src/stty.c:606
msgid " * swtch CHAR    CHAR will switch to a different shell layer\n"
msgstr " * swtch СИМВОЛ  СИМВОЛ перемикатиме на інший шар оболонки\n"

#: src/stty.c:611
msgid " * werase CHAR   CHAR will erase the last word typed\n"
msgstr "* werase СИМВОЛ   СИМВОЛ буде стирати останнє введене слово\n"

#: src/stty.c:615
msgid ""
"\n"
"Special settings:\n"
"   N             set the input and output speeds to N bauds\n"
msgstr ""
"\n"
"Спеціальні параметри:\n"
"   N             встановити швидкість введення та виведення у N бод\n"

#: src/stty.c:621
msgid ""
" * cols N        tell the kernel that the terminal has N columns\n"
" * columns N     same as cols N\n"
msgstr ""
"* cols N        повідомити ядру, що термінал має N позицій у рядку\n"
"* columns N     те саме, що і cols N\n"

#: src/stty.c:626
#, c-format
msgid ""
" * [-]drain      wait for transmission before applying settings (%s by "
"default)\n"
msgstr ""
" * [-]drain      зачекати на передавання, перш ніж застосовувати параметри "
"(типове значення: %s)\n"

#: src/stty.c:628
msgid "on"
msgstr "увімкнено"

#: src/stty.c:628
msgid "off"
msgstr "вимкнено"

#: src/stty.c:629
msgid "   ispeed N      set the input speed to N\n"
msgstr "   ispeed N      встановити швидкість надходження вхідних даних N\n"

#: src/stty.c:633
msgid " * line N        use line discipline N\n"
msgstr ""
" * line N        використовувати порядок передавання лінією зв’язку N\n"

#: src/stty.c:637
msgid ""
"   min N         with -icanon, set N characters minimum for a completed "
"read\n"
"   ospeed N      set the output speed to N\n"
msgstr ""
"   min N         використовується з -icanon, встановити Н мінімальним "
"числом\n"
"                 символів для завершення операції читання\n"
"   ospeed N      встановити швидкість виводу N\n"

#: src/stty.c:642
msgid ""
" * rows N        tell the kernel that the terminal has N rows\n"
" * size          print the number of rows and columns according to the "
"kernel\n"
msgstr ""
"* rows N        повідомити ядру, що термінал має N рядків\n"
"* size          вивести числа стовпчиків та рядків, відомі ядру\n"

#: src/stty.c:647
msgid ""
"   speed         print the terminal speed\n"
"   time N        with -icanon, set read timeout of N tenths of a second\n"
msgstr ""
"   speed         вивести швидкість термінала\n"
"   time N        використовується з -icanon, встановити часову межу для\n"
"                 операції читання рівним N десятим секунди\n"

#: src/stty.c:651
msgid ""
"\n"
"Control settings:\n"
"   [-]clocal     disable modem control signals\n"
"   [-]cread      allow input to be received\n"
msgstr ""
"\n"
"Параметри керування:\n"
"   [-]clocal     вимкнути сигнали керування модемом\n"
"   [-]cread      дозволити отримання вхідних даних\n"

#: src/stty.c:658
msgid " * [-]crtscts    enable RTS/CTS handshaking\n"
msgstr " * [-]crtscts    увімкнути узгодження RTS/CTS\n"

#: src/stty.c:663
msgid " * [-]cdtrdsr    enable DTR/DSR handshaking\n"
msgstr " * [-]cdtrdsr    увімкнути узгодження DTR/DSR\n"

#: src/stty.c:667
msgid "   csN           set character size to N bits, N in [5..8]\n"
msgstr ""
"   csN           встановити розмір символу у N бітів, N — число у діапазоні "
"[5..8]\n"

#: src/stty.c:670
msgid ""
"   [-]cstopb     use two stop bits per character (one with '-')\n"
"   [-]hup        send a hangup signal when the last process closes the tty\n"
"   [-]hupcl      same as [-]hup\n"
"   [-]parenb     generate parity bit in output and expect parity bit in "
"input\n"
"   [-]parodd     set odd parity (or even parity with '-')\n"
msgstr ""
"  [-]cstopb     два біти розділення у символі (один, якщо з '-')\n"
"  [-]hup        надсилати сигнал обриву термінальної лінії, коли останній\n"
"                процес закриває термінал\n"
"  [-]hupcl      синонім [-]hup\n"
"  [-]parenb     генерувати при виводі біт парності та очікувати біт "
"парності\n"
"                на вводі\n"
"  [-]parodd     встановити перевірку на непарність (або парність, якщо з "
"'-')\n"

#: src/stty.c:678
msgid " * [-]cmspar     use \"stick\" (mark/space) parity\n"
msgstr ""
" * [-]cmspar     використовувати «жорстку» (із позначками і пробілами) "
"парність\n"

#: src/stty.c:682
msgid ""
"\n"
"Input settings:\n"
"   [-]brkint     breaks cause an interrupt signal\n"
"   [-]icrnl      translate carriage return to newline\n"
"   [-]ignbrk     ignore break characters\n"
"   [-]igncr      ignore carriage return\n"
"   [-]ignpar     ignore characters with parity errors\n"
msgstr ""
"\n"
"Параметри вводу:\n"
"   [-]brkint     символ break буде викликати сигнал переривання\n"
"   [-]icrnl      перетворювати переведення каретки у переведення рядка\n"
"   [-]ignbrk     ігнорувати символи переривання\n"
"   [-]igncr      ігнорувати символи переведення каретки\n"
"   [-]ignpar     ігнорувати символи із порушенням парності\n"

#: src/stty.c:692
msgid ""
" * [-]imaxbel    beep and do not flush a full input buffer on a character\n"
msgstr ""
" * [-]imaxbel    видавати гудок і не спорожнювати повний буфер введення у "
"відповідь на символ\n"

#: src/stty.c:696
msgid ""
"   [-]inlcr      translate newline to carriage return\n"
"   [-]inpck      enable input parity checking\n"
"   [-]istrip     clear high (8th) bit of input characters\n"
msgstr ""
"  [-]inlcr      перетворювати переведення рядка у переведення каретки\n"
"  [-]inpck      використовувати перевірку парності вводу\n"
"  [-]istrip     очищати старший (восьмий) біт символів, що вводяться\n"

#: src/stty.c:702
msgid " * [-]iutf8      assume input characters are UTF-8 encoded\n"
msgstr " * [-]iutf8      вважати, що вхідні знаки у кодуванні UTF-8\n"

#: src/stty.c:707
msgid " * [-]iuclc      translate uppercase characters to lowercase\n"
msgstr ""
" * [-]iuclc      перетворювати літери у верхньому регістрі на літери у "
"нижньому регістрі\n"

#: src/stty.c:712
msgid ""
" * [-]ixany      let any character restart output, not only start character\n"
msgstr ""
" * [-]ixany      дозволити будь-якому символу перезапускати виведення, не "
"лише початковому символу\n"

#: src/stty.c:716
msgid ""
"   [-]ixoff      enable sending of start/stop characters\n"
"   [-]ixon       enable XON/XOFF flow control\n"
"   [-]parmrk     mark parity errors (with a 255-0-character sequence)\n"
"   [-]tandem     same as [-]ixoff\n"
msgstr ""
"  [-]ixoff      дозволити надсилання символів призупинення/відновлення\n"
"  [-]ixon       дозволити керування потоком даних\n"
"  [-]parmrk     позначати помилки парності (послідовністю з 255 нуль-"
"символів)\n"
"  [-]tandem     синонім [-]xioff\n"

#: src/stty.c:722
msgid ""
"\n"
"Output settings:\n"
msgstr ""
"\n"
"Параметри виведення:\n"

#: src/stty.c:727
msgid " * bsN           backspace delay style, N in [0..1]\n"
msgstr ""
" * bsN           стиль затримки backspace, N — число у діапазоні [0..1]\n"

#: src/stty.c:732
msgid " * crN           carriage return delay style, N in [0..3]\n"
msgstr ""
" * crN           стиль затримки повернень каретки, N — число у діапазоні "
"[0..3]\n"

#: src/stty.c:737
msgid " * ffN           form feed delay style, N in [0..1]\n"
msgstr ""
" * ffN           стиль затримки посування сторінки, N — число у діапазоні "
"[0..1]\n"

#: src/stty.c:742
msgid " * nlN           newline delay style, N in [0..1]\n"
msgstr ""
" * nlN           стиль затримки розриву рядка, N — число у діапазоні [0..1]\n"

#: src/stty.c:747
msgid " * [-]ocrnl      translate carriage return to newline\n"
msgstr " * [-]ocrnl      перетворювати повернення каретки на розрив рядка\n"

#: src/stty.c:752
msgid ""
" * [-]ofdel      use delete characters for fill instead of NUL characters\n"
msgstr ""
" * [-]ofdel      використовувати для заповнення символи вилучення, а не "
"символи NUL\n"

#: src/stty.c:757
msgid ""
" * [-]ofill      use fill (padding) characters instead of timing for delays\n"
msgstr ""
" * [-]ofill      використовувати символи заповнення замість таймера для "
"затримок\n"

#: src/stty.c:762
msgid " * [-]olcuc      translate lowercase characters to uppercase\n"
msgstr ""
" * [-]olcuc      перетворювати літери у нижньому регістрі на літери у "
"верхньому регістрі\n"

#: src/stty.c:767
msgid " * [-]onlcr      translate newline to carriage return-newline\n"
msgstr ""
" * [-]onlcr      перетворювати розриви рядка на комбінації повернення "
"каретки і розриву рядка\n"

#: src/stty.c:772
msgid " * [-]onlret     newline performs a carriage return\n"
msgstr " * [-]onlret     розрив рядка призводить до повернення каретки\n"

#: src/stty.c:777
msgid " * [-]onocr      do not print carriage returns in the first column\n"
msgstr " * [-]onocr      не виводити повернення каретки у першу позицію\n"

#: src/stty.c:781
msgid "   [-]opost      postprocess output\n"
msgstr "   [-]opost      додатково виконувати завершальну обробку виведеного\n"

#: src/stty.c:785
msgid ""
" * tabN          horizontal tab delay style, N in [0..3]\n"
" * tabs          same as tab0\n"
" * -tabs         same as tab3\n"
msgstr ""
" * tabN          стиль затримки горизонтальної табуляції, N — число у "
"діапазоні [0..3]\n"
" * tabs          те саме, що і tab0\n"
" * -tabs         те саме, що і tab3\n"

#: src/stty.c:792
msgid " * vtN           vertical tab delay style, N in [0..1]\n"
msgstr ""
" * vtN           стиль затримки вертикальної табуляції, N — число у "
"діапазоні [0..1]\n"

#: src/stty.c:796
msgid ""
"\n"
"Local settings:\n"
"   [-]crterase   echo erase characters as backspace-space-backspace\n"
msgstr ""
"\n"
"Локальні параметри:\n"
"   [-]crterase   виводити символи erase як backspace-пробіл-backspace\n"

#: src/stty.c:802
msgid ""
" * crtkill       kill all line by obeying the echoprt and echoe settings\n"
" * -crtkill      kill all line by obeying the echoctl and echok settings\n"
msgstr ""
"* crtkill       стирати весь рядок, згідно з параметрами echoprt та echoe\n"
"* -crtkill      стирати весь рядок, згідно з параметрами echoctl та echok\n"

#: src/stty.c:808
msgid " * [-]ctlecho    echo control characters in hat notation ('^c')\n"
msgstr " * [-]ctlecho    виводити керівні символи з каре («^c»)\n"

#: src/stty.c:812
msgid "   [-]echo       echo input characters\n"
msgstr "   [-]echo       виводити введені символи\n"

#: src/stty.c:816
msgid " * [-]echoctl    same as [-]ctlecho\n"
msgstr " * [-]echoctl    те саме, що і [-]ctlecho\n"

#: src/stty.c:820
msgid ""
"   [-]echoe      same as [-]crterase\n"
"   [-]echok      echo a newline after a kill character\n"
msgstr ""
"   [-]echoe      те саме, що і [-]crterase\n"
"   [-]echok      виводити розрив рядка після символу знищення\n"

#: src/stty.c:825
msgid " * [-]echoke     same as [-]crtkill\n"
msgstr " * [-]echoke     те саме, що і [-]crtkill\n"

#: src/stty.c:829
msgid "   [-]echonl     echo newline even if not echoing other characters\n"
msgstr ""
"   [-]echonl     виводити розрив рядка, навіть якщо не копіюються інші "
"символи\n"

#: src/stty.c:833
msgid ""
" * [-]echoprt    echo erased characters backward, between '\\' and '/'\n"
msgstr " * [-]echoprt    виводити вилучені символи за курсор, між «\\» і «/»\n"

#: src/stty.c:838
msgid " * [-]extproc    enable \"LINEMODE\"; useful with high latency links\n"
msgstr ""
" * [-]extproc    увімкнути «лінійний режим»; корисно для посилань із високою "
"латентністю\n"

#: src/stty.c:843
msgid " * [-]flusho     discard output\n"
msgstr " * [-]flusho     відкинути виведені дані\n"

#: src/stty.c:847
#, c-format
msgid ""
"   [-]icanon     enable special characters: %s\n"
"   [-]iexten     enable non-POSIX special characters\n"
msgstr ""
"   [-]icanon     уможливити спеціальні символи: %s\n"
"   [-]iexten     уможливити спеціальні символи не з POSIX\n"

#: src/stty.c:858
msgid ""
"   [-]isig       enable interrupt, quit, and suspend special characters\n"
"   [-]noflsh     disable flushing after interrupt and quit special "
"characters\n"
msgstr ""
"  [-]isig       використовувати спецсимволи interrupt, quit, та suspend\n"
"  [-]noflsh     заборонити скидання буфера після переривання спецсимволами\n"
"                interrupt та quit\n"

#: src/stty.c:863
msgid " * [-]prterase   same as [-]echoprt\n"
msgstr " * [-]prterase   те саме, що [-]echoprt\n"

#: src/stty.c:868
msgid ""
" * [-]tostop     stop background jobs that try to write to the terminal\n"
msgstr ""
" * [-]tostop     зупинити фонові завдання, які намагаються виконати запис до "
"термінала\n"

#: src/stty.c:873
msgid ""
" * [-]xcase      with icanon, escape with '\\' for uppercase characters\n"
msgstr ""
" * [-]xcase      з icanon, екранування «\\» символів у верхньому регістрі\n"

#: src/stty.c:877
msgid ""
"\n"
"Combination settings:\n"
msgstr ""
"\n"
"Параметри поєднання:\n"

#: src/stty.c:882
msgid " * [-]LCASE      same as [-]lcase\n"
msgstr " * [-]LCASE      те саме, що [-]lcase\n"

#: src/stty.c:886
msgid ""
"   cbreak        same as -icanon\n"
"   -cbreak       same as icanon\n"
msgstr ""
"  cbreak        те саме, що -icanon\n"
"  -cbreak       те саме, що icanon\n"

#: src/stty.c:890
msgid ""
"   cooked        same as brkint ignpar istrip icrnl ixon opost isig\n"
"                 icanon, eof and eol characters to their default values\n"
"   -cooked       same as raw\n"
msgstr ""
"  cooked        те саме, що brkint ignpar istrip icrnl ixon opost isig,\n"
"                символи  icanon, eof та eol мають типове значення\n"
"  -cooked       те саме, що raw\n"

#: src/stty.c:895
#, c-format
msgid "   crt           same as %s\n"
msgstr "   crt           те саме, що %s\n"

#: src/stty.c:905
#, c-format
msgid ""
"   dec           same as %s intr ^c erase 0177\n"
"                 kill ^u\n"
msgstr ""
"   dec           те саме, що %s intr ^c erase 0177\n"
"                 kill ^u\n"

#: src/stty.c:920
msgid " * [-]decctlq    same as [-]ixany\n"
msgstr " * [-]decctlq    те саме, що [-]ixany\n"

#: src/stty.c:924
msgid ""
"   ek            erase and kill characters to their default values\n"
"   evenp         same as parenb -parodd cs7\n"
"   -evenp        same as -parenb cs8\n"
msgstr ""
"   ek            зводити символи erase і kill до типових значень\n"
"   evenp         те саме, що і parenb -parodd cs7\n"
"   -evenp        те саме, що і -parenb cs8\n"

#: src/stty.c:930
msgid " * [-]lcase      same as xcase iuclc olcuc\n"
msgstr " * [-]lcase      те саме, що xcase iuclc olcuc\n"

#: src/stty.c:934
msgid ""
"   litout        same as -parenb -istrip -opost cs8\n"
"   -litout       same as parenb istrip opost cs7\n"
msgstr ""
"   litout        те саме, що -parenb -istrip -opost cs8\n"
"   -litout       те саме, що parenb istrip opost cs7\n"

#: src/stty.c:938
#, c-format
msgid ""
"   nl            same as %s\n"
"   -nl           same as %s\n"
msgstr ""
"   nl            те саме, що %s\n"
"   -nl           те саме, що %s\n"

#: src/stty.c:956
msgid ""
"   oddp          same as parenb parodd cs7\n"
"   -oddp         same as -parenb cs8\n"
"   [-]parity     same as [-]evenp\n"
"   pass8         same as -parenb -istrip cs8\n"
"   -pass8        same as parenb istrip cs7\n"
msgstr ""
"  oddp          синонім parenb parodd cs7\n"
"  -oddp         синонім -parenb cs8\n"
"  [-]parity     синонім [-]evenp\n"
"  pass8         синонім -parenb -istrip cs8\n"
"  -pass8        синонім parenb istrip cs7\n"

#: src/stty.c:963
#, c-format
msgid ""
"   raw           same as -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                 -inlcr -igncr -icrnl -ixon -ixoff -icanon -opost\n"
"                 -isig%s min 1 time 0\n"
"   -raw          same as cooked\n"
msgstr ""
"  raw            те саме, що і -ignbrk -brkint -ignpar -parmrk -inpck -"
"istrip\n"
"                 -inlcr -igncr -icrnl -ixon -ixoff -icanon -opost\n"
"                 -isig%s min 1 time 0\n"
"  -raw           те саме, що і cooked\n"

#: src/stty.c:982
#, c-format
msgid ""
"   sane          same as cread -ignbrk brkint -inlcr -igncr icrnl\n"
"                 icanon iexten echo echoe echok -echonl -noflsh\n"
"                 %s\n"
"                 %s\n"
"                 %s,\n"
"                 all special characters to their default values\n"
msgstr ""
"   sane          те саме, що і cread -ignbrk brkint -inlcr -igncr icrnl\n"
"                 icanon iexten echo echoe echok -echonl -noflsh\n"
"                 %s\n"
"                 %s\n"
"                 %s,\n"
"                 усі спеціальні символи мають типові значення\n"

#: src/stty.c:1068
msgid ""
"\n"
"Handle the tty line connected to standard input.  Without arguments,\n"
"prints baud rate, line discipline, and deviations from stty sane.  In\n"
"settings, CHAR is taken literally, or coded as in ^c, 0x37, 0177 or\n"
"127; special values ^- or undef used to disable special characters.\n"
msgstr ""
"\n"
"Керує термінальною лінією, що підключена до стандартного вводу.  Запущена\n"
"без аргументів, виводить швидкість передачі інформації, line discipline та\n"
"відмінності від звичайних параметрів.  В параметрах, СИМВОЛИ трактуються\n"
"буквально або вказуються у як ^c, 0x37, 0177 або 127; для скасування\n"
"спеціальних символів служать значення ^- та undef.\n"

#: src/stty.c:1129 src/stty.c:1271
#, c-format
msgid "invalid argument %s"
msgstr "неправильний аргумент %s"

#: src/stty.c:1140 src/stty.c:1157 src/stty.c:1171 src/stty.c:1203
#: src/stty.c:1217 src/stty.c:1241
#, c-format
msgid "missing argument to %s"
msgstr "пропущений аргумент для %s"

#: src/stty.c:1193
#, c-format
msgid "%s: error setting %s"
msgstr "%s: помилка під час встановлення %s"

#: src/stty.c:1247
#, c-format
msgid "invalid line discipline %s"
msgstr "неправильна line discipline %s"

#: src/stty.c:1339
msgid "only one device may be specified"
msgstr "можна вказати лише одне пристрій"

#: src/stty.c:1373
msgid ""
"the options for verbose and stty-readable output styles are\n"
"mutually exclusive"
msgstr ""
"ключі для виводу у текстовому та виводі, зрозумілому програмі stty,\n"
"виключають один одного"

#: src/stty.c:1379
msgid "when specifying an output style, modes may not be set"
msgstr "при вказуванні стилю виводу не можна встановлювати режим"

#: src/stty.c:1397
#, c-format
msgid "%s: couldn't reset non-blocking mode"
msgstr "%s: не вдалося переініціалізувати неблокуючий режим"

#: src/stty.c:1460
#, c-format
msgid "%s: unable to perform all requested operations"
msgstr "%s: не вдалося виконати всі запитані дії"

#: src/stty.c:1806
#, c-format
msgid "%s: no size information for this device"
msgstr "%s: для цього пристрою немає відомостей про розмір"

#: src/stty.c:2341
msgid "invalid integer argument"
msgstr "некоректний цілий аргумент"

#. This is a proper name. See the gettext manual, section Names.
#: src/sum.c:38
msgid "Kayvan Aghaiepour"
msgstr "Kayvan Aghaiepour"

#: src/sum.c:63
msgid "Print checksum and block counts for each FILE.\n"
msgstr ""
"Виводить контрольну суму і кількість блоків для кожного ФАЙЛА.\n"
"\n"

#: src/sum.c:69
msgid ""
"\n"
"  -r              use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
msgstr ""
"\n"
"  -r              використовувати метод обчислення контрольних сум BSD,\n"
"                  розмір блоку 1 кБ\n"
"  -s, --sysv      використовувати метод обчислення контрольних сум System "
"V,\n"
"                  розмір блоку 512 байт\n"

#: src/sync.c:64
#, c-format
msgid "Usage: %s [OPTION] [FILE]...\n"
msgstr "Використання: %s [ПАРАМЕТР] [ФАЙЛ]...\n"

#: src/sync.c:65
msgid ""
"Synchronize cached writes to persistent storage\n"
"\n"
"If one or more files are specified, sync only them,\n"
"or their containing file systems.\n"
"\n"
msgstr ""
"Синхронізувати кешований запис на носій постійного зберігання\n"
"\n"
"Якщо вказано один або декілька файлів, синхронізувати лише ці файли\n"
"або файлові системи, які їх містять.\n"
"\n"

#: src/sync.c:73
msgid "  -d, --data             sync only file data, no unneeded metadata\n"
msgstr ""
"  -d, --data             синхронізувати лише дані файла, без непотрібних "
"метаданих\n"

#: src/sync.c:76
msgid "  -f, --file-system      sync the file systems that contain the files\n"
msgstr ""
"  -f, --file-system      синхронізувати файлові системи, що містять файли\n"

#: src/sync.c:114
#, c-format
msgid "error opening %s"
msgstr "помилка під час відкриття %s"

#: src/sync.c:124
#, c-format
msgid "couldn't reset non-blocking mode %s"
msgstr "не вдалося переініціалізувати режим без блокування %s"

#: src/sync.c:155
#, c-format
msgid "error syncing %s"
msgstr "помилка під час синхронізації %s"

#: src/sync.c:213
msgid "cannot specify both --data and --file-system"
msgstr "не можна одночасно використовувати параметри --data і --file-system"

#: src/sync.c:217
msgid "--data needs at least one argument"
msgstr "--data слід передати принаймні один аргумент"

#: src/system.h:344
#, c-format
msgid ""
"\n"
"NOTE: your shell may have its own version of %s, which usually supersedes\n"
"the version described here.  Please refer to your shell's documentation\n"
"for details about the options it supports.\n"
msgstr ""
"\n"
"ПРИМІТКА: ваша оболонка може надавати свою версію %s, яка\n"
"звичайно перекриває версію, описану тут.  Зверніться до\n"
"документації з вашої оболонки, щоб дізнатись, які ключі вона\n"
"підтримує.\n"

#: src/system.h:350
msgid "      --help     display this help and exit\n"
msgstr "      --help     показати цю довідку та вийти\n"

#: src/system.h:352
msgid "      --version  output version information and exit\n"
msgstr ""
"      --version  показати інформацію про версію та вийти\n"
"\n"

#: src/system.h:580
msgid ""
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"Якщо вхідний файл не вказаний, або якщо вказано символ -,\n"
"використовується стандартний ввід.\n"

#: src/system.h:587
msgid ""
"\n"
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"\n"
"Обов'язкові аргументи для довгих форм запису параметрів є обов'язковими і "
"для скорочених форм.\n"

#: src/system.h:595
msgid ""
"\n"
"The SIZE argument is an integer and optional unit (example: 10K is "
"10*1024).\n"
"Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n"
msgstr ""
"\n"
"РОЗМІР є цілим числом з додатковим значенням одиниці (приклад: 10K = "
"10*1024).\n"
"Одиницями можуть бути K, M, G, T, P, E, Z, Y (степені 1024) або KB, MB... "
"(степені 1000).\n"

#: src/system.h:604
#, c-format
msgid ""
"\n"
"Display values are in units of the first available SIZE from --block-size,\n"
"and the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\n"
"Otherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n"
msgstr ""
"\n"
"Показує значення у одиницях першого доступного РОЗМІРу з --block-size\n"
"та змінні середовища %s_BLOCK_SIZE, BLOCK_SIZE та BLOCKSIZE.\n"
"Якщо розмір не буде знайдено, типовою одиницею буде 1024 байтів\n"
"(або 512, якщо встановлено POSIXLY_CORRECT).\n"

#: src/system.h:614
msgid ""
"\n"
"The backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n"
"The version control method may be selected via the --backup option or "
"through\n"
"the VERSION_CONTROL environment variable.  Here are the values:\n"
"\n"
msgstr ""
"\n"
"Типовий суфікс для запасних копій ~, лише якщо не встановлена\n"
"змінна оточення SIMPLE_BACKUP_SUFFIX або ключ --suffix. Спосіб контролю\n"
"версій можна вказати ключем --backup або змінною оточення\n"
"VERSION_CONTROL. Можливі значення:\n"
"\n"

#: src/system.h:621
msgid ""
"  none, off       never make backups (even if --backup is given)\n"
"  numbered, t     make numbered backups\n"
"  existing, nil   numbered if numbered backups exist, simple otherwise\n"
"  simple, never   always make simple backups\n"
msgstr ""
"  none, off       ніколи не створювати резервних копій (навіть якщо\n"
"                  вказаний ключ --backup)\n"
"  numbered, t     створювати нумеровані копії\n"
"  existing, nil   якщо існують нумеровані копії, то створювати\n"
"                  нумеровані інакше створювати прості\n"
"  simple. never   завжди створювати прості копії\n"

#: src/system.h:651
#, c-format
msgid ""
"\n"
"%s online help: <%s>\n"
msgstr ""
"\n"
"Довідкові дані щодо %s у мережі: <%s>\n"

#. TRANSLATORS: Replace LANG_CODE in this URL with your language code
#. <http://translationproject.org/team/LANG_CODE.html> to form one of
#. the URLs at http://translationproject.org/team/.  Otherwise, replace
#. the entire URL with your translation team's email address.
#: src/system.h:662
#, c-format
msgid "Report %s translation bugs to <http://translationproject.org/team/>\n"
msgstr ""
"Повідомте %s про помилку у перекладі на <http://translationproject.org/team/"
">\n"

#: src/system.h:665
#, c-format
msgid "Full documentation at: <%s%s>\n"
msgstr "Документація повністю: <%s%s>\n"

#: src/system.h:667
#, c-format
msgid "or available locally via: info '(coreutils) %s%s'\n"
msgstr "вона ж доступна локально: info '(coreutils) %s%s'\n"

#: src/system.h:678
#, c-format
msgid "Try '%s --help' for more information.\n"
msgstr "Спробуйте '%s --help' для одержання додаткової інформації.\n"

#: src/system.h:722
#, c-format
msgid ""
"WARNING: Circular directory structure.\n"
"This almost certainly means that you have a corrupted file system.\n"
"NOTIFY YOUR SYSTEM MANAGER.\n"
"The following directory is part of the cycle:\n"
"  %s\n"
msgstr ""
"УВАГА: Зациклення у структурі каталогу.\n"
"Швидше за все, це означає, що ваша файлова система пошкоджена.\n"
"ПОВІДОМТЕ ВАШОГО СИСТЕМНОГО АДМІНІСТРАТОРА.\n"
"Наступний каталог є частиною циклу:\n"
" %s\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/tac.c:57
msgid "Jay Lepreau"
msgstr "Jay Lepreau"

#: src/tac.c:136
msgid "Write each FILE to standard output, last line first.\n"
msgstr "Вивести кожен ФАЙЛ до стандартного виведення, останній рядок першим.\n"

#: src/tac.c:143
msgid ""
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
msgstr ""
"  -b, --before             приєднати розділювач до початку, а не до кінця\n"
"  -r, --regex              сприймати розділювач як регулярний вираз\n"
"  -s, --separator=РЯДОК    вказати розділювачем РЯДОК, а не знак '\\n'\n"

#: src/tac.c:223 src/tac.c:233 src/tac.c:343
#, c-format
msgid "%s: seek failed"
msgstr "%s: помилка переміщення по файла"

#: src/tac.c:276
msgid "record too large"
msgstr "запис надто великий"

#: src/tac.c:458
#, c-format
msgid "failed to create temporary file in %s"
msgstr "не вдалося створити тимчасовий файл у %s"

#: src/tac.c:466
#, c-format
msgid "failed to open %s for writing"
msgstr "не вдалося відкрити %s для читання"

#: src/tac.c:484
#, c-format
msgid "failed to rewind stream for %s"
msgstr "не вдалося повернутися до початку потоку даних для %s"

#: src/tac.c:521 src/tac.c:533
#, c-format
msgid "%s: write error"
msgstr "%s: помилка запису"

#: src/tac.c:582
#, c-format
msgid "failed to open %s for reading"
msgstr "помилка при спробі відкрити %s для читання"

#: src/tac.c:650
msgid "separator cannot be empty"
msgstr "розділювач не може бути порожнім"

#. This is a proper name. See the gettext manual, section Names.
#: src/tail.c:74
msgid "Ian Lance Taylor"
msgstr "Ian Lance Taylor"

#: src/tail.c:262
#, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
msgstr ""
"Виводить останні %d рядків кожного з ФАЙЛІВ до стандартного виведення.\n"
"Якщо задано декілька ФАЙЛІВ, спочатку виводить перед даними заголовок із "
"назвою файла.\n"

#: src/tail.c:270
msgid ""
"  -c, --bytes=[+]NUM       output the last NUM bytes; or use -c +NUM to\n"
"                             output starting with byte NUM of each file\n"
msgstr ""
"  -c, --bytes=[+]ЧИСЛО     вивести вказану кількість останніх байтів;\n"
"                             -c +ЧИСЛО можна вказати, щоб виведення для\n"
"                             кожного файла починалося із байта ЧИСЛО\n"

#: src/tail.c:274
msgid ""
"  -f, --follow[={name|descriptor}]\n"
"                           output appended data as the file grows;\n"
"                             an absent option argument means 'descriptor'\n"
"  -F                       same as --follow=name --retry\n"
msgstr ""
"  -f, --follow[={name|descriptor}]\n"
"                           виводити дані, що надходять, при зростанні "
"файла;\n"
"                           -f, --follow та --follow=descriptor еквівалентні\n"
"  -F                       еквівалент --follow=name --retry\n"

#: src/tail.c:280
#, c-format
msgid ""
"  -n, --lines=[+]NUM       output the last NUM lines, instead of the last "
"%d;\n"
"                             or use -n +NUM to output starting with line "
"NUM\n"
"      --max-unchanged-stats=N\n"
"                           with --follow=name, reopen a FILE which has not\n"
"                             changed size after N (default %d) iterations\n"
"                             to see if it has been unlinked or renamed\n"
"                             (this is the usual case of rotated log files);\n"
"                             with inotify, this option is rarely useful\n"
msgstr ""
"  -n, --lines=[+]Н         виводити останні Н рядків, а не останні %d\n"
"                           скористайтеся -n +Н для виведення рядків з Н-го\n"
"      --max-unchanged-stats=Н\n"
"                           c ключем --follow=name, повторно відкривати\n"
"                           ФАЙЛ, який не змінився останні Н (типово %d)\n"
"                           ітерацій, щоб перевірити, чи не було його "
"вилучено\n"
"                           або перейменовано (таке звичайно буває при\n"
"                           ротації системних протокольних файлів)\n"
"                           З inotify цей параметр малокорисний.\n"

#: src/tail.c:293
msgid ""
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"      --retry              keep trying to open a file if it is inaccessible\n"
msgstr ""
"      --pid=PID            з ключем -f, перерватися, коли процес PID\n"
"                           завершує роботу\n"
"  -q, --quiet, --silent    не виводити заголовки з назвами файлів\n"
"      --retry              повторювати спроби відкрити файл, навіть якщо\n"
"                             доступ до нього буде втрачено\n"

#: src/tail.c:298
msgid ""
"  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\n"
"                             (default 1.0) between iterations;\n"
"                             with inotify and --pid=P, check process P at\n"
"                             least once every N seconds\n"
"  -v, --verbose            always output headers giving file names\n"
msgstr ""
"  -s, --sleep-interval=Н   з ключем -f, перевіряти отримання нових даних\n"
"                             приблизно кожні Н секунд (типово 1).\n"
"                             Якщо використано inotify і --pid=P, перевіряти\n"
"                             процес P принаймні кожні Н секунд.\n"
"  -v, --verbose            завжди виводити заголовки з назвами файлів\n"

#: src/tail.c:310
msgid ""
"\n"
"NUM may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"\n"
msgstr ""
"\n"
"Після ЧИСЛА блоків та байт може стоять один з множників:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024 тощо для T, P, E, Z, Y.\n"
"\n"

#: src/tail.c:317
msgid ""
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file in a way that accommodates renaming, removal and creation.\n"
msgstr ""
"З --follow (-f) tail типово слідкує за дескриптором файла, тобто, навіть "
"якщо\n"
"назву файла буде змінено, tail продовжуватиме стежити за його кінцем.\n"
"Така типова поведінка небажана, якщо ви хочете слідкувати за файлом, який\n"
"має певну назву, а не за дескриптором (наприклад файлом журналу, який\n"
"підлягає періодичній ротації). У такому разі використовуйте\n"
"--follow=name. Це змусить tail слідувати за вказаним файлом, беручи до "
"уваги\n"
"його перейменування, вилучення або створення.\n"

#: src/tail.c:369
#, c-format
msgid "closing %s (fd=%d)"
msgstr "закриття %s (fd=%d)"

#: src/tail.c:468
#, c-format
msgid "%s: cannot seek to end-relative offset %s"
msgstr "%s: не вдалося перемістити вказівник позиції на %s відносно кінця"

#: src/tail.c:903
#, c-format
msgid "cannot determine location of %s. reverting to polling"
msgstr ""
"не вдалося визначити розташування %s. Повертаємося до способу опитування"

#: src/tail.c:959
#, c-format
msgid "%s has been replaced with an untailable symbolic link"
msgstr "%s було замінено символічним посиланням, до якого tail незастосовний"

#: src/tail.c:974
#, c-format
msgid "%s has become inaccessible"
msgstr "%s став недоступний"

#: src/tail.c:992
#, c-format
msgid "%s has been replaced with an untailable file%s"
msgstr "%s було замінено файлом, до якого tail незастосовний%s"

#: src/tail.c:994 src/tail.c:1951
msgid "; giving up on this name"
msgstr "; припиняємо обробку на цій назві"

#: src/tail.c:1000
#, c-format
msgid "%s has been replaced with an untailable remote file"
msgstr "%s було замінено віддаленим файлом, до якого tail незастосовний"

#: src/tail.c:1021
#, c-format
msgid "%s has become accessible"
msgstr "%s став доступний"

#: src/tail.c:1033
#, c-format
msgid "%s has appeared;  following new file"
msgstr "З’явилося %s; виводимо новий файл"

#: src/tail.c:1043
#, c-format
msgid "%s has been replaced;  following new file"
msgstr "Замінено %s; виводимо новий файл"

#: src/tail.c:1160
#, c-format
msgid "%s: cannot change nonblocking mode"
msgstr "%s: не вдалося змінити неблокуючий режим"

#: src/tail.c:1206 src/tail.c:1373
#, c-format
msgid "%s: file truncated"
msgstr "%s: файл обрізаний"

#: src/tail.c:1240 src/tail.c:1573
#, c-format
msgid "no files remaining"
msgstr "більше немає файлів"

#: src/tail.c:1467
#, c-format
msgid "cannot watch parent directory of %s"
msgstr "не вдалося виконати спостереження за батьківським каталогом %s"

#: src/tail.c:1470 src/tail.c:1487 src/tail.c:1662
#, c-format
msgid "inotify resources exhausted"
msgstr "вичерпано ресурси inotify"

#: src/tail.c:1491 src/tail.c:1670
#, c-format
msgid "cannot watch %s"
msgstr "не вдалося виконати спостереження за %s"

#: src/tail.c:1540
#, c-format
msgid "%s was replaced"
msgstr "Замінено %s"

#: src/tail.c:1604
msgid "error monitoring inotify event"
msgstr "помилка під час стеження за подією inotify"

#: src/tail.c:1624
msgid "error reading inotify event"
msgstr "помилка під час спроби читання події inotify"

#: src/tail.c:1949
#, c-format
msgid "%s: cannot follow end of this type of file%s"
msgstr "%s: не можна стежити за кінцем файла такого типу%s"

#: src/tail.c:2130
msgid "invalid maximum number of unchanged stats between opens"
msgstr "некоректна максимальна кількість незмінених параметрів між відкриттями"

#: src/tail.c:2138
msgid "invalid PID"
msgstr "некоректний PID"

#: src/tail.c:2154
#, c-format
msgid "invalid number of seconds: %s"
msgstr "некоректна кількість секунд: %s"

#: src/tail.c:2173
#, c-format
msgid "option used in invalid context -- %c"
msgstr "параметр використовує неправильний контекст -- %c"

#: src/tail.c:2185
#, c-format
msgid "warning: --retry ignored; --retry is useful only when following"
msgstr ""
"попередження: --retry проігноровано; --retry корисний лише при слідуванні"

#: src/tail.c:2189
#, c-format
msgid "warning: --retry only effective for the initial open"
msgstr "попередження: --retry працюватиме лише для початкового відкриття"

#: src/tail.c:2194
#, c-format
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr ""
"попередження: PID ігнорований; ключ --pid=PID корисний лише при слідуванні"

#: src/tail.c:2197
#, c-format
msgid "warning: --pid=PID is not supported on this system"
msgstr "попередження: --pid=PID не підтримується на цій системі"

#: src/tail.c:2304
#, c-format
msgid "cannot follow %s by name"
msgstr "не вдалося слідувати за %s за назвою"

#: src/tail.c:2310
#, c-format
msgid "warning: following standard input indefinitely is ineffective"
msgstr "попередження: нескінченне стеження за стандартним вводом неефективне"

#: src/tail.c:2396
#, c-format
msgid "inotify cannot be used, reverting to polling"
msgstr "не можна використовувати inotify, повертаємося до способу опитування"

#: src/tee.c:88
msgid ""
"Copy standard input to each FILE, and also to standard output.\n"
"\n"
"  -a, --append              append to the given FILEs, do not overwrite\n"
"  -i, --ignore-interrupts   ignore interrupt signals\n"
msgstr ""
"Копіює стандартний ввід у кожен ФАЙЛ, а також у стандартний вивід.\n"
"\n"
"  -a, --append              дописати у вказані ФАЙЛИ\n"
"  -i, --ignore-interrupts   ігнорувати сигнали переривання\n"

#: src/tee.c:94
msgid ""
"  -p                        diagnose errors writing to non pipes\n"
"      --output-error[=MODE]   set behavior on write error.  See MODE below\n"
msgstr ""
"  -p                        діагностувати помилки, якщо запис ведеться не до "
"каналів обробки\n"
"      --output-error[=РЕЖИМ]  визначити поведінку під час запису помилок "
"Див. РЕЖИМ нижче\n"

#: src/tee.c:100
msgid ""
"\n"
"MODE determines behavior with write errors on the outputs:\n"
"  'warn'         diagnose errors writing to any output\n"
"  'warn-nopipe'  diagnose errors writing to any output not a pipe\n"
"  'exit'         exit on error writing to any output\n"
"  'exit-nopipe'  exit on error writing to any output not a pipe\n"
"The default MODE for the -p option is 'warn-nopipe'.\n"
"The default operation when --output-error is not specified, is to\n"
"exit immediately on error writing to a pipe, and diagnose errors\n"
"writing to non pipe outputs.\n"
msgstr ""
"\n"
"РЕЖИМ визначає поведінку у відповідь на помилки запису виведених даних:\n"
"  'warn'         діагностувати помилки запису до будь-якого виведення\n"
"  'warn-nopipe'  діагностувати помилки запису до будь-якого виведення, окрім "
"каналу обробки\n"
"  'exit'         виходити при помилках запису до будь-якого виведення\n"
"  'exit-nopipe'  виходити при помилках запису до будь-якого виведення, окрім "
"каналу обробки\n"
"Типовим значенням параметра РЕЖИМ для параметра -p є 'warn-nopipe'.\n"
"Типовою дією у відповідь, якщо не вказано --output-error, є негайне "
"завершення обробки,\n"
"якщо виявлено помилку запису до каналу обробки, та діагностування помилок "
"запису,\n"
"якщо запис виконувався не до каналу обробки.\n"

#: src/test.c:127
#, c-format
msgid "missing argument after %s"
msgstr "пропущений аргумент після %s"

#: src/test.c:163
#, c-format
msgid "invalid integer %s"
msgstr "неправильне ціле число %s"

#: src/test.c:245
#, c-format
msgid "%s expected"
msgstr "мало бути %s"

#: src/test.c:248
#, c-format
msgid "%s expected, found %s"
msgstr "мало бути %s, а маємо %s"

#: src/test.c:265 src/test.c:623
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: очікується унарний оператор"

#: src/test.c:334
msgid "-nt does not accept -l"
msgstr "-nt не допускає -l"

#: src/test.c:347
msgid "-ef does not accept -l"
msgstr "-ef не допускає -l"

#: src/test.c:363
msgid "-ot does not accept -l"
msgstr "-ot не допускає -l"

#: src/test.c:372
#, c-format
msgid "%s: unknown binary operator"
msgstr "%s: невідомий бінарний оператор"

#: src/test.c:651
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: очікується двійковий оператор"

#: src/test.c:709
msgid ""
"Usage: test EXPRESSION\n"
"  or:  test\n"
"  or:  [ EXPRESSION ]\n"
"  or:  [ ]\n"
"  or:  [ OPTION\n"
msgstr ""
"Використання: test ВИРАЗ\n"
"  або:  test\n"
"  або:  [ ВИРАЗ ]\n"
"  або:  [ ]\n"
"  або:  [ КЛЮЧ\n"

#: src/test.c:716
msgid ""
"Exit with the status determined by EXPRESSION.\n"
"\n"
msgstr "Вихідний статус визначається ВИРАЗОМ.\n"

#: src/test.c:722
msgid ""
"\n"
"An omitted EXPRESSION defaults to false.  Otherwise,\n"
"EXPRESSION is true or false and sets exit status.  It is one of:\n"
msgstr ""
"\n"
"Якщо ВИРАЗ не вказаний, він вважається хибним.  У іншому випадку\n"
"ВИРАЗ може бути істинним або хибним; він встановлює статус\n"
"завершення програми.  Код завершення визначається наступним образом:\n"

#: src/test.c:727
msgid ""
"\n"
"  ( EXPRESSION )               EXPRESSION is true\n"
"  ! EXPRESSION                 EXPRESSION is false\n"
"  EXPRESSION1 -a EXPRESSION2   both EXPRESSION1 and EXPRESSION2 are true\n"
"  EXPRESSION1 -o EXPRESSION2   either EXPRESSION1 or EXPRESSION2 is true\n"
msgstr ""
"\n"
"  ( ВИРАЗ )               ВИРАЗ істинний\n"
"  ! ВИРАЗ                 ВИРАЗ хибний\n"
"  ВИРАЗ1 -a ВИРАЗ2        ВИРАЗ1 та ВИРАЗ2 обидва істинні\n"
"  ВИРАЗ1 -o ВИРАЗ2        ВИРАЗ1 або ВИРАЗ2 істинний\n"

#: src/test.c:734
msgid ""
"\n"
"  -n STRING            the length of STRING is nonzero\n"
"  STRING               equivalent to -n STRING\n"
"  -z STRING            the length of STRING is zero\n"
"  STRING1 = STRING2    the strings are equal\n"
"  STRING1 != STRING2   the strings are not equal\n"
msgstr ""
"\n"
"  -n РЯДОК            довжина РЯДКА відмінна від нуля\n"
"  РЯДОК               еквівалентно -n РЯДОК\n"
"  -z РЯДОК            довжина РЯДКА дорівнює нулю\n"
"  РЯДОК1 = РЯДОК2     рядки еквівалентні\n"
"  РЯДОК1 != РЯДОК2    рядки не еквівалентні\n"

#: src/test.c:742
msgid ""
"\n"
"  INTEGER1 -eq INTEGER2   INTEGER1 is equal to INTEGER2\n"
"  INTEGER1 -ge INTEGER2   INTEGER1 is greater than or equal to INTEGER2\n"
"  INTEGER1 -gt INTEGER2   INTEGER1 is greater than INTEGER2\n"
"  INTEGER1 -le INTEGER2   INTEGER1 is less than or equal to INTEGER2\n"
"  INTEGER1 -lt INTEGER2   INTEGER1 is less than INTEGER2\n"
"  INTEGER1 -ne INTEGER2   INTEGER1 is not equal to INTEGER2\n"
msgstr ""
"\n"
"  ЦІЛЕ1 -eq ЦІЛЕ2   ЦІЛЕ1 дорівнює ЦІЛОМУ2\n"
"  ЦІЛЕ1 -ge ЦІЛЕ2   ЦІЛЕ1 більше або дорівнює ЦІЛОМУ2\n"
"  ЦІЛЕ1 -gt ЦІЛЕ2   ЦІЛЕ1 більше ЦІЛОГО2\n"
"  ЦІЛЕ1 -le ЦІЛЕ2   ЦІЛЕ1 менше або дорівнює ЦІЛОМУ2\n"
"  ЦІЛЕ1 -lt ЦІЛЕ2   ЦІЛЕ1 менше ЦІЛОГО2\n"
"  ЦІЛЕ1 -ne ЦІЛЕ2   ЦІЛЕ1 відмінне від ЦІЛОГО2\n"

#: src/test.c:751
msgid ""
"\n"
"  FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inode numbers\n"
"  FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2\n"
"  FILE1 -ot FILE2   FILE1 is older than FILE2\n"
msgstr ""
"\n"
"  ФАЙЛ1 -ef ФАЙЛ2   ФАЙЛ1 та ФАЙЛ2 мають одинакові пристрої та номери inode\n"
"  ФАЙЛ1 -nt ФАЙЛ2   ФАЙЛ1 змінювався пізніше ніж ФАЙЛ2\n"
"  ФАЙЛ1 -ot ФАЙЛ2   ФАЙЛ1 створений пізніше ніж ФАЙЛ2\n"

#: src/test.c:757
msgid ""
"\n"
"  -b FILE     FILE exists and is block special\n"
"  -c FILE     FILE exists and is character special\n"
"  -d FILE     FILE exists and is a directory\n"
"  -e FILE     FILE exists\n"
msgstr ""
"\n"
"  -b ФАЙЛ     ФАЙЛ існує та є спеціальним з блоковим доступом\n"
"  -c ФАЙЛ     ФАЙЛ існує та є спеціальним з символьним доступом\n"
"  -d ФАЙЛ     ФАЙЛ існує та є каталогом\n"
"  -e ФАЙЛ     ФАЙЛ існує\n"

#: src/test.c:764
msgid ""
"  -f FILE     FILE exists and is a regular file\n"
"  -g FILE     FILE exists and is set-group-ID\n"
"  -G FILE     FILE exists and is owned by the effective group ID\n"
"  -h FILE     FILE exists and is a symbolic link (same as -L)\n"
"  -k FILE     FILE exists and has its sticky bit set\n"
msgstr ""
"  -f ФАЙЛ     ФАЙЛ існує та є звичайним файлом\n"
"  -g ФАЙЛ     ФАЙЛ існує та має ознака set-group-ID\n"
"  -G ФАЙЛ     ФАЙЛ існує та належить поточної ефективній групі\n"
"  -h ФАЙЛ     ФАЙЛ існує та є символьним посиланням (еквівалент -L)\n"
"  -k ФАЙЛ     ФАЙЛ існує та має ознака sticky\n"

#: src/test.c:771
msgid ""
"  -L FILE     FILE exists and is a symbolic link (same as -h)\n"
"  -O FILE     FILE exists and is owned by the effective user ID\n"
"  -p FILE     FILE exists and is a named pipe\n"
"  -r FILE     FILE exists and read permission is granted\n"
"  -s FILE     FILE exists and has a size greater than zero\n"
msgstr ""
"  -L ФАЙЛ     ФАЙЛ існує та є символьним посиланням (еквівалент -h)\n"
"  -O ФАЙЛ     ФАЙЛ існує та належить поточному ефективному користувачу\n"
"  -p ФАЙЛ     ФАЙЛ існує та є іменованим каналом\n"
"  -r ФАЙЛ     ФАЙЛ існує доступний для читання\n"
"  -s ФАЙЛ     ФАЙЛ існує та має ненульовий розмір\n"

#: src/test.c:778
msgid ""
"  -S FILE     FILE exists and is a socket\n"
"  -t FD       file descriptor FD is opened on a terminal\n"
"  -u FILE     FILE exists and its set-user-ID bit is set\n"
"  -w FILE     FILE exists and write permission is granted\n"
"  -x FILE     FILE exists and execute (or search) permission is granted\n"
msgstr ""
"  -S ФАЙЛ     ФАЙЛ існує та є сокетом\n"
"  -t [ДФ]     дескриптор файла ДФ відкритий на терміналі\n"
"  -u ФАЙЛ     ФАЙЛ існує та має ознака set-user-ID\n"
"  -w ФАЙЛ     ФАЙЛ існує та доступний для запису\n"
"  -x ФАЙЛ     ФАЙЛ існує та є виконуваним\n"

#: src/test.c:785
msgid ""
"\n"
"Except for -h and -L, all FILE-related tests dereference symbolic links.\n"
"Beware that parentheses need to be escaped (e.g., by backslashes) for "
"shells.\n"
"INTEGER may also be -l STRING, which evaluates to the length of STRING.\n"
msgstr ""
"\n"
"Всі тести, що відносяться до ФАЙЛА, крім -h та -L розіменовують\n"
"символьні посилання.  Пам'ятайте, що ви повинні скасувати спеціальне\n"
"значення дужок для командного інтерпретатора (наприклад, за допомогою\n"
"знаку '\\').  ЦІЛЕ може також бути вказане як \"-l РЯДОК\", при цьому\n"
"воно приймає значення довжини РЯДКА.\n"

#: src/test.c:791
msgid ""
"\n"
"NOTE: Binary -a and -o are inherently ambiguous.  Use 'test EXPR1 && test\n"
"EXPR2' or 'test EXPR1 || test EXPR2' instead.\n"
msgstr ""
"\n"
"ЗАУВАЖЕННЯ: двійкові -a і -o є спадково неоднозначними. Слід користуватися\n"
"«test ВИРАЗ1 && test ВИРАЗ2» або «test ВИРАЗ1 || test ВИРАЗ2».\n"

#: src/test.c:796
msgid ""
"\n"
"NOTE: [ honors the --help and --version options, but test does not.\n"
"test treats each of those as it treats any other nonempty STRING.\n"
msgstr ""
"\n"
"ПРИМІТКА: [ притримується параметрів --help та --version options, але тест - "
"ні.\n"
"інтерпретує кожен з цих параметрів як будь-який непорожній рядок.\n"

#: src/test.c:801
msgid "test and/or ["
msgstr "test та/або ["

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:813
msgid "Kevin Braunsdorf"
msgstr "Kevin Braunsdorf"

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:814
msgid "Matthew Bradburn"
msgstr "Matthew Bradburn"

#: src/test.c:868
#, c-format
msgid "missing %s"
msgstr "пропущено %s"

#: src/test.c:882
#, c-format
msgid "extra argument %s"
msgstr "зайвий аргумент %s"

#: src/timeout.c:132
#, c-format
msgid "warning: timer_settime"
msgstr "попередження: timer_settime"

#: src/timeout.c:137
#, c-format
msgid "warning: timer_create"
msgstr "попередження: timer_create"

#: src/timeout.c:224
#, c-format
msgid ""
"Usage: %s [OPTION] DURATION COMMAND [ARG]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"Використання: %s [ПАРАМЕТР] ТРИВАЛІСТЬ КОМАНДА [АРГУМЕНТ]...\n"
"       або:    %s [ПАРАМЕТР]\n"

#: src/timeout.c:228
msgid "Start COMMAND, and kill it if still running after DURATION.\n"
msgstr ""
"Запустити КОМАНДУ і завершити її роботу, якщо її не буде завершено протягом "
"часу ТРИВАЛІСТЬ.\n"

#: src/timeout.c:234
msgid ""
"      --preserve-status\n"
"                 exit with the same status as COMMAND, even when the\n"
"                   command times out\n"
"      --foreground\n"
"                 when not running timeout directly from a shell prompt,\n"
"                   allow COMMAND to read from the TTY and get TTY signals;\n"
"                   in this mode, children of COMMAND will not be timed out\n"
"  -k, --kill-after=DURATION\n"
"                 also send a KILL signal if COMMAND is still running\n"
"                   this long after the initial signal was sent\n"
"  -s, --signal=SIGNAL\n"
"                 specify the signal to be sent on timeout;\n"
"                   SIGNAL may be a name like 'HUP' or a number;\n"
"                   see 'kill -l' for a list of signals\n"
msgstr ""
"      --preserve-status\n"
"                 вийти зі станом рівним стану КОМАНДИ, навіть якщо час\n"
"                 час очікування на завершення команди перевищено\n"
"      --foreground\n"
"                 Якщо timeout не запущено безпосередньо з командної "
"оболонки,\n"
"                 надати змогу КОМАНДІ читати дані з TTY і отримувати сигнали "
"TTY.\n"
"                 У цьому режимі дочірні процеси КОМАНДИ не підлягатимуть "
"обмеженню\n"
"                 часу очікування на завершення.\n"
"  -k, --kill-after=ТРИВАЛІСТЬ\n"
"                 надсилати сигнал KILL, якщо КОМАНДА не завершила роботу\n"
"                 протягом вказаного часу з надсилання початкового сигналу.\n"
"  -s, --signal=СИГНАЛ\n"
"                 вказати сигнал, який слід надсилати у разі перевищення "
"часу\n"
"                 очікування.\n"
"                 СИГНАЛом може бути назва, наприклад HUP, або число.\n"
"                 Переглянути список сигналів можна за допомогою команди\n"
"                 «kill -l»\n"

#: src/timeout.c:253
msgid ""
"\n"
"DURATION is a floating point number with an optional suffix:\n"
"'s' for seconds (the default), 'm' for minutes, 'h' for hours or 'd' for "
"days.\n"
msgstr ""
"\n"
"ТРИВАЛІСТЬ — число з плаваючою крапкою з додатковим суфіксом:\n"
"«s» — секунди (типовий), «m» — хвилини, «h» — години або «d» — дні.\n"

#: src/timeout.c:258
msgid ""
"\n"
"If the command times out, and --preserve-status is not set, then exit with\n"
"status 124.  Otherwise, exit with the status of COMMAND.  If no signal\n"
"is specified, send the TERM signal upon timeout.  The TERM signal kills\n"
"any process that does not block or catch that signal.  It may be necessary\n"
"to use the KILL (9) signal, since this signal cannot be caught, in which\n"
"case the exit status is 128+9 rather than 124.\n"
msgstr ""
"\n"
"Якщо час очікування на завершення команди буде перевищено, і не вказано\n"
"--preserve-status, вийти з кодом стану 124. Якщо цього не відбудеться,\n"
"вийти з кодом стану КОМАНДИ. Якщо сигналу не вказано, надіслати сигнал TERM\n"
"після перевищення часу очікування. Сигнал TERM перерве виконання будь-яких\n"
"процесів, які не блокують і не перехоплюють цей сигнал. Іншим\n"
"процесам слід насилати сигнал KILL (9), оскільки цей сигнал не може\n"
"бути перехоплено. Якщо надіслано сигнал KILL (9), станом виходу буде\n"
"128+9, а не 124.\n"

#: src/timeout.c:369 src/timeout.c:379
#, c-format
msgid "warning: sigprocmask"
msgstr "попередження: sigprocmask"

#: src/timeout.c:401
#, c-format
msgid "warning: disabling core dumps failed"
msgstr "попередження: спроба вимикання дампів ядра завершилася невдало"

#: src/timeout.c:515
#, c-format
msgid "error waiting for command"
msgstr "помилка під час очікування на команду"

#: src/timeout.c:526
#, c-format
msgid "the monitored command dumped core"
msgstr ""
"команда, за якою виконувалося спостереження, завершила роботу критичною "
"помилкою"

#: src/timeout.c:539
#, c-format
msgid "unknown status from command (%d)"
msgstr "невідомий стан завершення від команди (%d)"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:44
msgid "Jim Kingdon"
msgstr "Jim Kingdon"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:46
msgid "Randy Smith"
msgstr "Randy Smith"

#: src/touch.c:116 src/touch.c:310
#, c-format
msgid "invalid date format %s"
msgstr "неправильний формат дати %s"

#: src/touch.c:192
#, c-format
msgid "cannot touch %s"
msgstr "не вдалося виконати touch для %s"

#: src/touch.c:198
#, c-format
msgid "setting times of %s"
msgstr "встановлення тимчасових позначок %s"

#: src/touch.c:214
msgid ""
"Update the access and modification times of each FILE to the current time.\n"
"\n"
"A FILE argument that does not exist is created empty, unless -c or -h\n"
"is supplied.\n"
"\n"
"A FILE argument string of - is handled specially and causes touch to\n"
"change the times of the file associated with standard output.\n"
msgstr ""
"Оновити час доступу та час зміни кожного ФАЙЛА до поточної позначки часу.\n"
"\n"
"Якщо ФАЙЛа у аргументі не існує і не вказано -c або -h, його буде створено\n"
"порожнім.\n"
"\n"
"Якщо у аргументі ФАЙЛ вказано символ -, він обробляється особливим чином\n"
"та призводить до зміни позначки часу для файла, пов'язаного зі стандартним\n"
"виведенням даних.\n"

#: src/touch.c:226
msgid ""
"  -a                     change only the access time\n"
"  -c, --no-create        do not create any files\n"
"  -d, --date=STRING      parse STRING and use it instead of current time\n"
"  -f                     (ignored)\n"
msgstr ""
"  -a                     змінювати лише час доступу\n"
"  -c, --no-create        не створювати файлів\n"
"  -d, --date=РЯДОК       проаналізувати РЯДОК і використовувати його\n"
"                          замість поточного часу\n"
"  -f                     (ігнорується)\n"

#: src/touch.c:232
msgid ""
"  -h, --no-dereference   affect each symbolic link instead of any "
"referenced\n"
"                         file (useful only on systems that can change the\n"
"                         timestamps of a symlink)\n"
"  -m                     change only the modification time\n"
msgstr ""
"  -h, --no-dereference   впливає на символічне посилання, а не на файл,\n"
"                         на який вказує (діє лише на системі з підтримкою\n"
"                         зміни часових позначок символічних посилань)\n"
"  -m                     змірити лише час внесення змін\n"

#: src/touch.c:238
msgid ""
"  -r, --reference=FILE   use this file's times instead of current time\n"
"  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time\n"
"      --time=WORD        change the specified time:\n"
"                           WORD is access, atime, or use: equivalent to -a\n"
"                           WORD is modify or mtime: equivalent to -m\n"
msgstr ""
"  -r, --reference=ФАЙЛ   використовувати час ФАЙЛА замість поточного\n"
"  -t Час                 використовувати [[ВВ]РР]ММДДггхх[.сс] замість\n"
"                           поточного часу\n"
"  --time=СЛОВО           змінити вказаний час:\n"
"                          СЛОВО access, atime, use еквівалентно -a\n"
"                          СЛОВО modify, mtime еквівалентно -m\n"

#: src/touch.c:247
msgid ""
"\n"
"Note that the -d and -t options accept different time-date formats.\n"
msgstr ""
"\n"
"Зауважте, що ключі -d та -t сприймають різні формати дати та часу.\n"

#: src/touch.c:336
#, c-format
msgid "cannot specify times from more than one source"
msgstr "не вдалося вказати час з кількох джерел"

#: src/touch.c:410
#, c-format
msgid ""
"warning: 'touch %s' is obsolete; use 'touch -t %04ld%02d%02d%02d%02d.%02d'"
msgstr ""
"попередження: 'touch %s' застарів; використовуйте 'touch -t %04ld%02d%02d%02d"
"%02d.%02d'"

#: src/tr.c:287
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "Використання: %s [КЛЮЧ]... НАБІР1 [НАБІР2]\n"

#: src/tr.c:291
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, -C, --complement    use the complement of SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace each sequence of a repeated character\n"
"                            that is listed in the last specified SET,\n"
"                            with a single occurrence of that character\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
msgstr ""
"Перетворює, ущільнює та/або вилучає символи зі стандартного введення і\n"
"виводить їх до стандартного виведення.\n"
"\n"
"  -c, -C, --complement    спочатку отримати доповнення ТАБЛИЦІ1\n"
"  -d, --delete            вилучати знаки з ТАБЛИЦІ1, не перетворювати\n"
"  -s, --squeeze-repeats   заміщати послідовності знаків, що повторюються, з\n"
"                           перелічених у останній ТАБЛИЦІ, на єдиний такий "
"знак\n"
"  -t, --truncate-set1     спочатку вкоротити ТАБЛИЦЮ1 до розміру ТАБЛИЦІ2\n"

#: src/tr.c:304
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
msgstr ""
"\n"
"ТАБЛИЦі вказуються як символьні рядки.  У багатьох випадках символи\n"
"представляють самі себе.  Приймаються наступні послідовності:\n"
"\n"
"  \\ННН            знак з вісімковим кодом ННН (від 1 до 3 цифр)\n"
"  \\\\              зворотна похила риска\n"
"  \\a              звуковий сигнал\n"
"  \\b              забиття\n"
"  \\f              переведення сторінки\n"
"  \\n              новий рядок\n"
"  \\r              переведення каретки\n"
"  \\t              горизонтальна табуляція\n"

#: src/tr.c:318
msgid ""
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
msgstr ""
"  \\v              вертикальна табуляція\n"
"  ЗНАК1-ЗНАК2     всі знаки від ЗНАК1 до ЗНАК2 у порядку зростання\n"
"  [ЗНАК*]         ЗНАК заповнює ТАБЛИЦЮ2 до довжини ТАБЛИЦІ1\n"
"  [ЗНАК*ЧИСЛО]    вказане ЧИСЛО однакових ЗНАКІВ; ЧИСЛО вісімкових, якщо\n"
"                  починається з 0\n"
"  [:alnum:]       всі літери та цифри\n"
"  [:alpha:]       всі літери\n"
"  [:blank:]       всі горизонтальні пробільні символи\n"
"  [:cntrl:]       всі керівні знаки\n"
"  [:digit:]       всі цифри\n"

#: src/tr.c:329
msgid ""
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"  [:graph:]       всі друковані знаки, за винятком пробілу\n"
"  [:lower:]       всі маленькі літери\n"
"  [:print:]       всі друковані знаки, включно з пробілом\n"
"  [:punct:]       всі знаки пунктуації\n"
"  [:space:]       всі вертикальні або горизонтальні пробільні знаки\n"
"  [:upper:]       всі великі літери\n"
"  [:xdigit:]      всі шістнадцяткові цифри\n"
"  [=ЗНАК=]        всі знаки, еквівалентні ЗНАКУ\n"

#: src/tr.c:339
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  -s uses the last\n"
"specified SET, and occurs after translation or deletion.\n"
msgstr ""
"\n"
"Перетворення виконується, якщо не вказано -d і обох таблиць, ТАБЛИЦІ1\n"
"і ТАБЛИЦІ2. -t можна використовувати лише під час перетворення.\n"
"Якщо потрібно, ТАБЛИЦЮ2 буде розширено до розмірів ТАБЛИЦІ1\n"
"повторенням останнього символу. Зайві символи ТАБЛИЦІ2 буде пропущено.\n"
"Гарантовано розширюються у порядку зростання лише [:lower:] і [:upper:].\n"
"Використані у ТАБЛИЦІ2 під час перетворення символи можна використовувати\n"
"для визначення перетворення регістру лише у парах. -s використовує останню\n"
"вказану таблицю. Ущільнення відбувається після перетворення або\n"
"вилучення.\n"

#: src/tr.c:507
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, %c"
msgstr ""
"попередження: неоднозначна вісімкова послідовність \\%c%c%c трактується\n"
"як двобайтова послідовність \\0%c%c, %c"

#: src/tr.c:516
#, c-format
msgid "warning: an unescaped backslash at end of string is not portable"
msgstr ""
"попередження: неекранована зворотна похила риска наприкінці формату не є "
"переносимою"

#: src/tr.c:666
#, c-format
msgid "range-endpoints of '%s-%s' are in reverse collating sequence order"
msgstr "неправильний порядок меж діапазону '%s-%s'"

#: src/tr.c:812
#, c-format
msgid "invalid repeat count %s in [c*n] construct"
msgstr "неправильно вказана кількість повторів %s у конструкції [c*n]"

#: src/tr.c:888
#, c-format
msgid "missing character class name '[::]'"
msgstr "пропущено назву класу знаків '[::]'"

#: src/tr.c:891
#, c-format
msgid "missing equivalence class character '[==]'"
msgstr "пропущений знак класу еквівалентності '[==]'"

#: src/tr.c:906
#, c-format
msgid "invalid character class %s"
msgstr "неправильний клас знаків %s"

#: src/tr.c:925
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s: потрібно вказати один символ, що визначає клас еквівалентних йому"

#: src/tr.c:1206
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "непарні конструкції [:upper:] та/або [:lower:]"

#: src/tr.c:1310
msgid "too many characters in set"
msgstr "надто багато знаків у таблиці"

#: src/tr.c:1394
msgid ""
"when translating with string1 longer than string2,\n"
"the latter string must not end with a character class"
msgstr ""
"якщо під час перетворення рядок1 буде довшим за рядок2,\n"
"останній рядок не повинен завершуватися класом символів"

#: src/tr.c:1450
msgid "the [c*] repeat construct may not appear in string1"
msgstr "конструкція [c*] не може використовуватись у ТАБЛИЦІ1"

#: src/tr.c:1460
msgid "only one [c*] repeat construct may appear in string2"
msgstr "у ТАБЛИЦІ2 може використовуватись лише одна конструкція [c*]"

#: src/tr.c:1468
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr "вираз [=c=] не може використовуватись у ТАБЛИЦІ2 при перетворенні"

#: src/tr.c:1475
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are 'upper' and 'lower'"
msgstr ""
"при перетворенні, у ТАБЛИЦІ2 можуть використовуватись лише\n"
"класи 'upper' та 'lower'"

#: src/tr.c:1490
msgid "when not truncating set1, string2 must be non-empty"
msgstr ""
"якщо частина таблиці1 не відкидається, таблиця2 не повинна бути порожньою"

#: src/tr.c:1499
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr ""
"при перетворенні з доповненням класів символів, ТАБЛИЦЯ2 повинна\n"
"ставити у відповідність всім символам доповнення рівно один символ"

#: src/tr.c:1508
msgid "the [c*] construct may appear in string2 only when translating"
msgstr ""
"конструкція [c*] може використовуватись у ТАБЛИЦІ2 лише при перетворенні"

#: src/tr.c:1754
msgid "Two strings must be given when both deleting and squeezing repeats."
msgstr "При вилученні і ущільненні повторів слід вказати два рядки."

#: src/tr.c:1756
msgid "Two strings must be given when translating."
msgstr "При перетворенні потрібно вказати дві таблиці."

#: src/tr.c:1766
msgid "Only one string may be given when deleting without squeezing repeats."
msgstr ""
"При вилученні без ущільнення повторів можна вказати дві лише одну таблицю."

#: src/true.c:38
#, c-format
msgid ""
"Usage: %s [ignored command line arguments]\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s [ аргументи командного рядка, що ігноруються ]\n"
"       або:    %s КЛЮЧ\n"

#: src/true.c:45
msgid "Exit with a status code indicating success."
msgstr "Завершення з успішним статусом."

#: src/true.c:46
msgid "Exit with a status code indicating failure."
msgstr "Завершення роботи з кодом стану, що відповідає невдалому виконанню."

#: src/truncate.c:70
#, c-format
msgid "Usage: %s OPTION... FILE...\n"
msgstr "Використання: %s ПАРАМЕТР... ФАЙЛ...\n"

#: src/truncate.c:71
msgid ""
"Shrink or extend the size of each FILE to the specified size\n"
"\n"
"A FILE argument that does not exist is created.\n"
"\n"
"If a FILE is larger than the specified size, the extra data is lost.\n"
"If a FILE is shorter, it is extended and the extended part (hole)\n"
"reads as zero bytes.\n"
msgstr ""
"Зменшити або збільшити розмір кожного ФАЙЛа до вказаного значення\n"
"\n"
"Якщо ФАЙЛа не існує, його буде створено.\n"
"\n"
"Якщо розмір ФАЙЛа перевищуватиме вказаний, додаткові дані буде втрачено.\n"
"Якщо розмір ФАЙЛа буде меншим, його буде збільшено. Додаткову частину\n"
"буде заповнено нульовими байтами.\n"

#: src/truncate.c:83
msgid "  -c, --no-create        do not create any files\n"
msgstr "  -c, --no-create        не створювати файлів\n"

#: src/truncate.c:86
msgid ""
"  -o, --io-blocks        treat SIZE as number of IO blocks instead of bytes\n"
msgstr ""
"  -o, --io-blocks        вважати РОЗМІР кількістю блоків введення-вивадення, "
"а не байтів\n"

#: src/truncate.c:89
msgid ""
"  -r, --reference=RFILE  base size on RFILE\n"
"  -s, --size=SIZE        set or adjust the file size by SIZE bytes\n"
msgstr ""
"  -r, --reference=RФАЙЛ  основний розмір RФАЙЛА\n"
"  -s, --size=РОЗМІР      встановити або змінити розмір файла, відповідно до "
"РОЗМІР\n"

#: src/truncate.c:95
msgid ""
"\n"
"SIZE may also be prefixed by one of the following modifying characters:\n"
"'+' extend by, '-' reduce by, '<' at most, '>' at least,\n"
"'/' round down to multiple of, '%' round up to multiple of.\n"
msgstr ""
"\n"
"Перед РОЗМІРом може бути додано один з таких символів-модифікаторів:\n"
"«+» — розширити, «-» — звузити, «<» — не більше, «>» — не менше,\n"
"«/» — зменшити до кратного, «%» — збільшити до кратного.\n"

#: src/truncate.c:123
#, c-format
msgid "overflow in %<PRIdMAX> * %<PRIdMAX> byte blocks for file %s"
msgstr "переповнення у %<PRIdMAX> * %<PRIdMAX> байтових блоків для файла %s"

#: src/truncate.c:147
#, c-format
msgid "%s has unusable, apparently negative size"
msgstr "%s має непридатний, ймовірно від'ємний розмір"

#: src/truncate.c:157 src/truncate.c:359
#, c-format
msgid "cannot get the size of %s"
msgstr "не вдалося визначити розмір %s"

#: src/truncate.c:179
#, c-format
msgid "overflow rounding up size of file %s"
msgstr "переповнення під час округлення розміру файла %s у бік збільшення"

#: src/truncate.c:189
#, c-format
msgid "overflow extending size of file %s"
msgstr "переповнення під час розширення розміру файла %s"

#: src/truncate.c:204
#, c-format
msgid "failed to truncate %s at %<PRIdMAX> bytes"
msgstr "не вдалося обрізати %s до %<PRIdMAX> байтів"

#: src/truncate.c:277
#, c-format
msgid "multiple relative modifiers specified"
msgstr "вказано декілька відносних модифікаторів"

#: src/truncate.c:286
msgid "Invalid number"
msgstr "Некоректне число"

#: src/truncate.c:308
#, c-format
msgid "you must specify either %s or %s"
msgstr "можна визначити лише щось одне: %s або %s"

#: src/truncate.c:315
#, c-format
msgid "you must specify a relative %s with %s"
msgstr "вам слід вказати відносний %s з %s"

#: src/truncate.c:322
#, c-format
msgid "%s was specified but %s was not"
msgstr "вказано %s, але без %s"

#: src/truncate.c:379
#, c-format
msgid "cannot open %s for writing"
msgstr "не вдалося відкрити %s для запису"

#. This is a proper name. See the gettext manual, section Names.
#: src/tsort.c:41
msgid "Mark Kettenis"
msgstr "Mark Kettenis"

#: src/tsort.c:83
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
msgstr ""
"Користування: %s [ПАРАМЕТР] [ФАЙЛ]\n"
"Вивести повністю упорядкований список, узгоджений із частковим "
"упорядковуванням у ФАЙЛі.\n"

#: src/tsort.c:90 src/uptime.c:213
#, c-format
msgid "\n"
msgstr "\n"

#: src/tsort.c:476
#, c-format
msgid "%s: input contains an odd number of tokens"
msgstr "%s: на вході міститься непарна кількість лексем"

#: src/tsort.c:522
#, c-format
msgid "%s: input contains a loop:"
msgstr "%s: на вході міститься цикл:"

#: src/tty.c:65
msgid ""
"Print the file name of the terminal connected to standard input.\n"
"\n"
"  -s, --silent, --quiet   print nothing, only return an exit status\n"
msgstr ""
"Виводить назву файла для терміналу, що приєднаний до стандартному вводу.\n"
"\n"
"  -s, --silent, --quiet   не виводити, лише повернути код завершення\n"

#: src/tty.c:120
msgid "not a tty"
msgstr "не tty"

#: src/uname.c:125
msgid ""
"Print certain system information.  With no OPTION, same as -s.\n"
"\n"
"  -a, --all                print all information, in the following order,\n"
"                             except omit -p and -i if unknown:\n"
"  -s, --kernel-name        print the kernel name\n"
"  -n, --nodename           print the network node hostname\n"
"  -r, --kernel-release     print the kernel release\n"
msgstr ""
"Виводить певні відомості про систему.  Якщо КЛЮЧ не вказаний,\n"
"вважається -s.\n"
"\n"
"  -a, --all                вивести всю інформацію, у наступному порядку,\n"
"                            крім -p та -i, якщо вони невідомі:\n"
"  -s, --kernel-name        вивести назву ядра\n"
"  -n, --nodename           вивести назву машини у мережі\n"
"  -r, --release            вивести номер випуску операційної системи\n"

#: src/uname.c:134
msgid ""
"  -v, --kernel-version     print the kernel version\n"
"  -m, --machine            print the machine hardware name\n"
"  -p, --processor          print the processor type (non-portable)\n"
"  -i, --hardware-platform  print the hardware platform (non-portable)\n"
"  -o, --operating-system   print the operating system\n"
msgstr ""
"  -v, --kernel-version     вивести версію ядра\n"
"  -m, --machine            вивести тип обладнання машини\n"
"  -p, --processor          вивести тип процесора (непридатне до портування)\n"
"  -i, --hardware-platform  вивести тип апаратної платформи (непридатне до "
"портування)\n"
"  -o, --operating-system   вивести назву операційної системи\n"

#: src/uname.c:144
msgid ""
"Print machine architecture.\n"
"\n"
msgstr ""
"Вивести архітектуру машини.\n"
"\n"

#: src/uname.c:287
msgid "cannot get system name"
msgstr "не вдалося дізнатись назву системи"

#: src/unexpand.c:82
msgid "Convert blanks in each FILE to tabs, writing to standard output.\n"
msgstr ""
"Перетворити пробіли у кожному ФАЙЛі на табуляції, вивести результат до "
"стандартного виведення.\n"

#: src/unexpand.c:89
msgid ""
"  -a, --all        convert all blanks, instead of just initial blanks\n"
"      --first-only  convert only leading sequences of blanks (overrides -a)\n"
"  -t, --tabs=N     have tabs N characters apart instead of 8 (enables -a)\n"
"  -t, --tabs=LIST  use comma separated LIST of tab positions (enables -a)\n"
msgstr ""
"  -a, --all         перетворювати всі пробільні знаки, а не лише початкові\n"
"      --first-only  перетворювати лише початкові пробільні знаки\n"
"                      (перекриває-a)\n"
"  -t, --tabs=ЧИСЛО  вживати табуляцію вказаної ширини, а не 8 (включає -a)\n"
"  -t, --tabs=СПИСОК використовувати заданий СПИСОК (розділених комами)\n"
"                       позицій табуляції (включає -a)\n"

#: src/unexpand.c:306
msgid "tab stop value is too large"
msgstr "розмір табуляції надто великий"

#: src/uniq.c:171
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "Використання: %s [КЛЮЧ]... [ВХІД [ВИХІД]]\n"

#: src/uniq.c:175
msgid ""
"Filter adjacent matching lines from INPUT (or standard input),\n"
"writing to OUTPUT (or standard output).\n"
"\n"
"With no options, matching lines are merged to the first occurrence.\n"
msgstr ""
"Фільтрує сусідні відповідні рядків з ВХОДУ (або стандартного введення),\n"
"з записом до ВИХОДУ (або стандартного виведення).\n"
"\n"
"Якщо не вказано параметрів, відповідні рядки об'єднуються з рядками,\n"
"виявленими першими.\n"

#: src/uniq.c:184
msgid ""
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines, one for each group\n"
msgstr ""
"  -c, --count           виводити число повторів на початку кожного рядка\n"
"  -d, --repeated        виводити лише рядки, що повторюються, один для "
"кожної з груп\n"

#: src/uniq.c:188
msgid ""
"  -D                    print all duplicate lines\n"
"      --all-repeated[=METHOD]  like -D, but allow separating groups\n"
"                                 with an empty line;\n"
"                                 METHOD={none(default),prepend,separate}\n"
msgstr ""
"  -D                    вивести усі рядки-дублікати\n"
"      --all-repeated[=СПОСІБ]  подібно до -D, але уможливити відокремлення\n"
"                                 груп порожнім рядком;\n"
"                                 СПОСІБ={none(типовий),prepend(перед),"
"separate(окремо)}\n"

#: src/uniq.c:194
msgid "  -f, --skip-fields=N   avoid comparing the first N fields\n"
msgstr "  -f, --skip-fields=N   уникати порівняння перших N полів\n"

#: src/uniq.c:197
msgid ""
"      --group[=METHOD]  show all items, separating groups with an empty "
"line;\n"
"                          METHOD={separate(default),prepend,append,both}\n"
msgstr ""
"      --group[=МЕТОД]   показати усі запис, відокремивши групи порожніми "
"рядками;\n"
"                          МЕТОД={separate(типовий),prepend,append,both}\n"

#: src/uniq.c:201
msgid ""
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
msgstr ""
"  -i, --ignore-case     ігнорувати при порівнянні регістр\n"
"  -s, --skip-chars=Н    не порівнювати перші Н знаків\n"
"  -u, --unique          виводити лише рядки, що не повторюються\n"

#: src/uniq.c:209
msgid "  -w, --check-chars=N   compare no more than N characters in lines\n"
msgstr "  -w, --check-chars=Н   порівнювати перші Н знаків рядків\n"

#: src/uniq.c:214
msgid ""
"\n"
"A field is a run of blanks (usually spaces and/or TABs), then non-blank\n"
"characters.  Fields are skipped before chars.\n"
msgstr ""
"\n"
"Полем вважається послідовність пробільних знаків, за якою\n"
"йдуть не пробільні знаки. Спочатку пропускаються поля, потім символи.\n"

#: src/uniq.c:219
msgid ""
"\n"
"Note: 'uniq' does not detect repeated lines unless they are adjacent.\n"
"You may want to sort the input first, or use 'sort -u' without 'uniq'.\n"
"Also, comparisons honor the rules specified by 'LC_COLLATE'.\n"
msgstr ""
"\n"
"Зауваження: uniq не зможе визначити повторених рядків, якщо ці рядки не є\n"
"сусідніми. Вам варто спочатку впорядкувати вхідні дані, або скористатися\n"
"«sort -u» замість uniq.\n"
"Крім того, під час порівняння використовуються правила, встановлені змінною\n"
"LC_COLLATE.\n"

#: src/uniq.c:437
msgid "too many repeated lines"
msgstr "надто багато рядків, що повторюються"

#: src/uniq.c:613
msgid "invalid number of fields to skip"
msgstr "неправильна кількість полів, що пропускаються"

#: src/uniq.c:622
msgid "invalid number of bytes to skip"
msgstr "неправильна кількість байт, що пропускаються"

#: src/uniq.c:632
msgid "invalid number of bytes to compare"
msgstr "неправильна кількість байт, що порівнюються"

#: src/uniq.c:654
#, c-format
msgid "--group is mutually exclusive with -c/-d/-D/-u"
msgstr "--group не можна використовувати разом з -c/-d/-D/-u"

#: src/uniq.c:661
#, c-format
msgid "grouping and printing repeat counts is meaningless"
msgstr "одночасне групування і виведення даних щодо повторів не має сенсу"

#: src/uniq.c:668
#, c-format
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr "вивід усіх рядків, що повторюються та числа повторів не має сенсу"

#: src/unlink.c:46
#, c-format
msgid ""
"Usage: %s FILE\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s ФАЙЛ\n"
"       або:    %s КЛЮЧ\n"

#: src/unlink.c:49
msgid ""
"Call the unlink function to remove the specified FILE.\n"
"\n"
msgstr ""
"Викликає функцію unlink для вилучення вказаного ФАЙЛА.\n"
"\n"

#: src/uptime.c:126
msgid "couldn't get boot time"
msgstr "не вдалося дізнатись час початкового завантаження"

#. TRANSLATORS: This prints the current clock time.
#: src/uptime.c:137
msgid " %H:%M%P  "
msgstr " %H:%M  "

#: src/uptime.c:139
#, c-format
msgid " ??:????  "
msgstr " ??:????  "

#: src/uptime.c:141
#, c-format
msgid "up ???? days ??:??,  "
msgstr "???? днів ??:??,  "

#: src/uptime.c:145
#, c-format
msgid "up %ld day %2d:%02d,  "
msgid_plural "up %ld days %2d:%02d,  "
msgstr[0] "%ld день %2d:%02d,  "
msgstr[1] "%ld дні %2d:%02d,  "
msgstr[2] "%ld днів %2d:%02d,  "

#: src/uptime.c:150
#, c-format
msgid "up  %2d:%02d,  "
msgstr "%2d:%02d,  "

#: src/uptime.c:152
#, c-format
msgid "%lu user"
msgid_plural "%lu users"
msgstr[0] "%lu користувач"
msgstr[1] "%lu користувачі"
msgstr[2] "%lu користувачів"

#: src/uptime.c:162
#, c-format
msgid ",  load average: %.2f"
msgstr ", середня завантаженість: %.2f"

#: src/uptime.c:200
#, c-format
msgid ""
"Print the current time, the length of time the system has been up,\n"
"the number of users on the system, and the average number of jobs\n"
"in the run queue over the last 1, 5 and 15 minutes."
msgstr ""
"Виводить поточний час, час безперервної роботи системи, кількість\n"
"користувачів у системі та середнє число завдань у черзі запуску за\n"
"останні 1, 5 та 15 хвилин."

#: src/uptime.c:209
#, c-format
msgid ""
"  Processes in\n"
"an uninterruptible sleep state also contribute to the load average.\n"
msgstr ""
"  Процеси у\n"
"стані неперервного сну також впливають на середнє завантаження.\n"

#: src/uptime.c:215
#, c-format
msgid ""
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"Якщо ФАЙЛ не вказано, використовується %s.  Часто замість ФАЙЛ\n"
"вказують %s.\n"
"\n"

#: src/users.c:107
#, c-format
msgid ""
"Output who is currently logged in according to FILE.\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"Виводить список підключених користувачів відповідно до ФАЙЛА.\n"
"Якщо ФАЙЛ не вказаний, використовується %s.  Часто у якості ФАЙЛА\n"
"вказують %s.\n"
"\n"

#: src/wc.c:120
msgid ""
"Print newline, word, and byte counts for each FILE, and a total line if\n"
"more than one FILE is specified.  A word is a non-zero-length sequence of\n"
"characters delimited by white space.\n"
msgstr ""
"Вивести дані щодо кількості розривів рядків, слів та байтів для кожного з "
"ФАЙЛів і\n"
"рядок сумарних даних, якщо вказано декілька файлів. Словом вважається "
"ненульової\n"
"довжини послідовність символів символів обмежена пробілами.\n"

#: src/wc.c:128
msgid ""
"\n"
"The options below may be used to select which counts are printed, always in\n"
"the following order: newline, word, character, byte, maximum line length.\n"
"  -c, --bytes            print the byte counts\n"
"  -m, --chars            print the character counts\n"
"  -l, --lines            print the newline counts\n"
msgstr ""
"\n"
"За допомогою вказаних нижче параметрів можна вибрати дані, які\n"
"буде виведено. Порядок буде завжди таким: розриви рядків,\n"
"слова, символи, байти, максимальна довжина рядка.\n"
"  -c, --bytes            вивести кількість байт\n"
"  -m, --chars            вивести кількість знаків\n"
"  -l, --lines            вивести кількість розривів рядків\n"

#: src/wc.c:136
msgid ""
"      --files0-from=F    read input from the files specified by\n"
"                           NUL-terminated names in file F;\n"
"                           If F is - then read names from standard input\n"
"  -L, --max-line-length  print the maximum display width\n"
"  -w, --words            print the word counts\n"
msgstr ""
"      --files0-from=F    читати вхідні дані з файлів, вказаних\n"
"                           назвами зі списку, розділеного символами\n"
"                           NUL у файлі F. Якщо F дорівнює «-», назви\n"
"                           буде прочитано зі стандартного джерела даних\n"
"  -L, --max-line-length  вивести максимальну ширину виведення\n"
"  -w, --words            вивести кількість слів\n"

#: src/who.c:213
msgid " old "
msgstr "давно"

#: src/who.c:443
msgid "system boot"
msgstr "завантаження системи"

#: src/who.c:450 src/who.c:452
msgid "id="
msgstr "id="

#: src/who.c:465 src/who.c:470
msgid "term="
msgstr "термінал="

#: src/who.c:467 src/who.c:471
msgid "exit="
msgstr "вихід="

#: src/who.c:488
msgid "LOGIN"
msgstr "ВХІД"

#: src/who.c:508
msgid "clock change"
msgstr "зміна часу"

#: src/who.c:520 src/who.c:521
msgid "run-level"
msgstr "рівень виконання"

#: src/who.c:524 src/who.c:525
msgid "last="
msgstr "попередній="

#: src/who.c:556
#, c-format
msgid ""
"\n"
"# users=%lu\n"
msgstr ""
"\n"
"число користувачів=%lu\n"

#: src/who.c:562
msgid "NAME"
msgstr "НАЗВА"

#: src/who.c:562
msgid "LINE"
msgstr "ЛІНІЯ"

#: src/who.c:562
msgid "TIME"
msgstr "Час"

#: src/who.c:562
msgid "IDLE"
msgstr "НЕАКТИВНИЙ"

#: src/who.c:563
msgid "PID"
msgstr "PID"

#: src/who.c:563
msgid "COMMENT"
msgstr "КОМЕНТАР"

#: src/who.c:563
msgid "EXIT"
msgstr "ВИХІД"

#: src/who.c:643
#, c-format
msgid "Usage: %s [OPTION]... [ FILE | ARG1 ARG2 ]\n"
msgstr "Використання: %s [КЛЮЧ]... [ ФАЙЛ | АРГ1 АРГ2]\n"

#: src/who.c:644
msgid "Print information about users who are currently logged in.\n"
msgstr "Вивести дані щодо користувачів, які працюють у системі.\n"

#: src/who.c:647
msgid ""
"\n"
"  -a, --all         same as -b -d --login -p -r -t -T -u\n"
"  -b, --boot        time of last system boot\n"
"  -d, --dead        print dead processes\n"
"  -H, --heading     print line of column headings\n"
msgstr ""
"\n"
"  -a, --all         еквівалент -b -d --login -p -r -t -T -u\n"
"  -b, --boot        час останнього звантаження системи\n"
"  -d, --dead        виводити мертві процеси\n"
"  -H, --heading     виводити рядок з заголовками стовпчиків\n"

#: src/who.c:654
msgid "  -l, --login       print system login processes\n"
msgstr "  -l, --login       виводити процеси входу у систему\n"

#: src/who.c:657
msgid ""
"      --lookup      attempt to canonicalize hostnames via DNS\n"
"  -m                only hostname and user associated with stdin\n"
"  -p, --process     print active processes spawned by init\n"
msgstr ""
"      --lookup      намагатись канонізувати назви вузлів через DNS\n"
"  -m                лише назва вузлі та користувач, пов'язані з\n"
"                    стандартним вводом\n"
"  -p, --process     виводити активні процеси, які породжені init\n"

#: src/who.c:662
msgid ""
"  -q, --count       all login names and number of users logged on\n"
"  -r, --runlevel    print current runlevel\n"
"  -s, --short       print only name, line, and time (default)\n"
"  -t, --time        print last system clock change\n"
msgstr ""
"  -q, --count       всі назви та кількість підключених користувачів\n"
"  -r, --runlevel    виводити поточний рівень виконання\n"
"  -s, --short       виводити лише назву, лінію та час (приймається типово)\n"
"  -t, --time        виводити останню зміна системного часу\n"

#: src/who.c:668
msgid ""
"  -T, -w, --mesg    add user's message status as +, - or ?\n"
"  -u, --users       list users logged in\n"
"      --message     same as -T\n"
"      --writable    same as -T\n"
msgstr ""
"  -T, -w, --mesg    додавати статус отримання повідомлень як  +, - або ?\n"
"  -u, --users       перерахувати підключених користувачів\n"
"      --message     еквівалент -T\n"
"      --writable    еквівалент -T\n"

#: src/who.c:676
#, c-format
msgid ""
"\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"If ARG1 ARG2 given, -m presumed: 'am i' or 'mom likes' are usual.\n"
msgstr ""
"\n"
"Якщо ФАЙЛ не вказаний, використовується %s. Часто як ФАЙЛ вказують %s.\n"
"Якщо вказані АРГ1 та АРГ2, вважається використання -m: наприклад 'am i'\n"
"та 'mom likes'.\n"

#: src/whoami.c:46
msgid ""
"Print the user name associated with the current effective user ID.\n"
"Same as id -un.\n"
"\n"
msgstr ""
"Вивести ім'я користувача, що відповідає поточному ефективному id\n"
"користувача.  Аналогічно виклику id -un.\n"
"\n"

#: src/whoami.c:88
#, c-format
msgid "cannot find name for user ID %lu"
msgstr "не вдалося визначити назву для ідентифікатора користувача %lu"

#: src/yes.c:42
#, c-format
msgid ""
"Usage: %s [STRING]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s [РЯДОК]...\n"
"       або:    %s КЛЮЧ\n"

#: src/yes.c:48
msgid ""
"Repeatedly output a line with all specified STRING(s), or 'y'.\n"
"\n"
msgstr ""
"Безперервно виводити вказаний РЯДОК (РЯДКИ) або, якщо РЯДОК не вказано, "
"'y'.\n"
"\n"

#~ msgid "stdin"
#~ msgstr "stdin"

#~ msgid "stdout"
#~ msgstr "stdout"

#~ msgid "stderr"
#~ msgstr "stderr"

#~ msgid "unknown stream"
#~ msgstr "невідомий потік"

#~ msgid "failed to reopen %s with mode %s"
#~ msgstr "не вдалося повторно відкрити %s у режимі %s"

#~ msgid "error initializing month strings"
#~ msgstr "помилка під час ініціалізації рядків місяців"

#~ msgid "%s has been replaced with a symbolic link. giving up on this name"
#~ msgstr ""
#~ "%s було замінено символічним посиланням. Кінець виводу для цієї назви"

#~ msgid "%s has been replaced with a remote file. giving up on this name"
#~ msgstr "%s було замінено віддаленим файлом. Кінець виводу для цієї назви"

#~ msgid "empty %s not allowed"
#~ msgstr "порожній рядок %s є неприпустимим"

#~ msgid "  nocache   discard cached data\n"
#~ msgstr "  nocache   відкинути кешовані дані\n"

#~ msgid ", %g s, %s/s\n"
#~ msgstr ", %g с, %s/s\n"

#~ msgid ", %.6f s, %s/s"
#~ msgstr ", %.6f с, %s/с"

#~ msgid ""
#~ "\n"
#~ "If the first character of K (the number of bytes or lines) is a '+',\n"
#~ "print beginning with the Kth item from the start of each file, "
#~ "otherwise,\n"
#~ "print the last K items in the file.  K may have a multiplier suffix:\n"
#~ "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
#~ "\n"
#~ msgstr ""
#~ "\n"
#~ "Якщо першим символом у Н (числі байт або рядків) є «+», виведення буде\n"
#~ "розпочато з Н-ого елемента від початку кожного файла, інакше буде\n"
#~ "виведено останні Н елементи. Н може мати суфікс-множник: b 512, kB 1000, "
#~ "K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024 тощо для T, P, E, Z, Y.\n"
#~ "\n"

#~ msgid ""
#~ "unrecognized file system type 0x%08lx for %s. please report this to %s. "
#~ "reverting to polling"
#~ msgstr ""
#~ "Нерозпізнаний тип файлової системи 0x%08lx для %s. Будь ласка, повідомте "
#~ "про нього до %s. Повертаємося до простого опитування."

#~ msgid "failed to %s supplemental groups"
#~ msgstr "не вдалося %s список додаткових груп"

#~ msgid "%s: invalid number"
#~ msgstr "%s: неприпустимий число"

#~ msgid ""
#~ "\n"
#~ "Sending a %s signal to a running 'dd' process makes it\n"
#~ "print I/O statistics to standard error and then resume copying.\n"
#~ "\n"
#~ "  $ dd if=/dev/zero of=/dev/null& pid=$!\n"
#~ "  $ kill -%s $pid; sleep 1; kill $pid\n"
#~ "  18335302+0 records in\n"
#~ "  18335302+0 records out\n"
#~ "  9387674624 bytes (9.4 GB) copied, 34.6279 seconds, 271 MB/s\n"
#~ "\n"
#~ "Options are:\n"
#~ "\n"
#~ msgstr ""
#~ "\n"
#~ "Якщо надіслати запущеному процесу 'dd' сигнал %s, він виведе на\n"
#~ "стандартний потік помилок статистику вводу/виводу та продовжить\n"
#~ "копіювання.\n"
#~ "\n"
#~ "  $ dd if=/dev/zero of=/dev/null& pid=$!\n"
#~ "  $ kill -%s $pid; sleep 1; kill $pid\n"
#~ "  18335302+0 вхідних записів\n"
#~ "  18335302+0 вихідних записів\n"
#~ "  9387674624 байта (9.4 GB) скопійовано, 34.6279 секунди, 271 Мб/с\n"
#~ "\n"
#~ "Ключі:\n"
#~ "\n"

#~ msgid "%s: %s is so large that it is not representable"
#~ msgstr "%s: %s настільки великий, що його неможливо машинно представити"

#~ msgid "number of lines"
#~ msgstr "число рядків"

#~ msgid "number of bytes"
#~ msgstr "число байт"

#~ msgid "%s: invalid number to ignore"
#~ msgstr "%s: некоректне число для виключення"

#~ msgid "input line is too short, no numbers found to convert in field %ld"
#~ msgstr ""
#~ "надто короткий рядок вхідних даних, у полі %ld не виявлено чисел для "
#~ "форматування"

#~ msgid ""
#~ "\n"
#~ "-t is implied if PAGE_LENGTH <= 10.  With no FILE, or when FILE is -, "
#~ "read\n"
#~ "standard input.\n"
#~ msgstr ""
#~ "\n"
#~ "додається -t, якщо PAGE_LENGTH <= 10. Якщо ФАЙЛ не вказано\n"
#~ "або вказаний як -, читає стандартне джерело введення.\n"

#~ msgid ""
#~ "\n"
#~ "With no FILE, or when FILE is -, read standard input.  Default is '-"
#~ "F /'.\n"
#~ msgstr ""
#~ "\n"
#~ "Якщо вхідний файл не вказаний, або якщо вказано символ -,\n"
#~ "використовується стандартне джерело вхідних даних. Типовим є «-F /».\n"

#~ msgid "%s: invalid number of bytes"
#~ msgstr "%s: неправильна кількість байт"

#~ msgid "%s: invalid number of lines"
#~ msgstr "%s: неправильна кількість рядків"

#~ msgid ""
#~ " * lnext CHAR    CHAR will enter the next character quoted\n"
#~ "   quit CHAR     CHAR will send a quit signal\n"
#~ " * rprnt CHAR    CHAR will redraw the current line\n"
#~ "   start CHAR    CHAR will restart the output after stopping it\n"
#~ msgstr ""
#~ "* lnext СИМВОЛ    СИМВОЛ буде вводити наступний символ, скасовуючи його\n"
#~ "                  спеціальну дію\n"
#~ "  quit СИМВОЛ     СИМВОЛ буде надсилати сигнал виходу\n"
#~ "* rprnt СИМВОЛ    СИМВОЛ буде перерисовувати поточний рядок\n"
#~ "  start СИМВОЛ    СИМВОЛ буде відновлювати ввід\n"

#~ msgid ""
#~ "\n"
#~ "Control settings:\n"
#~ "   [-]clocal     disable modem control signals\n"
#~ "   [-]cread      allow input to be received\n"
#~ " * [-]crtscts    enable RTS/CTS handshaking\n"
#~ " * [-]cdtrdsr    enable DTR/DSR handshaking\n"
#~ "   csN           set character size to N bits, N in [5..8]\n"
#~ msgstr ""
#~ "\n"
#~ "Параметри керування:\n"
#~ "   [-]clocal     скасувати керівні сигнали модему\n"
#~ "   [-]cread      дозволити ввід\n"
#~ " * [-]crtscts    дозволити керування потоком RTS/CTS\n"
#~ " * [-]cdtrdsr    дозволити керування потоком DTR/DSR\n"
#~ "   csН           встановити розмір символу рівним Н біт, Н від 5 до 8\n"

#~ msgid ""
#~ "\n"
#~ "Output settings:\n"
#~ " * bsN           backspace delay style, N in [0..1]\n"
#~ " * crN           carriage return delay style, N in [0..3]\n"
#~ " * ffN           form feed delay style, N in [0..1]\n"
#~ " * nlN           newline delay style, N in [0..1]\n"
#~ msgstr ""
#~ "\n"
#~ "Параметри виводу:\n"
#~ "* bsН           пауза після забою, діапазон Н [0..1]\n"
#~ "* crН           пауза після переведення каретки, діапазон Н [0..3]\n"
#~ "* ffН           пауза після переведення сторінки, діапазон Н [0..1]\n"
#~ "* nlН           пауза після нового рядка, діапазон Н [0..1]\n"

#~ msgid ""
#~ " * [-]ocrnl      translate carriage return to newline\n"
#~ " * [-]ofdel      use delete characters for fill instead of NUL "
#~ "characters\n"
#~ " * [-]ofill      use fill (padding) characters instead of timing for "
#~ "delays\n"
#~ " * [-]olcuc      translate lowercase characters to uppercase\n"
#~ " * [-]onlcr      translate newline to carriage return-newline\n"
#~ " * [-]onlret     newline performs a carriage return\n"
#~ msgstr ""
#~ "* [-]ocrnl      перетворювати переведення каретки у переведення рядка\n"
#~ "* [-]ofdel      заповнювати символами затирання замість нулів\n"
#~ "* [-]ofill      використовувати символи заповнення для затримок\n"
#~ "* [-]olcuc      перетворювати маленькі літери на великі\n"
#~ "* [-]onlcr      перетворювати переведення рядка у переведення каретки-"
#~ "розрив рядка\n"
#~ "* [-]onlret     переведення рядка призводить до переведення каретки\n"

#~ msgid ""
#~ " * [-]onocr      do not print carriage returns in the first column\n"
#~ "   [-]opost      postprocess output\n"
#~ " * tabN          horizontal tab delay style, N in [0..3]\n"
#~ " * tabs          same as tab0\n"
#~ " * -tabs         same as tab3\n"
#~ " * vtN           vertical tab delay style, N in [0..1]\n"
#~ msgstr ""
#~ "* [-]onocr      не виводити переведення каретки у першому стовпчику\n"
#~ "  [-]opost      форматувати вивід\n"
#~ "* tabН          значення паузи після горизонтальної табуляції,\n"
#~ "                допустимі Н [0..3]\n"
#~ "* tabs          синонім tab0\n"
#~ "* -tabs         синонім tab3\n"
#~ "* vtН           пауза після вертикальної табуляції, діапазон Н [0..1]\n"

#~ msgid ""
#~ " * [-]ctlecho    echo control characters in hat notation ('^c')\n"
#~ "   [-]echo       echo input characters\n"
#~ " * [-]echoctl    same as [-]ctlecho\n"
#~ "   [-]echoe      same as [-]crterase\n"
#~ "   [-]echok      echo a newline after a kill character\n"
#~ msgstr ""
#~ "* [-]ctlecho    відображати керівні символи з шапкою ('^c')\n"
#~ "  [-]echo       відображати символи, що вводяться\n"
#~ "* [-]echoctl    синонім [-]ctlecho\n"
#~ "  [-]echoe      синонім [-]crterase\n"
#~ "  [-]echok      відображати переведення рядка після символу знищення\n"

#~ msgid ""
#~ " * [-]echoke     same as [-]crtkill\n"
#~ "   [-]echonl     echo newline even if not echoing other characters\n"
#~ " * [-]echoprt    echo erased characters backward, between '\\' and '/'\n"
#~ "   [-]icanon     enable erase, kill, werase, and rprnt special "
#~ "characters\n"
#~ "   [-]iexten     enable non-POSIX special characters\n"
#~ msgstr ""
#~ "* [-]echoke     синонім [-]crtkill\n"
#~ "  [-]echonl     відображати переведення рядка, навіть якщо інші символи "
#~ "не\n"
#~ "                відображаються\n"
#~ "* [-]echoprt    виводити стерті символи у зворотному порядку, між '\\' та "
#~ "'/'\n"
#~ "  [-]icanon     використовувати спецсимволи erase, kill, werase, та "
#~ "rprnt\n"
#~ "  [-]iexten     використовувати спецсимволи, не описані у стандарті "
#~ "POSIX\n"

#~ msgid ""
#~ "   dec           same as echoe echoctl echoke -ixany intr ^c erase 0177\n"
#~ "                 kill ^u\n"
#~ " * [-]decctlq    same as [-]ixany\n"
#~ "   ek            erase and kill characters to their default values\n"
#~ "   evenp         same as parenb -parodd cs7\n"
#~ msgstr ""
#~ "  dec           синонім echoe echoctl echoke -ixany intr ^c erase 0177\n"
#~ "                 kill ^u\n"
#~ "* [-]decctlq    синонім [-]ixany\n"
#~ "  ek            встановити типові значення для символів erase та kill\n"
#~ "  evenp         синонім parenb -parodd cs7\n"

#~ msgid ""
#~ "   -evenp        same as -parenb cs8\n"
#~ " * [-]lcase      same as xcase iuclc olcuc\n"
#~ "   litout        same as -parenb -istrip -opost cs8\n"
#~ "   -litout       same as parenb istrip opost cs7\n"
#~ "   nl            same as -icrnl -onlcr\n"
#~ "   -nl           same as icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"
#~ msgstr ""
#~ "  -evenp        синонім -parenb cs8\n"
#~ "* [-]lcase      синонім xcase iuclc olcuc\n"
#~ "  litout        синонім -parenb -istrip -opost cs8\n"
#~ "  -litout       синонім parenb istrip opost cs7\n"
#~ "  nl            синонім -icrnl -onlcr\n"
#~ "  -nl           синонім icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"

#~ msgid ""
#~ "Force changed blocks to disk, update the super block.\n"
#~ "\n"
#~ msgstr ""
#~ "Записує змінені блоки на диск, оновлює суперблок\n"
#~ "\n"

#~ msgid "ignoring all arguments"
#~ msgstr "всі аргументи проігноровані"

#~ msgid "For complete documentation, run: info coreutils '%s invocation'\n"
#~ msgstr ""
#~ "Ознайомитися з повною документацією можна за допомогою команди info "
#~ "coreutils '%s invocation'\n"

#~ msgid "number in %s is too large"
#~ msgstr "число у %s надто велике"

#~ msgid "%s: invalid number of seconds"
#~ msgstr "%s: неправильне число секунд"

#~ msgid "%s: cannot find name for user ID %lu\n"
#~ msgstr "%s: не вдалося визначити ім'я користувача для ID %lu\n"

#~ msgid "cannot create pipe"
#~ msgstr "не вдалося створити канал"

#~ msgid "%s subprocess failed"
#~ msgstr "помилка підпроцесу %s"

#~ msgid "_open_osfhandle failed"
#~ msgstr "Помилка _open_osfhandle"

#~ msgid "cannot restore fd %d: dup2 failed"
#~ msgstr "не вдалося відновити файловий дескриптор %d: помилка dup2"

#~ msgid "%s subprocess"
#~ msgstr "дочірній процес %s"

#~ msgid "%s subprocess got fatal signal %d"
#~ msgstr "дочірнім процесом %s отримано сигнал щодо аварійного завершення %d"

#~ msgid "failed to set additional groups"
#~ msgstr "не вдалося встановити додаткові групи"

#~ msgid "mount point %s already traversed"
#~ msgstr "обхід точки монтування %s вже здійснено"

#~ msgid "%s: cannot lseek back to original position"
#~ msgstr "ю%s: не вдалося вернуть вказівник файла на початкову позицію"

#~ msgid "%s: failed to reset file pointer"
#~ msgstr "%s: не вдалося скинути вказівник на файл"

#~ msgid "cannot reposition file pointer for %s"
#~ msgstr "не вдалося перемістити вказівник файла для %s"

#~ msgid ""
#~ "  -Z, --context[=CTX]  set the SELinux security context of each NAME to\n"
#~ "                         default type, or CTX if specified\n"
#~ msgstr ""
#~ "  -Z, --context[=КОН]  встановити контекст захисту SELinux для кожної "
#~ "НАЗВИ у типове\n"
#~ "                       значення або у значення КОН\n"

#~ msgid ""
#~ "  -Z, --context[=CTX]  set the SELinux security context of NAME to\n"
#~ "                         default type, or to CTX if specified\n"
#~ msgstr ""
#~ "  -Z, --context[=КОН]  встановити контекст захисту SELinux для НАЗВИ у "
#~ "типове\n"
#~ "                       значення або у значення КОН\n"

#~ msgid "out of memory (requested %zu bytes)"
#~ msgstr "переповнення пам'яті (запитано %zu байтів)"

#~ msgid "--padding cannot be combined with --format"
#~ msgstr "--padding не можна використовувати разом з --format"

#~ msgid ""
#~ "Usage: %s [SHORT-OPTION]... USER COMMAND [ARGUMENT]...\n"
#~ "  or:  %s LONG-OPTION\n"
#~ msgstr ""
#~ "Використання: %s [СКОРОЧЕНИЙ-ПАРАМЕТР]... КОРИСТУВАЧ КОМАНДА "
#~ "[АРГУМЕНТ]...\n"
#~ "  або  %s ПАРАМЕТР-ПОВНІСТЮ\n"

#~ msgid ""
#~ "Drop any supplemental groups, assume the user-ID and group-ID of the "
#~ "specified\n"
#~ "USER (numeric ID or user name), and run COMMAND with any specified "
#~ "ARGUMENTs.\n"
#~ "Exit with status 111 if unable to assume the required user and group ID.\n"
#~ "Otherwise, exit with the exit status of COMMAND.\n"
#~ "This program is useful only when run by root (user ID zero).\n"
#~ "\n"
#~ msgstr ""
#~ "Скидає всі додаткові групи, встановлює ідентифікатори\n"
#~ "користувача та групи як у вказаного КОРИСТУВАЧА та запускає КОМАНДУ\n"
#~ "з вказаними АРГУМЕНТАМИ.  Завершується зі статусом 111, якщо \n"
#~ "не вдалося встановити потрібні ідентифікатори користувача та групи.  У\n"
#~ "іншому випадку повертається вихідний статус КОМАНДИ.  Ця програма\n"
#~ "має сенс лише для root (UID=0).\n"
#~ "\n"

#~ msgid ""
#~ "  -g GID[,GID1...]  also set the primary group-ID to the numeric GID, "
#~ "and\n"
#~ "                      (if specified) supplemental group IDs to GID1, ...\n"
#~ msgstr ""
#~ "  -g GID[,GID1...]  також встановити головний ідентифікатор групи у "
#~ "значення GID, та\n"
#~ "                    (якщо вказано) ідентифікатори додаткових груп ID у "
#~ "GID1, ...\n"

#~ msgid "unknown user-ID: %s"
#~ msgstr "невідомий ідентифікатор користувача: %s"

#~ msgid "to use user-ID %s you need to use -g too"
#~ msgstr ""
#~ "для використання ідентифікатора користувача %s слід використовувати -g too"

#~ msgid "cannot set group-ID to %lu"
#~ msgstr "не вдалося встановити ідентифікатор групи рівним %lu"

#~ msgid "cannot set user-ID to %lu"
#~ msgstr "не вдалося встановити ідентифікатор користувача рівним %lu"

#~ msgid "failed to get file system create context"
#~ msgstr "не вдалося отримати контекст файлової системи для створення файлів"

#~ msgid "warning: "
#~ msgstr "попередження: "

#~ msgid "long option '--megabytes' is deprecated and will soon be removed"
#~ msgstr ""
#~ "довга версія параметра «--megabytes» вважається застарілою, скоро її буде "
#~ "вилучено"

#~ msgid "Usage: %s [OPTION]... [USERNAME]\n"
#~ msgstr "Використання: %s [КЛЮЧ]... [КОРИСТУВАЧ]\n"

#~ msgid ""
#~ "      --strict         with --check, exit non-zero for any invalid input\n"
#~ msgstr ""
#~ "      --strict         з --check вийти з ненульовим кодом для будь-якого "
#~ "некоректного\n"
#~ "                       джерела вхідних даних\n"

#~ msgid "failed to redirect stderr to /dev/null"
#~ msgstr "не вдалося переспрямувати stderr до /dev/null"

#~ msgid "invalid number: '%s'"
#~ msgstr "некоректне число: «%s»"

#~ msgid ""
#~ "\n"
#~ "With no FILE or if FILE is -, read Standard Input.  '-F /' by default.\n"
#~ msgstr ""
#~ "\n"
#~ "Якщо ФАЙЛ не вказаний або вказаний як -, читає стандартний ввід.\n"
#~ "Типово вважається вказаним '-F /'.\n"

#~ msgid "cannot remove directory: %s"
#~ msgstr "не вдалося вилучити каталог: %s"

#~ msgid "dup2 failed"
#~ msgstr "помилка dup2"

#~ msgid "couldn't execute %s"
#~ msgstr "неможливо виконати %s"

#~ msgid "couldn't execute %s -d"
#~ msgstr "неможливо виконати %s -d"

#~ msgid ""
#~ "\n"
#~ "Report %s bugs to %s\n"
#~ msgstr ""
#~ "\n"
#~ "Про вади у %s повідомляйте на адресу %s.\n"

#~ msgid "warning: --retry is useful mainly when following by name"
#~ msgstr ""
#~ "попередження: ключ --retry корисний лише при слідуванні за назвою файла"

#~ msgid "using single-precision arithmetic"
#~ msgstr "використання арифметики з фіксованою точністю"

#~ msgid "using arbitrary-precision arithmetic"
#~ msgstr "використання арифметики з довільною точністю"

#~ msgid ""
#~ "simple_strtod_human:\n"
#~ "  input string: '%s'\n"
#~ "  locale decimal-point: '%s'\n"
#~ msgstr ""
#~ "simple_strtod_human:\n"
#~ "  рядок вхідних даних: «%s»\n"
#~ "  символ відокремлення дробової частини локалі: «%s»\n"

#~ msgid ""
#~ "  parsed numeric value: %Lf\n"
#~ "  input precision = %d\n"
#~ msgstr ""
#~ "  оброблене числове значення: %Lf\n"
#~ "  точність вхідних даних = %d\n"

#~ msgid "  Auto-scaling, found 'i', switching to base %d\n"
#~ msgstr "  Автомасштабування, виявлено «i», перемикаємося на основу %d\n"

#~ msgid "  suffix power=%d^%d = %Lf\n"
#~ msgstr "  степінь у суфіксі=%d^%d = %Lf\n"

#~ msgid "  returning value: %Lf (%LG)\n"
#~ msgstr "  повертаємо значення %Lf (%LG)\n"

#~ msgid "double_to_human:\n"
#~ msgstr "double_to_human:\n"

#~ msgid "  no scaling, returning (grouped) value: %'.*Lf\n"
#~ msgstr "  без масштабування, повертаємо значення (з групуванням) %'.*Lf\n"

#~ msgid "  no scaling, returning value: %.*Lf\n"
#~ msgstr "  без масштабування, повертаємо значення %.*Lf\n"

#~ msgid "  scaled value to %Lf * %0.f ^ %d\n"
#~ msgstr "  масштабоване значення до %Lf * %0.f ^ %d\n"

#~ msgid "  after rounding, value=%Lf * %0.f ^ %d\n"
#~ msgstr "  після округлення, значення=%Lf * %0.f ^ %d\n"

#~ msgid "  returning value: '%s'\n"
#~ msgstr "  повернутаємо значення «%s»\n"

#~ msgid "Usage: %s [OPTIONS] [NUMBER]\n"
#~ msgstr "Використання: %s [ПАРАМЕТРИ] [ЧИСЛО]\n"

#~ msgid ""
#~ "  --from=UNIT     auto-scale input numbers to UNITs. Default is 'none'.\n"
#~ "                  See UNIT below.\n"
#~ "  --from-unit=N   specify the input unit size (instead of the default "
#~ "1).\n"
#~ "  --to=UNIT       auto-scale output numbers to UNITs.\n"
#~ "                  See UNIT below.\n"
#~ "  --to-unit=N     the output unit size (instead of the default 1).\n"
#~ "  --round=METHOD  the rounding method to use when scaling. METHOD can "
#~ "be:\n"
#~ "                  up, down, from-zero (default), towards-zero, nearest\n"
#~ "  --suffix=SUFFIX add SUFFIX to output numbers, and accept optional "
#~ "SUFFIX\n"
#~ "                  in input numbers.\n"
#~ "  --padding=N     pad the output to N characters.\n"
#~ "                  Positive N will right-aligned. Negative N will left-"
#~ "align.\n"
#~ "                  Note: if the output is wider than N, padding is "
#~ "ignored.\n"
#~ "                  Default is to automatically pad if whitespace is "
#~ "found.\n"
#~ "  --grouping      group digits together (e.g. 1,000,000).\n"
#~ "                  Uses the locale-defined grouping (i.e. have no effect\n"
#~ "                  in C/POSIX locales).\n"
#~ "  --header[=N]    print (without converting) the first N header lines.\n"
#~ "                  N defaults to 1 if not specified.\n"
#~ "  --field N       replace the number in input field N (default is 1)\n"
#~ "  -d, --delimiter=X  use X instead of whitespace for field delimiter\n"
#~ "  --format=FORMAT use printf style floating-point FORMAT.\n"
#~ "                  See FORMAT below for details.\n"
#~ "  --invalid=MODE  failure mode for invalid numbers: MODE can be:\n"
#~ "                  abort (the default), fail, warn, ignore.\n"
#~ "  --debug         print warnings about invalid input.\n"
#~ "  \n"
#~ msgstr ""
#~ "  --from=ОДИНИЦЯ  автоматично масштабувати вхідні числа за ОДИНИЦЕЮ. "
#~ "Типове\n"
#~ "                  значення -- 'none'. Опис ОДИНИЦІ наведено нижче.\n"
#~ "  --from-unit=N   вказати розмір вхідної одиниці (типовим є 1).\n"
#~ "  --to=ОДИНИЦЯ    автоматично масштабувати виведені числа за ОДИНИЦЕЮ. "
#~ "Опис\n"
#~ "                  ОДИНИЦІ наведено нижче.\n"
#~ "  --to-unit=N     розмір одиниці виведення (замість типового значення "
#~ "1).\n"
#~ "  --round=СПОСІБ  спосіб округлення під час масштабування. Варіанти:\n"
#~ "                  up (до більшого), down (до меншого), from-zero (до "
#~ "дальшого\n"
#~ "                  до нуля, типовий), towards-zero (до ближчого до "
#~ "нуля),                   nearest (до найближчого цілого\n"
#~ "  --suffix=СУФІКС додати СУФІКС до виведених чисел і використовувати "
#~ "СУФІКС\n"
#~ "                  у вхідних даних.\n"
#~ "  --padding=N     доповнити виведені дані до N символів.\n"
#~ "                  Використання додатного N призведе до вирівнювання "
#~ "праворуч\n"
#~ "                  Від’ємні N вирівнюватимуть дані ліворуч.\n"
#~ "                  Зауваження: якщо виведені дані будуть довшими за N,\n"
#~ "                  доповнення не відбуватиметься. Типовим є автоматичне "
#~ "доповнення,\n"
#~ "                  якщо буде виявлено пробіли.\n"
#~ "  --grouping      групувати цифри (наприклад, 1.000.000).\n"
#~ "                  Використовується визначене локаллю групування (тобто не "
#~ "впливає\n"
#~ "                  на локалі C/POSIX).\n"
#~ "  --header[=N]    вивести (без перетворення) перші N рядків заголовка.\n"
#~ "                  Якщо не вказано, типовим значенням N є 1.\n"
#~ "  --field N       замінити число у вхідному полі N (типовим є 1)\n"
#~ "  -d, --delimiter=X  використовувати X замість пробілу для відокремлення "
#~ "полів\n"
#~ "  --format=ФОРМАТ використовувати форматування у стилі printf.\n"
#~ "                  Опис ФОРМАТу наведено нижче.\n"
#~ "  --invalid=РЕЖИМ режим обробки некоректних символів. Можливі режими:\n"
#~ "                  abort (перервати обробку, типовий), fail (обробити з "
#~ "помилками),\n"
#~ "                  warn (попередити), ignore (ігнорувати).\n"
#~ "  --debug         виводити попередження щодо некоректних вхідних даних.\n"
#~ "  \n"

#~ msgid ""
#~ "\n"
#~ "UNIT options:\n"
#~ "  none       No auto-scaling is done. Suffixes will trigger an error.\n"
#~ "  auto       Accept optional single-letter/two-letter suffix:\n"
#~ "             1K  = 1000\n"
#~ "             1Ki = 1024\n"
#~ "             1M  = 1000000\n"
#~ "             1Mi = 1048576\n"
#~ "  si         Accept optional single letter suffix:\n"
#~ "             1K = 1000\n"
#~ "             1M = 1000000\n"
#~ "             ...\n"
#~ "  iec        Accept optional single letter suffix:\n"
#~ "             1K = 1024\n"
#~ "             1M = 1048576\n"
#~ "             ...\n"
#~ "  iec-i      Accept optional two-letter suffix:\n"
#~ "             1Ki = 1024\n"
#~ "             1Mi = 1048576\n"
#~ "             ...\n"
#~ "\n"
#~ msgstr ""
#~ "\n"
#~ "Варіанти ОДИНИЦІ:\n"
#~ "  none       без автоматичного масштабування. Використання суфіксів\n"
#~ "             призводитиме до повідомлення про помилку.\n"
#~ "  auto       Використовувати додатковий одно- або дволітерний суфікс:\n"
#~ "             1K  = 1000\n"
#~ "             1Ki = 1024\n"
#~ "             1M  = 1000000\n"
#~ "             1Mi = 1048576\n"
#~ "  si         Використовувати додатковий однолітерний суфікс:\n"
#~ "             1K = 1000\n"
#~ "             1M = 1000000\n"
#~ "             ...\n"
#~ "  iec        Використовувати додатковий однолітерний суфікс:\n"
#~ "             1K = 1024\n"
#~ "             1M = 1048576\n"
#~ "             ...\n"
#~ "  iec-i      Використовувати додатковий дволітерний суфікс:\n"
#~ "             1Ki = 1024\n"
#~ "             1Mi = 1048576\n"
#~ "             ...\n"
#~ "\n"

#~ msgid ""
#~ "format String:\n"
#~ "  input: %s\n"
#~ "  grouping: %s\n"
#~ "  padding width: %ld\n"
#~ "  alignment: %s\n"
#~ "  prefix: '%s'\n"
#~ "  suffix: '%s'\n"
#~ msgstr ""
#~ "Рядок форматування:\n"
#~ "  вхідні дані: %s\n"
#~ "  групування: %s\n"
#~ "  розмір доповнення: %ld\n"
#~ "  вирівнювання: %s\n"
#~ "  префікс: «%s»\n"
#~ "  суфікс: «%s»\n"

#~ msgid ""
#~ "formatting output:\n"
#~ "  value: %Lf\n"
#~ "  humanized: '%s'\n"
#~ msgstr ""
#~ "форматуємо виведення:\n"
#~ "  значення: %Lf\n"
#~ "  у зручному форматі: «%s»\n"

#~ msgid "  After padding: '%s'\n"
#~ msgstr "  Після доповнення: «%s»\n"

#~ msgid "trimming suffix '%s'\n"
#~ msgstr "обрізаємо суфікс «%s»\n"

#~ msgid "no valid suffix found\n"
#~ msgstr "не знайдено коректного суфікса\n"

#~ msgid "setting Auto-Padding to %ld characters\n"
#~ msgstr "встановлюємо автоматичне доповнення до %ld символів\n"

#~ msgid ""
#~ "extracting Fields:\n"
#~ "  input: '%s'\n"
#~ "  field: %d\n"
#~ msgstr ""
#~ "видобуваємо поля:\n"
#~ "  вхідні дані: «%s»\n"
#~ "  поле: %d\n"

#~ msgid ""
#~ "  TOO FEW FIELDS!\n"
#~ "  prefix: '%s'\n"
#~ msgstr ""
#~ "  НАДТО МАЛО ПОЛІВ!\n"
#~ "  префікс: «%s»\n"

#~ msgid ""
#~ "  prefix: '%s'\n"
#~ "  number: '%s'\n"
#~ "  suffix: '%s'\n"
#~ msgstr ""
#~ "  префікс: «%s»\n"
#~ "  номер: «%s»\n"
#~ "  суфікс: «%s»\n"

#~ msgid "reading %s"
#~ msgstr "читання %s"

#~ msgid "writing %s"
#~ msgstr "запис %s"

#~ msgid "closing %s"
#~ msgstr "закриття %s"

#~ msgid "accessing %s"
#~ msgstr "звернення до %s"

#~ msgid "opening %s"
#~ msgstr "відкриття %s"

#~ msgid ""
#~ "  -x, --one-file-system    skip directories on different file systems\n"
#~ "  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n"
#~ "      --exclude=PATTERN    exclude files that match PATTERN\n"
#~ "  -d, --max-depth=N     print the total for a directory (or file, with --"
#~ "all)\n"
#~ "                          only if it is N or fewer levels below the "
#~ "command\n"
#~ "                          line argument;  --max-depth=0 is the same as\n"
#~ "                          --summarize\n"
#~ msgstr ""
#~ "  -x, --one-file-system   пропускати каталоги на інших файлових системах\n"
#~ "  -X, --exclude-from=ФАЙЛ виключати файли, що збігаються з якимось\n"
#~ "                          шаблоном з ФАЙЛА\n"
#~ "      --exclude=ШАБЛОН    виключати файли, що збігаються з ШАБЛОНОМ\n"
#~ "      --max-depth=N       виводити зведення про каталог (або файл, з --"
#~ "all),\n"
#~ "                          лише якщо він на N або менше рівнів нижче,\n"
#~ "                          ніж аргумент командного рядка; --max-depth=0\n"
#~ "                          еквівалентно до --summarize\n"

#~ msgid ""
#~ "  none, off       never make backups (even if --backup is given)\n"
#~ "  numbered, t     make numbered backups\n"
#~ "  existing, nil   numbered if numbered backups exist, simple otherwise\n"
#~ "  simple, never   always make simple backups\n"
#~ "\n"
#~ msgstr ""
#~ "  none, off       ніколи не створювати резервних копій (навіть якщо\n"
#~ "                  вказаний ключ --backup)\n"
#~ "  numbered, t     створювати нумеровані копії\n"
#~ "  existing, nil   якщо існують нумеровані копії, то створювати\n"
#~ "                  нумеровані інакше створювати прості\n"
#~ "  simple. never   завжди створювати прості копії\n"
#~ "\n"

#~ msgid ""
#~ "WARNING: --page-increment is deprecated; use --line-increment instead"
#~ msgstr ""
#~ "ПОПЕРЕДЖЕННЯ: --page-increment вважаєте застарілим; вам варто "
#~ "скористатися --line-increment"

#~ msgid "All arguments to long options are mandatory for short options.\n"
#~ msgstr "Всі аргументи для довгих ключів є обов'язковими для коротких.\n"

#~ msgid ""
#~ "\n"
#~ "RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
#~ "BYTES is hexadecimal with 0x or 0X prefix, and may have a multiplier "
#~ "suffix:\n"
#~ "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
#~ "Adding a z suffix to any type displays printable characters at the end of "
#~ "each\n"
#~ "output line.\n"
#~ msgstr ""
#~ "\n"
#~ "ОСНОВА може бути d (десятковою), o (вісімковою), x (шістнадцятковою) або\n"
#~ "n (не виводити зсув).  Н з префіксом 0x або 0X сприймається як\n"
#~ "шістнадцяткове, з суфіксом b множиться на 512, з суфіксом kB — 1000, K — "
#~ "1024,\n"
#~ "MB — 1000*1000, M — 1024*1024, GB — 1000*1000*1000, G — 1024*1024*1024, "
#~ "те саме\n"
#~ "для T, P, E, Z, Y. Якщо додати до будь-якого формату суфікс z,\n"
#~ "наприкінці кожного рядка будуть виводитись друковані символи.\n"

#~ msgid ""
#~ "Option --string without a number implies 3; option --width without a "
#~ "number\n"
#~ "implies 32.  By default, od uses -A o -t oS -w16.\n"
#~ msgstr ""
#~ "Параметр --string без аргументу означає 3, --width — 32.\n"
#~ "Типово od використовуються ключі -A o -t oS -w16.\n"

#~ msgid "Usage: %s [OPTION]... FILE\n"
#~ msgstr "Використання: %s [КЛЮЧ]... [ФАЙЛ]\n"

#~ msgid "Password:"
#~ msgstr "Пароль:"

#~ msgid "getpass: cannot open /dev/tty"
#~ msgstr "getpass: не вдалося відкрити /dev/tty"

#~ msgid "cannot set groups"
#~ msgstr "не вдалося встановити групи"

#~ msgid "cannot set group id"
#~ msgstr "не вдалося встановити груповий id"

#~ msgid "cannot set user id"
#~ msgstr "не вдалося встановити id користувача"

#~ msgid "Usage: %s [OPTION]... [-] [USER [ARG]...]\n"
#~ msgstr "Використання: %s [КЛЮЧ]... [-] [КОРИСТУВАЧ [АРГ]...]\n"

#~ msgid ""
#~ "Change the effective user id and group id to that of USER.\n"
#~ "\n"
#~ "  -, -l, --login               make the shell a login shell\n"
#~ "  -c, --command=COMMAND        pass a single COMMAND to the shell with -"
#~ "c\n"
#~ "  -f, --fast                   pass -f to the shell (for csh or tcsh)\n"
#~ "  -m, --preserve-environment   do not reset environment variables\n"
#~ "  -p                           same as -m\n"
#~ "  -s, --shell=SHELL            run SHELL if /etc/shells allows it\n"
#~ msgstr ""
#~ "Встановлює ефективні id користувача та групи як у КОРИСТУВАЧА.\n"
#~ "\n"
#~ "  -, -l, --login               використовувати оболонку як оболонку "
#~ "входу\n"
#~ "  -c, --commmand=КОМАНДА       передати оболонці КОМАНДУ за допомогою -c\n"
#~ "  -f, --fast                   передати оболонці -f (для csh або tcsh)\n"
#~ "  -m, --preserve-environment   не перевстановлювати змінні оточення\n"
#~ "  -p                           синонім для -m\n"
#~ "  -s, --shell=ОБОЛОНКА         запустити ОБОЛОНКУ, якщо дозволяє /etc/"
#~ "shells\n"

#~ msgid ""
#~ "\n"
#~ "A mere - implies -l.   If USER not given, assume root.\n"
#~ msgstr ""
#~ "\n"
#~ "Просто знак мінус означає -l.  Якщо КОРИСТУВАЧ не вказаний,\n"
#~ "вважається root.\n"

#~ msgid "user %s does not exist"
#~ msgstr "користувач %s не існує"

#~ msgid "incorrect password"
#~ msgstr "неправильний пароль"

#~ msgid "using restricted shell %s"
#~ msgstr "використовується обмежена оболонка %s"

#~ msgid "warning: cannot change directory to %s"
#~ msgstr "попередження: не вдалося змінити каталог на %s"

#~ msgid ""
#~ "\n"
#~ "Examples:\n"
#~ "  %s /usr/bin/sort       Output \"sort\".\n"
#~ "  %s include/stdio.h .h  Output \"stdio\".\n"
#~ msgstr ""
#~ "\n"
#~ "Приклади:\n"
#~ "  %s /usr/bin/sort       Виводить \"sort\".\n"
#~ "  %s include/stdio.h .h  Виводить \"stdio\".\n"

#~ msgid ""
#~ "Usage: %s NAME\n"
#~ "  or:  %s OPTION\n"
#~ msgstr ""
#~ "Використання: %s НАЗВА\n"
#~ "       або:    %s КЛЮЧ\n"

#~ msgid "--relative-base requires --relative-to"
#~ msgstr "Для --relative-base слід вказати --relative-to"

#~ msgid ""
#~ "Change the group of each FILE to GROUP.\n"
#~ "With --reference, change the group of each FILE to that of RFILE.\n"
#~ "\n"
#~ "  -c, --changes          like verbose but report only when a change is "
#~ "made\n"
#~ "      --dereference      affect the referent of each symbolic link (this "
#~ "is\n"
#~ "                         the default), rather than the symbolic link "
#~ "itself\n"
#~ msgstr ""
#~ "Змінює групу власника кожного файла ФАЙЛ на ГРУПА.\n"
#~ "З ключем  --reference, змінює групу кожного ФАЙЛУ на групу ЗФАЙЛУ.\n"
#~ "\n"
#~ "  -c, --changes          як і verbose, але виводити лише при змінах\n"
#~ "      --dereference      впливає на ціль кожного символічного посилання\n"
#~ "                         (типово), а не на саме символічне посилання\n"

#~ msgid ""
#~ "  -f, --silent, --quiet  suppress most error messages\n"
#~ "      --reference=RFILE  use RFILE's group rather than specifying a\n"
#~ "                         GROUP value\n"
#~ "  -R, --recursive        operate on files and directories recursively\n"
#~ "  -v, --verbose          output a diagnostic for every file processed\n"
#~ "\n"
#~ msgstr ""
#~ "  -f, --silent, --quiet  не виводити більшість повідомлень про помилки\n"
#~ "      --reference=ЗФАЙЛУ використовувати групу ЗФАЙЛУ замість явного\n"
#~ "                         вказування ГРУПИ\n"
#~ "  -R, --recursive        рекурсивно обробляти файли та каталоги\n"
#~ "  -v, --verbose          виводити діагностичні повідомлення для кожного "
#~ "файла\n"

#~ msgid ""
#~ "Change the mode of each FILE to MODE.\n"
#~ "\n"
#~ "  -c, --changes           like verbose but report only when a change is "
#~ "made\n"
#~ msgstr ""
#~ "Змінює режим кожного ФАЙЛУ на вказаний РЕЖИМ.\n"
#~ "\n"
#~ "  -c, --changes           як verbose, але повідомляти, лише якщо справді\n"
#~ "                          внесена зміна\n"

#~ msgid ""
#~ "      --no-preserve-root  do not treat `/' specially (the default)\n"
#~ "      --preserve-root     fail to operate recursively on `/'\n"
#~ msgstr ""
#~ "      --no-preserve-root  не обробляти `/' особливим чином (типово)\n"
#~ "      --preserve-root     не обробляти рекурсивно `/'\n"

#~ msgid ""
#~ "  -f, --silent, --quiet   suppress most error messages\n"
#~ "  -v, --verbose           output a diagnostic for every file processed\n"
#~ "      --reference=RFILE   use RFILE's mode instead of MODE values\n"
#~ "  -R, --recursive         change files and directories recursively\n"
#~ msgstr ""
#~ "  -f, --silent, --quiet   не виводити більшість повідомлень про помилки\n"
#~ "  -v, --verbose           виводити діагностичні повідомлення для усіх "
#~ "файлів\n"
#~ "      --reference=ЗФАЙЛ   режим ЗФАЙЛУ замість явного вказування РЕЖИМУ\n"
#~ "  -R, --recursive         рекурсивно обробляти файли та каталоги\n"

#~ msgid ""
#~ "Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
#~ "With --reference, change the owner and group of each FILE to those of "
#~ "RFILE.\n"
#~ "\n"
#~ "  -c, --changes          like verbose but report only when a change is "
#~ "made\n"
#~ "      --dereference      affect the referent of each symbolic link (this "
#~ "is\n"
#~ "                         the default), rather than the symbolic link "
#~ "itself\n"
#~ msgstr ""
#~ "Змінює власника та/або групу кожного ФАЙЛУ на ВЛАСНИКА та/або ГРУПУ.\n"
#~ "З ключем --reference, змінює власника та групу кожного ФАЙЛУ на власника "
#~ "та\n"
#~ "групу ЗФАЙЛУ.\n"
#~ "\n"
#~ "  -c, --change           те саме що й --verbose, але повідомляє лише "
#~ "коли\n"
#~ "                         були внесені зміни\n"
#~ "      --dereference      змінювати файл, на який вказує символьне\n"
#~ "                         посилання, а не саме посилання (типово)\n"

#~ msgid ""
#~ "  -f, --silent, --quiet  suppress most error messages\n"
#~ "      --reference=RFILE  use RFILE's owner and group rather than\n"
#~ "                         specifying OWNER:GROUP values\n"
#~ "  -R, --recursive        operate on files and directories recursively\n"
#~ "  -v, --verbose          output a diagnostic for every file processed\n"
#~ "\n"
#~ msgstr ""
#~ "  -f, --silent, --quiet  не виводити більшість повідомлень про помилки\n"
#~ "      --reference=ЗФАЙЛ  використовувати власника та групу ЗФАЙЛУ "
#~ "замість\n"
#~ "                         явного вказування ВЛАСНИКА:ГРУПИ\n"
#~ "  -R, --recursive        рекурсивно обробляти файли та каталоги\n"
#~ "  -v, --verbose          виводити діагностичні повідомлення для кожного "
#~ "файла\n"

#~ msgid ""
#~ "\n"
#~ "SIZE may be (or may be an integer optionally followed by) one of "
#~ "following:\n"
#~ "KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, "
#~ "Y.\n"
#~ msgstr ""
#~ "\n"
#~ "РОЗМІР може бути таким (або це може бути ціле число, за яким\n"
#~ "може слідувати одне з переліченого):\n"
#~ "KB 1000, K 1024, MB 1000*1000, M 1024*1024 тощо для G, T, P, E, Z, Y.\n"
